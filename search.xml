<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>About Me</title>
    <url>/2020/07/21/about/</url>
    <content><![CDATA[<h2 id="Skykey"><a href="#Skykey" class="headerlink" title="Skykey"></a>Skykey</h2><h3 id="Hello-World-👋"><a href="#Hello-World-👋" class="headerlink" title="Hello,World! 👋"></a>Hello,World! 👋</h3><p>Hi, I’m Skykey 😉, a programmer 👨🏻‍💻 from China 🇨🇳. I’m an open-source profession and always develop in Cpp/Qt. Currently, I’m working on <a href="https://github.com/QtDocumentCN/QtDocumentCN">QtDocCN</a>. Besides programming, I like delicious food 🥗🥩🌮🍣 and doing sports 🏃⛹️‍♂️🏋🏼‍♂️.</p>
<span id="more"></span>

<p>​    <img align="right" alt="GIF" src="https://media.giphy.com/media/iIqmM5tTjmpOB9mpbn/giphy.gif" /></p>
<p><strong>Current Status Quo</strong></p>
<ul>
<li>👨🏻‍💻 I’m currently working on <a href="https://github.com/QtDocumentCN/QtDocumentCN">QtDocCN</a>.</li>
<li>🌱 I’m currently learning C++/Qt.</li>
<li>🤔  I hope to be a linux system development programmer. 🐧</li>
<li>💬 Ask me about anything and I would like to answer.</li>
<li>📫 Please email via <a href="zcxzxlc@163.com">zcxzxlc@163.com</a> to reach me.</li>
</ul>
<hr>
<p><img src="https://github-readme-stats.vercel.app/api?username=skykeyjoker&show_icons=true&hide_border=true" alt="stats"></p>
<p><img src="https://gitee.com/skykeyjoker/PicCloud/raw/master/img/dino.gif" alt="dino"></p>
]]></content>
  </entry>
  <entry>
    <title>C++/QT PC客户端面试题</title>
    <url>/2022/06/20/C++%E9%9D%A2%E8%AF%95/</url>
    <content><![CDATA[<h1 id="C-QT-PC客户端面试题"><a href="#C-QT-PC客户端面试题" class="headerlink" title="C++/QT PC客户端面试题"></a>C++/QT PC客户端面试题</h1><p>整理记录一些春招时面试字节跳动/阿里云 C++/Qt PC客户端相关岗位的面试题，包含面试中遇到后整理的题目和面试前准备的资料。</p>
<span id="more"></span>

<h2 id="父子继承时候，它构造函数和析构函数的顺序？析构时候，如何让父子类里所有的析构都调用一遍？"><a href="#父子继承时候，它构造函数和析构函数的顺序？析构时候，如何让父子类里所有的析构都调用一遍？" class="headerlink" title="父子继承时候，它构造函数和析构函数的顺序？析构时候，如何让父子类里所有的析构都调用一遍？"></a>父子继承时候，它构造函数和析构函数的顺序？析构时候，如何让父子类里所有的析构都调用一遍？</h2><p>构造时，先调用父类的构造函数，再调用派生类的构造函数。建楼从地基开始。</p>
<p>析构时，先调用子类的析构函数，再调用父类的析构函数。拆楼从最高层开始拆。</p>
<p>若使用父类指针指向子类对象，delete该对象时，只会调用父类的析构函数，此时可将父类的析构函数设置为虚函数。若使用子类指针指向父类对象，delete该对象时，会先调用子类析构函数，再调用父类析构函数。</p>
<h2 id="一个函数，如何让它在main函数之前执行？"><a href="#一个函数，如何让它在main函数之前执行？" class="headerlink" title="一个函数，如何让它在main函数之前执行？"></a>一个函数，如何让它在main函数之前执行？</h2><ol>
<li><p>全局对象的构造函数，main之前声明一个全局对象。</p>
</li>
<li><p>全局变量、对象和静态变量、对象的空间分配和赋初值。</p>
</li>
<li><p>进程启动后，要执行一些初始化代码，然后跳转到main函数执行。main函数执行完毕后，返回到入口函数，入口函数进行清理工作，包括全局变量的析构、堆销毁、关闭I/O等，然后等待系统关闭进程。</p>
</li>
<li><p>使用关键字<code>__attribute__</code>，让一个函数在主函数之前运行，进行一些数据初始化、模块加载验证等。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello world\n&quot;</span>);</span><br><span class="line">    <span class="comment">//exit(0);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__attribute__((constructor))<span class="function"><span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;before\n&quot;</span>);</span><br><span class="line">    <span class="built_in">func</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__attribute__((destructor))<span class="function"><span class="keyword">void</span> <span class="title">after</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;after\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main\n&quot;</span>); <span class="comment">//从运行结果来看，并没有执行main函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="可以在C-的成员函数里调用delete-this吗"><a href="#可以在C-的成员函数里调用delete-this吗" class="headerlink" title="可以在C++的成员函数里调用delete this吗?"></a>可以在C++的成员函数里调用delete this吗?</h2><p>能够调用。在调用后还可以调用该对象的其他方法，但是前提是：被调用的方法不涉及这个对象的数据成员和虚函数。</p>
<p><strong>根本原因</strong>在于delete操作符的功能和类对象的内存模型。在类对象的内存空间中，只有数据成员和虚函数表指针，并不包含代码内容，类的成员函数单独放在代码段中。</p>
<p>在类的析构函数中调用delete this会导致堆栈溢出。delete的本质是为将被释放的内存调用一个或多个析构函数，而析构函数中又调用delete this，形成无限递归，造成堆栈溢出。</p>
<h2 id="class-A-Class-B-A-a-能不能允许？"><a href="#class-A-Class-B-A-a-能不能允许？" class="headerlink" title="class A; Class B{ A a; };能不能允许？"></a><code>class A; Class B&#123; A a; &#125;;</code>能不能允许？</h2><p>不能。class A未定义，为不完整的类型，不允许。</p>
<h2 id="C-的类型转换有哪些"><a href="#C-的类型转换有哪些" class="headerlink" title="C++的类型转换有哪些"></a>C++的类型转换有哪些</h2><ol>
<li>C风格的强制类型转换。(typename)Var；</li>
<li>四种新类型转换：<ul>
<li><strong>static_cast<newType>(data)</strong> ：<ul>
<li>近似类型转换，如int转double，const转非const，向上转型</li>
<li>void*指针与具体类型指针之间的转换，如void*转int*</li>
<li>有转换构造函数或者类型转换函数的类与其他类型之间的转换</li>
</ul>
</li>
<li>**const_cast<newType>(data) **：<ul>
<li>用来将const/volatile 类型转换为非 const/volatile 类型。</li>
</ul>
</li>
<li>**reinterpret_cast<newType>(data)**：<ul>
<li>可以认为是 static_cast 的一种补充，一些 static_cast 不能完成的转换，就可以用 reinterpret_cast 来完成，例如<strong>两个具体类型指针之间的转换</strong>、<strong>int和指针之间的转换。非常简单粗暴，但是风险很高。</strong></li>
</ul>
</li>
<li>**dynamic_cast<newType>(data)**：<ul>
<li>用于在类的继承层次之间进行类型转换，它既允许向上转型（Upcasting），就是把继承类指针转换为基类指针；也允许向下转型（Downcasting）。向上转型是无条件的，不会进行任何检测，所以都能成功；向下转型的前提必须是安全的，要借助RTTI进行检测，所有只有一部分能成功。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="C-有哪些智能指针"><a href="#C-有哪些智能指针" class="headerlink" title="C++有哪些智能指针"></a>C++有哪些智能指针</h2><p>share_ptr, unique_ptr, weak_ptr。</p>
<p><strong>它们三者有什么区别？</strong></p>
<p>shared_ptr,unique_ptr,weak_ptr。第一个实现原理是同一个内存空间每多一个指针指向就计数加1，如果计数变为0就释放内存空间。第二个是计数只能为1，第三个只能指向该内存空间而没有所有权。主要用于辅助第一个指针，防止出现互锁。Shared_ptr当用普通指针初始化的时候，只能使用一次普通指针。它还可以自定义释放函数。Unique_ptr没有拷贝构造函数。借助 weak_ptr 类型指针， 我们可以获取 shared_ptr 指针的一些状态信息，比如有多少指向相同的 shared_ptr 指针、shared_ptr 指针指向的堆内存是否已经被释放等等。在构建 weak_ptr 指针对象时，可经常利用已有的 shared_ptr 指针为其初始化。</p>
<p><strong>为什么需要智能指针？它在实际工程中有什么作用？</strong></p>
<p>为了防止内存泄漏，设置的自动回收机制。</p>
<p><strong>说一下shared_ptr的底层实现？</strong></p>
<p>引用计数，每多一个智能指向同一个内存，就把计数加1，当计数减到0的时候就释放该指针。当该指针作为形参传递的时候，计数会加1，当他出该函数时会自动减一。</p>
<p><strong>Weak_ptr的作用？</strong></p>
<p>获取 shared_ptr 指针的一些状态信息，比如有多少指向相同的 shared_ptr 指针、shared_ptr 指针指向的堆内存是否已经被释放等等。另外防止循环引用。</p>
<p><strong>你刚才说到循环引用，那你口述一个循环引用的实例。</strong></p>
<p>比如说A、B两个类，两个类里面分别定义了一个对方类的智能指针，然后在主函数里面首先定义两个类的智能指针，然后分别把两个指针分别赋予对方的成员指针里，这样就形成了循环引用。</p>
<p>循环引用的问题是：一旦b出作用域，引用计数减一，导致b里面的a永远不会减一，导致a智能指针空间永远释放不掉，然后a出作用域时，a引用计数减一，a最终没释放，它里面的b也就不可能释放掉，最后a b都是1无法释放。</p>
<h2 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h2><p><img src="https://images2018.cnblogs.com/blog/1192097/201807/1192097-20180718181338035-1670765431.png" alt="img"></p>
<h2 id="C-多线程死锁"><a href="#C-多线程死锁" class="headerlink" title="C++多线程死锁"></a>C++多线程死锁</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;thread&gt;</span><br><span class="line">#include &lt;mutex&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="function"><span class="title">work1</span>(<span class="params">std::mutex&amp; mylock1, std::mutex&amp; mylock2</span>)</span> &#123;</span><br><span class="line">	<span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">		mylock1.lock();</span><br><span class="line">		mylock2.lock();</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;work1 : &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">		mylock2.unlock();</span><br><span class="line">		mylock1.unlock();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="function"><span class="title">work2</span>(<span class="params">std::mutex&amp; mylock1, std::mutex&amp; mylock2</span>)</span> &#123;</span><br><span class="line">	<span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">		mylock2.lock();</span><br><span class="line">		mylock1.lock();</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;work2 : &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">		mylock1.unlock();</span><br><span class="line">		mylock2.unlock();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="function"><span class="title">main</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="attr">std</span>::mutex mylock1, mylock2;</span><br><span class="line">	int ans = <span class="number">0</span>;</span><br><span class="line">	std::thread t1(work1, <span class="attr">std</span>::ref(mylock1), <span class="attr">std</span>::ref(mylock2));</span><br><span class="line">	std::thread t2(work2, <span class="attr">std</span>::ref(mylock1), <span class="attr">std</span>::ref(mylock2));</span><br><span class="line">	t1.join();</span><br><span class="line">	t2.join();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>由于==交叉加锁==，使得两个锁都在等待对方解锁而造成的死锁，运行结果如下图所示：</strong></p>
<p><strong>解决这个死锁的问题只是把加锁的顺序改过来就可以了，然后也可以用std::lock函数来创建多个互斥锁，用法也很简单，首先创建两个互斥锁lock1和lock2，那么std::lock(lock1,lock2)这句代码就相当于lock1.lock();lock2.lock();，最后不要忘了对两个锁的unlock，其实也可以搭配lock_guard()来使用，因为lock_guard内部就有析构函数来unlock，所以在lock_guard中引用std::adopt_lock参数（作用是告诉编译器我已经lock过了，不需要再重复lock了）就可以实现省去后面的unlock语句了。代码如下：</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;thread&gt;</span><br><span class="line">#include &lt;mutex&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="function"><span class="title">work1</span>(<span class="params">std::mutex&amp; mylock1, std::mutex&amp; mylock2</span>)</span> &#123;</span><br><span class="line">	<span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">		<span class="attr">std</span>::lock(mylock1, mylock2);</span><br><span class="line">		std::lock_guard&lt;std::mutex&gt; lock1(mylock1, <span class="attr">std</span>::adopt_lock);</span><br><span class="line">		std::lock_guard&lt;std::mutex&gt; lock2(mylock2, <span class="attr">std</span>::adopt_lock);</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;work1 : &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="function"><span class="title">work2</span>(<span class="params">std::mutex&amp; mylock1, std::mutex&amp; mylock2</span>)</span> &#123;</span><br><span class="line">	<span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">		<span class="attr">std</span>::lock(mylock1, mylock2);</span><br><span class="line">		std::lock_guard&lt;std::mutex&gt; lock1(mylock1, <span class="attr">std</span>::adopt_lock);</span><br><span class="line">		std::lock_guard&lt;std::mutex&gt; lock2(mylock2, <span class="attr">std</span>::adopt_lock);</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;work2 : &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="function"><span class="title">main</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="attr">std</span>::mutex mylock1, mylock2;</span><br><span class="line">	int ans = <span class="number">0</span>;</span><br><span class="line">	std::thread t1(work1, <span class="attr">std</span>::ref(mylock1), <span class="attr">std</span>::ref(mylock2));</span><br><span class="line">	std::thread t2(work2, <span class="attr">std</span>::ref(mylock1), <span class="attr">std</span>::ref(mylock2));</span><br><span class="line">	t1.join();</span><br><span class="line">	t2.join();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="TCP三次握手和四次挥手"><a href="#TCP三次握手和四次挥手" class="headerlink" title="TCP三次握手和四次挥手"></a>TCP三次握手和四次挥手</h2><h3 id="TCP与UDP"><a href="#TCP与UDP" class="headerlink" title="TCP与UDP"></a>TCP与UDP</h3><p><strong>用户数据报协议 UDP</strong>（User Datagram Protocol）：</p>
<ul>
<li><strong>UDP 在传送数据之前不需要先建立连接</strong>，远程主机在收到 UDP 报文后，不需要给出任何确认。</li>
<li>虽然 UDP <strong>不提供可靠交付</strong>，但在某些情况下 UDP 确是一种最有效的工作方式（一般用于即时通信），比如： QQ 语音、 QQ 视频 、直播等等</li>
</ul>
<p><strong>传输控制协议 TCP</strong>（Transmission Control Protocol）：</p>
<ul>
<li>TCP 提供<strong>面向连接</strong>的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。</li>
<li>TCP 不提供广播或多播服务。由于 TCP 要提供<strong>可靠</strong>的，面向连接的传输服务（TCP的可靠体现在TCP在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、流量控制、拥塞控制机制，在数据传完后，还会四次挥手断开连接用来节约系统资源），这不仅使协议数据单元的首部增大很多，还要占用许多处理机资源。</li>
<li>TCP <strong>一般用于文件传输、发送和接收邮件、远程登录等场景</strong>。</li>
</ul>
<h3 id="TCP报文格式"><a href="#TCP报文格式" class="headerlink" title="TCP报文格式"></a>TCP报文格式</h3><p><img src="https://segmentfault.com/img/remote/1460000039165596" alt="img"></p>
<p>首部固定部分各字段意义如下：</p>
<ul>
<li><p>1 - <strong>源端口和目的端口</strong>：各占 2 个字节，分别写入源端口和目的端口。IP 地址 + 端口号就可以确定一个进程地址</p>
</li>
<li><p>2 - <strong>序号/序列号（Sequense Number，SN）</strong>：在一个 TCP 连接中传送的字节流中的每一个字节都按顺序编号。该字段表示本报文段所发送的数据的第一个字节的序号。</p>
<p>初始序号称为 Init Sequense Number, ISN</p>
<p>（序号/序列号这个字段很重要，大家留个印象，下文会详细讲解）</p>
<p>例如，一报文段的序号是 101，共有 100 字节的数据。这就表明：本报文段的数据的第一个字节的序号是 101，最后一个字节的序号是 200。显然，下一个报文段的数据序号应当从 201 开始，即下一个报文段的序号字段值应为 201。</p>
</li>
<li><p>3 - <strong>确认号 ack</strong>：期望收到对方下一个报文段的第一个数据字节的序号。若确认号为 N，则表明：到序号 N-1 为止的所有数据都已正确收到。</p>
</li>
<li><p>4 - <strong>数据偏移</strong>（首部长度）：它指出 TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远。这个字段实际上是指出TCP报文段的首部长度。</p>
</li>
<li><p>5 - <strong>保留</strong>：占 6 位，应置为 0，保留为今后使用。</p>
</li>
</ul>
<p>保留位的右边还有 6 个控制位（重要），这是TCP 用来说明该报文段性质的：</p>
<ul>
<li><p><strong>紧急位 URG</strong>：当 URG = 1 时，表明此报文段中有紧急数据，是高优先级的数据，应尽快发送，不用在缓存中排队。该控制位需配合紧急指针使用（紧急指针指出本报文段中紧急数据的字节数）</p>
<p>举个例子：我们需要取消一个已经发送了很长程序的运行，因此用户从键盘发出中断命令。如果不使用紧急数据，那么这个指令将存储在接收 TCP 的缓存末尾，只有在所有的数据被处理完毕后这两个字符才被交付接收方的应用进程，这样做就无法实现立即中断。</p>
</li>
<li><p><strong>确认 ACK</strong>：仅当 ACK = 1 时确认号字段才有效，当 ACK = 0 时确认号无效。<strong>TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置为 1。</strong></p>
</li>
<li><p><strong>推送 PSH</strong>：当两个应用进程进行交互式的通信时，有时在一端的应用进程希望在键入一个命令后立即就能收到对方的响应。在这种情况下，TCP 就可以使用推送（push）操作。这时，发送方 TCP 把 PSH 置为 1，并立即创建一个报文段发送出去。接收方 TCP 收到 PSH = 1 的报文段，就尽快地交付接收应用进程。而不用等到整个缓存都填满了后再向上交付。</p>
</li>
<li><p><strong>复位 RST</strong>：当 RST = 1 时，表明 TCP 连接中出现了严重错误（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立传输连接。</p>
</li>
<li><p><strong>同步 SYN</strong>：SYN = 1 表示这是一个连接请求或连接接受报文。</p>
<p>当 SYN = 1 而 ACK = 0 时，表明这是一个连接请求报文段。对方若同意建立连接，则应在响应的报文段中使 SYN = 1 且 ACK = 1。</p>
</li>
<li><p><strong>终止 FIN</strong>：用来释放一个连接。当 FIN = 1时，表明此报文段的发送发的数据已发送完毕，并要求释放运输连接。</p>
</li>
</ul>
<h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p>主要作用就是为了确认双方的接收能力和发送能力是否正常、指定自己的**初始化序列号(Init Sequense Number, <code>ISN</code>)**为后面的可靠性传输做准备。</p>
<p><img src="https://segmentfault.com/img/remote/1460000039165594" alt="img"></p>
<p>只有经过三次握手才能确认双发的收发功能都正常，缺一不可：</p>
<ul>
<li><p>第一次握手（客户端发送 SYN 报文给服务器，服务器接收该报文）：客户端什么都不能确认；服务器确认了对方发送正常，自己接收正常</p>
</li>
<li><p>第二次握手（服务器响应 SYN 报文给客户端，客户端接收该报文）：</p>
<p>客户端确认了：自己发送、接收正常，对方发送、接收正常；</p>
<p>服务器确认了：对方发送正常，自己接收正常</p>
</li>
<li><p>第三次握手（客户端发送 ACK 报文给服务器）：</p>
<p>客户端确认了：自己发送、接收正常，对方发送、接收正常；</p>
<p>服务器确认了：自己发送、接收正常，对方发送、接收正常</p>
</li>
</ul>
<h4 id="三次握手过程中可以携带数据吗"><a href="#三次握手过程中可以携带数据吗" class="headerlink" title="三次握手过程中可以携带数据吗"></a>三次握手过程中可以携带数据吗</h4><p>第三次握手的时候，是可以携带数据的。但是，<strong>第一次、第二次握手绝对不可以携带数据</strong>，<strong>简单的记忆就是，请求连接/接收 即 <code>SYN = 1</code> 的时候不能携带数据</strong></p>
<h3 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h3><p><img src="https://segmentfault.com/img/remote/1460000039165595" alt="img"></p>
<h4 id="为什么要四次挥手"><a href="#为什么要四次挥手" class="headerlink" title="为什么要四次挥手"></a>为什么要四次挥手</h4><p>由于 TCP 的<strong>半关闭</strong>（half-close）特性，TCP 提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力。</p>
<p>任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入<strong>半关闭状态</strong>。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就<strong>完全关闭</strong>了TCP连接。</p>
<p>参考连接：<a href="https://segmentfault.com/a/1190000039165592">https://segmentfault.com/a/1190000039165592</a></p>
<h2 id="进程和线程的概念、区别"><a href="#进程和线程的概念、区别" class="headerlink" title="进程和线程的概念、区别"></a>进程和线程的概念、区别</h2><p>概念：</p>
<ol>
<li>进程是运行时程序的封装，是<strong>系统进行资源调度和分配的基本单位，实现了操作系统的并发</strong>。</li>
<li>线程是进程的子任务，是<strong>CPU调度和分派的基本单位，用于保证程序的实时性，实现进程内部的并发；线程是操作系统可识别的最小执行和调度单位</strong>。每个线程都独占一个<strong>虚拟处理器</strong>：独自的<strong>寄存器组</strong>，<strong>指令计数器</strong>和<strong>处理器状态</strong>。每个线程共享同一地址空间，打开的文件队列和其他内核资源。</li>
</ol>
<p>区别：</p>
<ol>
<li>一个线程只能属于一个进程，而一个进程可以有多个线程；</li>
<li>进程在执行过程中拥有独立的内存单元，而多个线程共享进程的内存</li>
<li>进程是资源分配的最小单位，线程是CPU调度的最小单位</li>
<li>系统开销：进程切换的开销也远大于线程切换的开销</li>
</ol>
<h2 id="进程线程间通信"><a href="#进程线程间通信" class="headerlink" title="进程线程间通信"></a>进程线程间通信</h2><p>进程间通信主要包括<strong>管道</strong>、<strong>系统IPC</strong>（<strong>消息队列</strong>、<strong>信号量</strong>、<strong>信号</strong>、<strong>共享内存</strong>）以及<strong>套接字socket</strong>。</p>
<p>socket也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同主机之间的进程通信。</p>
<p>线程间通信的方式: </p>
<ol>
<li>临界区：通过多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问；</li>
<li>互斥量Synchronized/Lock：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问 </li>
<li>信号量Semphare：为控制具有有限数量的用户资源而设计的，它允许多个线程在同一时刻去访问同一个资源，但一般需要限制同一时刻访问此资源的最大线程数目。 </li>
<li>事件(信号)，Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作</li>
</ol>
<h2 id="关系型数据库和非关系型数据库"><a href="#关系型数据库和非关系型数据库" class="headerlink" title="关系型数据库和非关系型数据库"></a>关系型数据库和非关系型数据库</h2><h3 id="关系型数据库"><a href="#关系型数据库" class="headerlink" title="关系型数据库"></a>关系型数据库</h3><ol>
<li><p><strong>概念</strong>：关系型数据库是指采用了关系模型来组织数据的数据库。简单来说，关系模式就是二维表格模型。</p>
<p>主要代表：SQL Server，Oracle,Mysql,PostgreSQL。</p>
</li>
<li><p><strong>优点</strong>：</p>
<ol>
<li>容易理解，二维表的结构非常贴近现实世界，二维表格，容易理解。</li>
<li>使用方便，通用的sql语句使得操作关系型数据库非常方便。</li>
<li>易于维护，数据库的ACID属性，大大降低了数据冗余和数据不一致的概率。</li>
</ol>
</li>
<li><p><strong>瓶颈</strong>：</p>
<ol>
<li>海量数据的读写效率。对于网站的并发量高，往往达到每秒上万次的请求，对于传统关系型数据库来说，硬盘I/o是一个很大的挑战。</li>
<li>高扩展性和可用性。在基于web的结构中，数据库是最难以横向拓展的，当一个应用系统的用户量和访问量与日俱增的时候，数据库没有办法像web Server那样简单的通过添加更多的硬件和服务节点来拓展性能和负载能力。</li>
</ol>
</li>
</ol>
<h3 id="非关系型数据库"><a href="#非关系型数据库" class="headerlink" title="非关系型数据库"></a>非关系型数据库</h3><ol>
<li><strong>概念</strong>：NoSQL非关系型数据库，主要指那些非关系型的、分布式的，且一般不保证ACID的数据存储系统，主要代表MongoDB，Redis、CouchDB。NoSQL提出了另一种理念，以键值来存储，且结构不稳定，每一个元组都可以有不一样的字段，这种就不会局限于固定的结构，可以减少一些时间和空间的开销。使用这种方式，为了获取用户的不同信息，不需要像关系型数据库中，需要进行多表查询。仅仅需要根据key来取出对应的value值即可。</li>
<li><strong>分类</strong>：非关系数据库大部分是开源的，实现比较简单，大都是针对一些特性的应用需求出现的。根据结构化方法和应用场景的不同，分为以下几类。<ol>
<li>面向高性能并发读写的key-value数据库。主要特点是具有极高的并发读写性能，例如Redis、Tokyo Cabint等。</li>
<li>面向海量数据访问的面向文档数据库。特点是，可以在海量的数据库快速的查询数据。例如MongoDB以及CouchDB。</li>
<li>面向可拓展的分布式数据库。解决的主要问题是传统数据库的扩展性上的缺陷。</li>
</ol>
</li>
<li><strong>缺点</strong>：但是由于Nosql约束少，所以也不能够像sql那样提供where字段属性的查询。因此适合存储较为简单的数据。有一些不能够持久化数据，所以需要和关系型数据库结合。</li>
</ol>
<h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><p>虚拟内存可以让程序拥有超过系统物理内存大小的可用内存空间。<strong>虚拟内存为每一个进程提供了一个一致的、私有的地址空间，它让每个进程产生了一种自己在独享储存的错觉（每个内存拥有一片连续完整的内存空间）</strong>。</p>
<p>虚拟内存的重要意义是它定义了一个连续的虚拟地址空间，并把内存扩展到硬盘空间。</p>
<h2 id="互斥锁、可重入锁、读写锁与自旋锁"><a href="#互斥锁、可重入锁、读写锁与自旋锁" class="headerlink" title="互斥锁、可重入锁、读写锁与自旋锁"></a>互斥锁、可重入锁、读写锁与自旋锁</h2><h3 id="mutex-互斥量"><a href="#mutex-互斥量" class="headerlink" title="mutex 互斥量"></a>mutex 互斥量</h3><p>mutex是睡眠等待类型的锁，当线程抢互斥锁失败的时候，线程会陷入休眠。优点就是节省CPU资源，缺点就是休眠唤醒会消耗一点时间。</p>
<p>依据同一线程是否能多次加锁，把互斥量又分为如下两类：</p>
<ul>
<li>是：递归互斥量recursive mutex，也称<strong>可重入锁</strong>，reentrant lock</li>
<li>否：非递归互斥量non-recursive mutex，也称<strong>不可重入锁</strong>，non-reentrant mutex</li>
</ul>
<h3 id="read-write-lock-读写锁"><a href="#read-write-lock-读写锁" class="headerlink" title="read-write lock 读写锁"></a>read-write lock 读写锁</h3><p>又称“共享-独占锁”，对于临界区区分读和写，读共享，写独占。</p>
<p>读写锁的特性：</p>
<ul>
<li>当读写锁被加了写锁时，其他线程对该锁加读锁或者写锁都会<strong>阻塞</strong>。</li>
<li>当读写锁被加了读锁时，其他线程对该锁加写锁会<strong>阻塞</strong>，加读锁会成功。</li>
</ul>
<p>适用于多读少写的场景。</p>
<h3 id="spinlock-自旋锁"><a href="#spinlock-自旋锁" class="headerlink" title="spinlock 自旋锁"></a>spinlock 自旋锁</h3><p><strong>自旋，更通俗的一个词时“忙等待”（busy waiting）。最通俗的一个理解，其实就是死循环。</strong></p>
<p>自旋锁不会引起线程休眠。当共享资源的状态不满足时，自旋锁会不停地<strong>循环检测状态</strong>(==循环检测状态利用了CPU提供的原语Compare&amp;Exchange来保证原子性==)。因为不会陷入休眠，而是忙等待的方式也就不需要条件变量。不休眠就不会引起上下文切换，但是会比较浪费CPU。</p>
<h2 id="Java的垃圾回收机制（GC）"><a href="#Java的垃圾回收机制（GC）" class="headerlink" title="Java的垃圾回收机制（GC）"></a>Java的垃圾回收机制（GC）</h2><p><img src="https://segmentfault.com/img/remote/1460000038256036" alt="GC讨论内容"></p>
<h3 id="垃圾的定义"><a href="#垃圾的定义" class="headerlink" title="垃圾的定义"></a>垃圾的定义</h3><h4 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h4><p>对象被创建之后，系统会给这个对象初始化一个引用计数器。被引用了则+1，引用失效后-1，直到计数器为0，意味该对象不再被使用，可以被回收。</p>
<p>引用计数法无法避免循环引用。</p>
<h4 id="根搜索算法"><a href="#根搜索算法" class="headerlink" title="根搜索算法"></a>根搜索算法</h4><p>解决了循环引用问题。从某一些指定的根对象出发，一步步遍历找到和这个根对象具有引用关系的对象，然后再从这些对象开始继续寻找，从而形成一个个的引用链，然后不在这些引用链上面的对象便被表示为引用不可达对象，这些对象需要被回收掉。</p>
<p>根对象，一般有如下几种：</p>
<ul>
<li>虚拟机栈中引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>方法区中静态属性引用的对象</li>
<li>本地方法栈中JNI引用的对象</li>
<li>活跃线程</li>
</ul>
<h3 id="回收算法"><a href="#回收算法" class="headerlink" title="回收算法"></a>回收算法</h3><p>常用的回收算法一般有：<strong>标记-清除算法</strong>、<strong>标记-整理算法</strong>、<strong>复制算法</strong>，以及系统自动进行判定使用的<strong>适应性算法</strong>。</p>
<h4 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h4><p>根据<strong>根搜索算法</strong>标记的不可达对象，标记所有代回收的垃圾对象之后，<strong>统一清除</strong>。</p>
<p>内存块变得不连续，==产生内存碎片==。</p>
<h4 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h4><p>标记完后，让所有的对象都向一端移动，然后将端边界以外的内存全部清理掉。</p>
<p>==不再产生内存碎片==。</p>
<h4 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h4><p>内存区域划分为两块，每次创建对象只使用其中一块区域，当该区域使用完后，将S0上存活的对象全部复制到S1上去，之后将S0全部清理掉。</p>
<p>可用的内存减小一半。</p>
<p>所以复制算法一般会用与对象存活时间比较短的区域，例如年轻代。老年代一般会用标记-整理算法。</p>
<h4 id="适应性算法"><a href="#适应性算法" class="headerlink" title="适应性算法"></a>适应性算法</h4><p>智能选择回收算法。</p>
<h4 id="分代回收"><a href="#分代回收" class="headerlink" title="分代回收"></a>分代回收</h4><p>年轻代复制算法，老年代标记整理算法。</p>
<h2 id="HTTPS的加密连接过程"><a href="#HTTPS的加密连接过程" class="headerlink" title="HTTPS的加密连接过程"></a>HTTPS的加密连接过程</h2><ol>
<li>客户端（发送者）提交HTTPS请求</li>
<li>服务器（接收者）响应客户，并把信息通过证书公钥加密后发给客户端（此时产生了公钥和私钥，只把公钥给客户端）</li>
<li>客户端验证证书公钥的有效性</li>
<li>有效后，会生成一个会话密钥</li>
<li>用证书公钥加密这个会话密钥后，发给服务器</li>
<li>服务器收到证书公钥加密的会话密钥后，用证书密钥的私钥解密，获取会话密钥</li>
<li>客户端与服务器双方利用这个会话密钥加密要传输的数据进行通信</li>
</ol>
<p><strong>前期是非对称加密，利用公开密钥加密技术传送复杂密钥，后期利用密钥进行对称加密</strong>。</p>
<p><img src="https://pic1.zhimg.com/80/v2-5f56cd0402e7ca767f864a07dfb57f8c_720w.jpg" alt="img"></p>
<h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p>线程分为内核态线程、用户态线程两种。</p>
<p><strong>协程的本质就是处理自身挂起和恢复的用户态线程</strong>。</p>
<p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/coroutine-user-kernel-thread.png?x-oss-process=image/resize,w_800" alt="img"></p>
<p>协程的切换比线程的切换速度更快，在<strong>IO密集型任务</strong>情境下更适合。IO密集型任务的特点是CPU消耗少，其大部分时间都是在等待IO操作完成，对于这样的场景，一个线程足矣，因此适合采用协程。</p>
<h3 id="挂起-恢复"><a href="#挂起-恢复" class="headerlink" title="挂起/恢复"></a>挂起/恢复</h3><p>相比于函数，协程最大的特点就是支持<strong>挂起/恢复</strong>。</p>
<h3 id="协程分类"><a href="#协程分类" class="headerlink" title="协程分类"></a>协程分类</h3><p><strong>按照是否开辟相应的调用栈</strong>，我们可以将协程分为两类：</p>
<ul>
<li><strong>有栈协程</strong>（Stackful Coroutine）：每个协程都有自己的调用栈，类似于线程的调用栈。</li>
<li><strong>无栈协程</strong>（Stackless Coroutine）：协程没有自己的调用栈，挂起点的状态通过状态机或闭包等语法来实现。</li>
</ul>
<h4 id="有栈协程"><a href="#有栈协程" class="headerlink" title="有栈协程"></a>有栈协程</h4><p><strong>有栈协程会改变函数调用栈</strong>。</p>
<p>有栈协程：在内存中给每个协程开辟一个栈内存（存在堆中），当协程挂起时会将它的运行时上下文（即栈空间）从系统栈中保存至所分配的栈内存中，当协程恢复时会将其运行时上下文从栈内存中恢复至系统栈中。</p>
<p>它可以在<strong>任意函数调用层级的位置进行挂起</strong>，并转移调度权。</p>
<h4 id="无栈协程"><a href="#无栈协程" class="headerlink" title="无栈协程"></a>无栈协程</h4><p>无栈协程不会为各个协程开辟相应的调用栈，无栈协程通常是<strong>基于状态机或闭包</strong>来实现。</p>
<p>基于状态机的解决方案一般是通过状态机，记录上次协程挂起时的位置，并基于此决定协程恢复时开始执行的位置。这个状态必须存储在栈以外的地方，从而避免状态与栈一同销毁。</p>
<p>相比于有栈协程，无栈协程不需要修改调用栈，也无需额外的内存来保存调用栈，因此它的开小会更小。但是相比于保存运行时上下文这种实现方式，无栈协程的实现还是存在比较多的限制，最大的缺点就是，它无法实现在任意函数调用层级的位置进行挂起。</p>
<h2 id="右值、右值引用，std-move"><a href="#右值、右值引用，std-move" class="headerlink" title="右值、右值引用，std::move"></a>右值、右值引用，std::move</h2><h3 id="左值、右值"><a href="#左值、右值" class="headerlink" title="左值、右值"></a>左值、右值</h3><p>左值<strong>可以取地址、位于等号左边</strong>，而右值<strong>没法取地址，位于等号右边</strong>。</p>
<p>有地址的变量就是左值，没有地址的字面值、临时值就是右值。</p>
<h3 id="左值引用"><a href="#左值引用" class="headerlink" title="左值引用"></a>左值引用</h3><p><strong>能指向左值，不能指向右值的就是左值引用</strong>，<strong>引用是变量的别名，由于右值没有地址，没法被修改，所以左值引用无法指向右值</strong>。</p>
<p>但是，const左值引用是可以指向右值的。因为const左值引用不会修改指向值。</p>
<h3 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h3><p>右值引用<strong>可以指向右值，不能指向左值</strong>。</p>
<p>右值使用<code>std::move</code>可以指向左值。**<code>std::move</code>并不会进行移动，唯一的功能是把左值强制转化为右值<strong>，其实现等同于一个类型转换<code>static_cast&lt;T&amp;&amp;&gt;(lvalue)</code>。所以，</strong>单纯的<code>std::move</code>并不会有性能提升**。</p>
<p>右值引用能够指向右值，本质上也是把右值提升为一个左值，并定义一个右值引用通过<code>std::move</code>指向该左值：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> &amp;&amp;ref_a = <span class="number">5</span>;</span><br><span class="line">ref_a = <span class="number">6</span>;  </span><br><span class="line">等同于以下代码：</span><br><span class="line"><span class="keyword">int</span> temp = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;&amp;ref_a = std::<span class="built_in">move</span>(temp);</span><br><span class="line">ref_a = <span class="number">6</span>;</span><br></pre></td></tr></table></figure>

<p><strong>被声明出来的左、右值都是左值</strong>。因为被声明出的左右值引用是有地址的，也位于等号左边。</p>
<p><strong>右值引用既可以是左值也是右值，如果有名称则是左值，否则是右值</strong>，也可以说，<strong>作为函数返回值的&amp;&amp;是右值，直接声明出来的&amp;&amp;是左值</strong>。</p>
<p>结论：</p>
<ol>
<li>从性能上讲，左右值引用没有区别，传参使用左右值引用都可以避免拷贝。</li>
<li>右值引用可以直接指向右值，也可以通过std::move指向左值；而左值引用只能指向左值（const左值引用也能指向右值）。</li>
<li>作为函数形参时，右值引用更灵活。虽然const左值引用可以做到左右值都接受，但它无法修改，有一定局限性。</li>
</ol>
<h3 id="右值引用与std-move的应用场景"><a href="#右值引用与std-move的应用场景" class="headerlink" title="右值引用与std::move的应用场景"></a>右值引用与std::move的应用场景</h3><ol>
<li><strong>实现移动语义</strong>，避免拷贝，从而提升程序性能。</li>
<li><strong>vector::push_back使用std::move提升性能</strong>。</li>
</ol>
<h2 id="RAII"><a href="#RAII" class="headerlink" title="RAII"></a>RAII</h2><p>==资源获取即初始化==（==R==esource ==A==cquisition ==I==s ==I==nitialization），或称 <strong>RAII</strong>，将必须在使用前请求的资源的生命周期绑定与一个对象的生存期相绑定。这些资源可以是数据库的连接、锁定的互斥体、打开的文件等。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::mutex m;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bad</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m.<span class="built_in">lock</span>();                    <span class="comment">// 请求互斥体</span></span><br><span class="line">    <span class="built_in">f</span>();                         <span class="comment">// 如果 f() 抛出异常，那么互斥体永远不会被释放</span></span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">everything_ok</span>()) <span class="keyword">return</span>; <span class="comment">// 提早返回，互斥体永远不会被释放</span></span><br><span class="line">    m.<span class="built_in">unlock</span>();                  <span class="comment">// 只有 bad() 抵达此语句，互斥体才会被释放</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">good</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(m)</span></span>; <span class="comment">// RAII类：互斥体的请求即是初始化</span></span><br><span class="line">    <span class="built_in">f</span>();                               <span class="comment">// 如果 f() 抛出异常，那么就会释放互斥体</span></span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">everything_ok</span>()) <span class="keyword">return</span>;       <span class="comment">// 提早返回也会释放互斥体</span></span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>



<h2 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h2><h3 id="什么是IO多路复用"><a href="#什么是IO多路复用" class="headerlink" title="什么是IO多路复用"></a>什么是IO多路复用</h3><ul>
<li>IO多路复用是一种同步IO模型，实现==一个线程==可以监视==多个文件句柄==；</li>
<li>一旦某个文件句柄就绪，就能够通知应用程序进行相应的读写操作；</li>
<li>没有文件句柄就绪就会==阻塞==应用程序，交出CPU</li>
</ul>
<h3 id="IO多路复用-1"><a href="#IO多路复用-1" class="headerlink" title="IO多路复用"></a>IO多路复用</h3><p>服务器采用多线程通过<code>select/poll/epoll</code>等系统调用获取fd列表，遍历有事件的fd进行<code>accept/recv/send</code>，使其能支持更多的并发连接请求。</p>
<h3 id="IO多路复用的三种实现"><a href="#IO多路复用的三种实现" class="headerlink" title="IO多路复用的三种实现"></a>IO多路复用的三种实现</h3><ul>
<li><strong>select</strong></li>
<li><strong>poll</strong></li>
<li><strong>epoll</strong></li>
</ul>
<h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><p>仅仅知道有IO事件发生，不知道是哪几个流，需要==无差别查询==所有流，<strong>select具有O(N)的无差别轮询复杂度</strong>。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2c06b4e5d90e49529f818807edeb3e8e~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image.png"></p>
<ol>
<li><p>使用copy_from_user从用户空间拷贝fd_set到内核空间</p>
</li>
<li><p>注册回调函数__pollwait</p>
</li>
<li><p>遍历所有fd，调用其对应的poll方法（对于socket，这个poll方法是sock_poll，sock_poll根据情况会调用到tcp_poll,udp_poll或者datagram_poll）</p>
</li>
<li><p>以tcp_poll为例，其核心实现就是__pollwait，也就是上面注册的回调函数。</p>
</li>
<li><p>__pollwait的主要工作就是把current（当前进程）挂到设备的等待队列中，不同的设备有不同的等待队列，对于tcp_poll来说，其等待队列是sk-&gt;sk_sleep（注意把进程挂到等待队列中并不代表进程已经睡眠了）。在设备收到一条消息（网络设备）或填写完文件数据（磁盘设备）后，会唤醒设备等待队列上睡眠的进程，这时current便被唤醒了。</p>
</li>
<li><p>poll方法返回时会返回一个描述读写操作是否就绪的mask掩码，根据这个mask掩码给fd_set赋值。</p>
</li>
<li><p>如果遍历完所有的fd，还没有返回一个可读写的mask掩码，则会调用schedule_timeout是调用select的进程（也就是current）进入睡眠。当设备驱动发生自身资源可读写后，会唤醒其等待队列上睡眠的进程。如果超过一定的超时时间（schedule_timeout指定），还是没人唤醒，则调用select的进程会重新被唤醒获得CPU，进而重新遍历fd，判断有没有就绪的fd。</p>
</li>
<li><p>把fd_set从内核空间拷贝到用户空间。</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FD_SETSIZE 1024</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NFDBITS (8 * sizeof(unsigned long))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __FDSET_LONGS (FD_SETSIZE/NFDBITS)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据结构 (bitmap)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> fds_bits[__FDSET_LONGS];</span><br><span class="line">&#125; fd_set;</span><br><span class="line"></span><br><span class="line"><span class="comment">// API</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">int</span> max_fd, </span></span></span><br><span class="line"><span class="params"><span class="function">    fd_set *readset, </span></span></span><br><span class="line"><span class="params"><span class="function">    fd_set *writeset, </span></span></span><br><span class="line"><span class="params"><span class="function">    fd_set *exceptset, </span></span></span><br><span class="line"><span class="params"><span class="function">    struct timeval *timeout</span></span></span><br><span class="line"><span class="params"><span class="function">)</span>                              <span class="comment">// 返回值就绪描述符的数目</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">FD_ZERO</span><span class="params">(<span class="keyword">int</span> fd, fd_set* fds)</span>   <span class="comment">// 清空集合</span></span></span><br><span class="line"><span class="function"><span class="title">FD_SET</span><span class="params">(<span class="keyword">int</span> fd, fd_set* fds)</span>    <span class="comment">// 将给定的描述符加入集合</span></span></span><br><span class="line"><span class="function"><span class="title">FD_ISSET</span><span class="params">(<span class="keyword">int</span> fd, fd_set* fds)</span>  <span class="comment">// 判断指定描述符是否在集合中 </span></span></span><br><span class="line"><span class="function"><span class="title">FD_CLR</span><span class="params">(<span class="keyword">int</span> fd, fd_set* fds)</span>    <span class="comment">// 将给定的描述符从文件中删除  </span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * 这里进行一些初始化的设置，</span></span><br><span class="line"><span class="comment">   * 包括socket建立，地址的设置等,</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  fd_set read_fs, write_fs;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">timeout</span>;</span></span><br><span class="line">  <span class="keyword">int</span> max = <span class="number">0</span>;  <span class="comment">// 用于记录最大的fd，在轮询中时刻更新即可</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化比特位</span></span><br><span class="line">  <span class="built_in">FD_ZERO</span>(&amp;read_fs);</span><br><span class="line">  <span class="built_in">FD_ZERO</span>(&amp;write_fs);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> nfds = <span class="number">0</span>; <span class="comment">// 记录就绪的事件，可以减少遍历的次数</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// 阻塞获取</span></span><br><span class="line">    <span class="comment">// 每次需要把fd从用户态拷贝到内核态</span></span><br><span class="line">    nfds = <span class="built_in">select</span>(max + <span class="number">1</span>, &amp;read_fd, &amp;write_fd, <span class="literal">NULL</span>, &amp;timeout);</span><br><span class="line">    <span class="comment">// 每次需要遍历所有fd，判断有无读写事件发生</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= max &amp;&amp; nfds; ++i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i == listenfd) &#123;</span><br><span class="line">         --nfds;</span><br><span class="line">         <span class="comment">// 这里处理accept事件</span></span><br><span class="line">         <span class="built_in">FD_SET</span>(i, &amp;read_fd);<span class="comment">//将客户端socket加入到集合中</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">FD_ISSET</span>(i, &amp;read_fd)) &#123;</span><br><span class="line">        --nfds;</span><br><span class="line">        <span class="comment">// 这里处理read事件</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">FD_ISSET</span>(i, &amp;write_fd)) &#123;</span><br><span class="line">         --nfds;</span><br><span class="line">        <span class="comment">// 这里处理write事件</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><strong>select缺点</strong>：</p>
<ul>
<li>单个进程所打开的FD是有限制的，通过<code>FD_SETSIZE</code>设置，默认1024；</li>
<li>每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大；</li>
<li>对socket扫描是线性扫描，采用轮询的方法，效率较低</li>
</ul>
<h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><p>poll本质上与select没有区别，但是基于==链表==来储存，因此<strong>没有最大连接数的限制</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="comment">// 数据结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> fd;                         <span class="comment">// 需要监视的文件描述符</span></span><br><span class="line">    <span class="keyword">short</span> events;                   <span class="comment">// 需要内核监视的事件</span></span><br><span class="line">    <span class="keyword">short</span> revents;                  <span class="comment">// 实际发生的事件</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// API</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(struct pollfd fds[], <span class="keyword">nfds_t</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先宏定义长度</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_POLLFD_LEN 4096  </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * 在这里进行一些初始化的操作，</span></span><br><span class="line"><span class="comment">   * 比如初始化数据和socket等。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> nfds = <span class="number">0</span>;</span><br><span class="line">  pollfd fds[MAX_POLLFD_LEN];</span><br><span class="line">  <span class="built_in">memset</span>(fds, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(fds));</span><br><span class="line">  fds[<span class="number">0</span>].fd = listenfd;</span><br><span class="line">  fds[<span class="number">0</span>].events = POLLRDNORM;</span><br><span class="line">  <span class="keyword">int</span> max  = <span class="number">0</span>;  <span class="comment">// 队列的实际长度，是一个随时更新的，也可以自定义其他的</span></span><br><span class="line">  <span class="keyword">int</span> timeout = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> current_size = max;</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// 阻塞获取</span></span><br><span class="line">    <span class="comment">// 每次需要把fd从用户态拷贝到内核态</span></span><br><span class="line">    nfds = <span class="built_in">poll</span>(fds, max+<span class="number">1</span>, timeout);</span><br><span class="line">    <span class="keyword">if</span> (fds[<span class="number">0</span>].revents &amp; POLLRDNORM) &#123;</span><br><span class="line">        <span class="comment">// 这里处理accept事件</span></span><br><span class="line">        connfd = <span class="built_in">accept</span>(listenfd);</span><br><span class="line">        <span class="comment">//将新的描述符添加到读描述符集合中</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 每次需要遍历所有fd，判断有无读写事件发生</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; max; ++i) &#123;     </span><br><span class="line">      <span class="keyword">if</span> (fds[i].revents &amp; POLLRDNORM) &#123; </span><br><span class="line">         sockfd = fds[i].fd</span><br><span class="line">         <span class="keyword">if</span> ((n = <span class="built_in">read</span>(sockfd, buf, MAXLINE)) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 这里处理read事件</span></span><br><span class="line">            <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">close</span>(sockfd);</span><br><span class="line">                fds[i].fd = <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="comment">// 这里处理write事件     </span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (--nfds &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;       </span><br><span class="line">         &#125;   </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>缺点同上。</p>
<h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><p><strong>epoll可以理解为event poll</strong>，不同于忙轮询和无差别轮询，epoll会把哪个流发生了怎么样的IO事件通知我们。所以说epoll实际上是<strong>事件驱动（每个事件关联上fd）</strong>的，此时我们对这些流的操作都是有意义的。（复杂度降到了O(1)）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据结构</span></span><br><span class="line"><span class="comment">// 每一个epoll对象都有一个独立的eventpoll结构体</span></span><br><span class="line"><span class="comment">// 用于存放通过epoll_ctl方法向epoll对象中添加进来的事件</span></span><br><span class="line"><span class="comment">// epoll_wait检查是否有事件发生时，只需要检查eventpoll对象中的rdlist双链表中是否有epitem元素即可</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> &#123;</span></span><br><span class="line">    <span class="comment">/*红黑树的根节点，这颗树中存储着所有添加到epoll中的需要监控的事件*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span>  <span class="title">rbr</span>;</span></span><br><span class="line">    <span class="comment">/*双链表中则存放着将要通过epoll_wait返回给用户的满足条件的事件*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">rdlist</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// API</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>; <span class="comment">// 内核中间加一个 ep 对象，把所有需要监听的 socket 都放到 ep 对象中</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *event)</span></span>; <span class="comment">// epoll_ctl 负责把 socket 增加、删除到内核红黑树</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event * events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;<span class="comment">// epoll_wait 负责检测可读队列，没有可读 socket 则阻塞进程</span></span><br></pre></td></tr></table></figure>

<p>每个epoll对象都有一个独立的eventpoll结构体，用于存放通过epoll_ctl方法向epoll对象中添加进来的事件。这些事件都会挂载在红黑树中。</p>
<p>而所有添加到epoll中的事件都会与设备（网卡）驱动程序建立回调关系，也就是说，当相应的事件发生时会调用这个回调方法。这个回调方法在内核中叫ep_poll_callback，它会将发生的事件添加到rdlist双链表中。</p>
<p>在epoll中，对于每一个事件，都会建立一个epitem结构体，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epitem</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span>  <span class="title">rbn</span>;</span><span class="comment">//红黑树节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">rdllink</span>;</span><span class="comment">//双向链表节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_filefd</span>  <span class="title">ffd</span>;</span>  <span class="comment">//事件句柄信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> *<span class="title">ep</span>;</span>    <span class="comment">//指向其所属的eventpoll对象</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>;</span> <span class="comment">//期待发生的事件类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>通过红黑树和双链表数据结构，并结合回调机制，造就了epoll的高效</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * 在这里进行一些初始化的操作，</span></span><br><span class="line"><span class="comment">   * 比如初始化数据和socket等。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内核中创建ep对象</span></span><br><span class="line">    epfd=<span class="built_in">epoll_create</span>(<span class="number">256</span>);</span><br><span class="line">    <span class="comment">// 需要监听的socket放到ep中</span></span><br><span class="line">    <span class="built_in">epoll_ctl</span>(epfd,EPOLL_CTL_ADD,listenfd,&amp;ev);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="comment">// 阻塞获取</span></span><br><span class="line">      nfds = <span class="built_in">epoll_wait</span>(epfd,events,<span class="number">20</span>,<span class="number">0</span>);</span><br><span class="line">      <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;nfds;++i) &#123;</span><br><span class="line">          <span class="keyword">if</span>(events[i].data.fd==listenfd) &#123;</span><br><span class="line">              <span class="comment">// 这里处理accept事件</span></span><br><span class="line">              connfd = <span class="built_in">accept</span>(listenfd);</span><br><span class="line">              <span class="comment">// 接收新连接写到内核对象中</span></span><br><span class="line">              <span class="built_in">epoll_ctl</span>(epfd,EPOLL_CTL_ADD,connfd,&amp;ev);</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (events[i].events&amp;EPOLLIN) &#123;</span><br><span class="line">              <span class="comment">// 这里处理read事件</span></span><br><span class="line">              <span class="built_in">read</span>(sockfd, BUF, MAXLINE);</span><br><span class="line">              <span class="comment">//读完后准备写</span></span><br><span class="line">              <span class="built_in">epoll_ctl</span>(epfd,EPOLL_CTL_MOD,sockfd,&amp;ev);</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span>(events[i].events&amp;EPOLLOUT) &#123;</span><br><span class="line">              <span class="comment">// 这里处理write事件</span></span><br><span class="line">              <span class="built_in">write</span>(sockfd, BUF, n);</span><br><span class="line">              <span class="comment">//写完后准备读</span></span><br><span class="line">              <span class="built_in">epoll_ctl</span>(epfd,EPOLL_CTL_MOD,sockfd,&amp;ev);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>epoll的优点</strong>：</p>
<ul>
<li>没有最大并发连接的限制，能打开的FD的上线远大于1024；</li>
<li>效率提升，不是轮询的方式，不会随着FD的数目的增加效率下降。只有活跃可用的FD才会调用callback函数；</li>
<li>内存拷贝，利用mmap()文件映射内存加速与内核空间的消息传递，即epoll使用mmap减少复制开销；</li>
</ul>
<h3 id="select-poll-epoll之间的区别"><a href="#select-poll-epoll之间的区别" class="headerlink" title="select/poll/epoll之间的区别"></a>select/poll/epoll之间的区别</h3><p>select，pollm，epoll都是IO多路复用的机制。IO多路复用通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。<strong>但select，poll，epoll本质上都是同步IO，因为它们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的</strong>。</p>
<p>epoll是Linux目前大规模网络并发程序开发的首选模型。</p>
<table>
<thead>
<tr>
<th></th>
<th>select</th>
<th>poll</th>
<th>epoll</th>
</tr>
</thead>
<tbody><tr>
<td>操作方式</td>
<td>遍历</td>
<td>遍历</td>
<td>回调</td>
</tr>
<tr>
<td>数据结构</td>
<td>bitmap</td>
<td>数组</td>
<td>红黑树</td>
</tr>
<tr>
<td>最大连接数</td>
<td>1024（x86）或2048（64）</td>
<td>无上限</td>
<td>无上限</td>
</tr>
<tr>
<td>最大支持文件描述符数</td>
<td>一般有最大值限制</td>
<td>65535</td>
<td>65535</td>
</tr>
<tr>
<td>fd拷贝</td>
<td>每次调用select，都需要把fd集合从用户态拷贝到内核态</td>
<td>每次调用poll，都需要把fd集合从用户态拷贝到内核态</td>
<td>fd每次调用epoll_ctl拷贝，每次调用epoll_wait不拷贝</td>
</tr>
<tr>
<td>工作模式</td>
<td>LT</td>
<td>LT</td>
<td>支持ET高效模式</td>
</tr>
<tr>
<td>工作效率</td>
<td>每次调用都进行线性遍历，时间复杂度为O(N)</td>
<td>每次调用都进行线性遍历，时间复杂度为O(N)</td>
<td>事件通知方式，每当fd就绪，系统注册的回调函数就会被调用，将就绪fd放到readylist里面，时间复杂度O(1)</td>
</tr>
</tbody></table>
<h2 id="程序的编译、链接、装载与运行"><a href="#程序的编译、链接、装载与运行" class="headerlink" title="程序的编译、链接、装载与运行"></a>程序的编译、链接、装载与运行</h2><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/12/9/167935399f11a321~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp" alt="img"></p>
<h3 id="程序编译的过程"><a href="#程序编译的过程" class="headerlink" title="程序编译的过程"></a>程序编译的过程</h3><ol>
<li><strong>预处理</strong><ul>
<li>删除所有注释信息</li>
<li>展开宏定义</li>
<li>展开include</li>
</ul>
</li>
<li><strong>编译</strong><ul>
<li>词法分析、语法分析、语义分析并优化后生成相对应的汇编文件</li>
</ul>
</li>
<li><strong>汇编</strong><ul>
<li>汇编代码转为机械指令，生成<strong>目标文件</strong></li>
</ul>
</li>
<li><strong>链接</strong><ul>
<li>多合并不同目标文件中的同类型的段</li>
<li>对于目标文件中的符号引用，在其他的目标文件中找到可以引用的符号</li>
<li>对目标文件中的变量地址进行重定位</li>
</ul>
</li>
</ol>
<h3 id="目标文件"><a href="#目标文件" class="headerlink" title="目标文件"></a>目标文件</h3><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/12/9/1679353acd247280~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp" alt="img"></p>
<p><strong>分段的好处</strong>：</p>
<ul>
<li>方便区分，代码（指令）存到<code>.text</code>，初始化好的数据存到<code>.data</code>，只读数据存到<code>.rdata</code>等</li>
<li>便于给段设置读写权限，某些段只需要设置只读权限即可</li>
<li>方便CPU缓存的生效</li>
<li>利于节省内存，例如程序有多个副本的情况下，此时只需要一份代码段即可</li>
</ul>
<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><strong>静态链接过程</strong>：</p>
<ol>
<li>扫描所有的目标文件，获取它们的每个段的长度、位置和属性，并将每个目标文件中的符号表的符号定义和符号引用收集起来放在一个全局符号表中，建立起可执行文件到目标文件的段映射关系</li>
<li>读取目标文件中的段数据，并解析符号表信息，根据符号表信息进行重定位、调整代码段中的地址等操作</li>
</ol>
<h3 id="重定位表"><a href="#重定位表" class="headerlink" title="重定位表"></a>重定位表</h3><p>编译器把所有需要重定位的数据存在重定位表中，这样连接器就能够知道该目标文件中哪些数据是需要被重定位的。</p>
<h3 id="符号表"><a href="#符号表" class="headerlink" title="符号表"></a>符号表</h3><p>目标文件中的某些部分是在链接时被使用到的“粘合剂”，这些部分被称为“符号”，符号就保存在符号表中。符号表中保存的符号很多，其中最重要的就是定义在本目标文件中的可以被其他目标文件引用的符号和在本目标文件中引用的全局符号，这两个符号呈现互补的关系。</p>
<p><strong>重定位表与符号表之间的关系</strong>：</p>
<p>他们之间是相互合作的关系，链接器首先要根据重定位表找到该目标文件中需要被重定位的符号，之后再根据符号表去其他的目标文件中找到可以相匹配的符号，最后对本目标文件中的符号进行重定位。</p>
<h3 id="装载"><a href="#装载" class="headerlink" title="装载"></a>装载</h3><p>所以可执行文件被加载到内存中的数据可以分为两类：<strong>可读不可写</strong>和<strong>可读可写</strong>。</p>
<p>由于现代操作系统均采用<strong>分页</strong>的方式来管理内存，所以操作系统只需要读取可执行文件的<strong>文件头</strong>，之后建立起可执行文件到虚拟内存的映射关系，而不需要真正的将程序载入内存。在程序的运行过程中，CPU发现有些内存页在物理内存中并不存在并因此触发<strong>缺页异</strong>常，此时CPU将控制权限转交给操作系统的<strong>异常处理函数</strong>，操作系统负责将此内存页的数据从磁盘上读取到物理内存中。数据读取完毕之后，操作系统让CPU jmp到触发了缺页异常的那条指令处继续执行，此时指令执行就不会再有缺页异常了。</p>
<p>参考：<a href="https://juejin.cn/post/6844903734191849480">https://juejin.cn/post/6844903734191849480</a></p>
<h2 id="std-shared-ptr实现细节"><a href="#std-shared-ptr实现细节" class="headerlink" title="std::shared_ptr实现细节"></a><code>std::shared_ptr</code>实现细节</h2><p>典型实现种，<code>std::shared_ptr</code>只<strong>保留两个指针</strong>：</p>
<ul>
<li>get()所返回的指针</li>
<li>指向==控制块==的指针</li>
</ul>
<p>控制块是一个动态分配的对象，其中包括：</p>
<ul>
<li>指向被管理对象的指针或者被管理对象本身</li>
<li>删除器</li>
<li>分配器</li>
<li>占有被管理对象的shared_ptr数量</li>
<li>涉及被管理对象的==weak_ptr==数量</li>
</ul>
<p>指向同一被管理对象内存的shared_ptr共享控制块。</p>
<p>强弱引用分别计数，shared_ptr计数器减至零，控制块调用被管理对象的析构函数。但控制块本身知道weak_ptr计数器同样归零时才会释放。</p>
<h2 id="Qt-deleteLater与delete对比"><a href="#Qt-deleteLater与delete对比" class="headerlink" title="Qt deleteLater与delete对比"></a>Qt deleteLater与delete对比</h2><p><code>delete</code>是C++标准关键字，作用是调用析构函数后释放该对象的内存。</p>
<p><code>deleteLater</code>是Qt的新方法，所有==继承自QObject==的对象都有此方法。</p>
<ul>
<li>deleteLater依赖于Qt的<strong>event loop</strong>机制</li>
<li>==可以多次调用此函数==</li>
</ul>
<p><strong>deleteLater原理</strong>：</p>
<ul>
<li>函数被调用后，向QCoreApplication发送一个QDeferredDeleteEvent</li>
<li>主线程将QDeferredDeleteEvent列入事件队列，需要时将该事件分发给该对象</li>
<li>该对象继续运行，直到收到QDeferredDeleteEvent，==delete自身==。</li>
<li>收到QDeferredDeleteEvent后，此对象将从event loop中被移除</li>
</ul>
<h2 id="Qt信号槽"><a href="#Qt信号槽" class="headerlink" title="Qt信号槽"></a>Qt信号槽</h2><p><strong>信号-槽的使用方法</strong>：在普通函数声明之前，加上signal、slot标记，然后通过connect函数把信号槽连接起来。</p>
<p><img src="https://pic4.zhimg.com/80/v2-29412691dc6685a8a7ac558c37494dc3_720w.jpg" alt="img"></p>
<p><strong>信号-槽分两种</strong>：</p>
<ul>
<li>==同一线程==内的信号槽，相当于函数调用，直接调用或列入事件循环。</li>
<li>==不同线程==的信号槽，信号触发时，发送者线程将槽函数的调用转化成了一次“调用事件”，放入事件循环中。接收者线程执行到下一次事件处理时，处理“调用事件”，调用相应的函数。</li>
</ul>
<p><strong>信号-槽的实现：元对象编译器MOC</strong>。</p>
<p>元对象编译器MOC负责解析signals、slot、emit等标准C++不存在的关键字，以及处理Q_OBJECT、Q_PROPERTY、Q_INVOKABLE等相关的宏，生成moc_xxx.cpp的C++文件（使用黑魔法来变现语法糖）。比如信号函数只要声明、不需要自己写实现，就是在这个moc_xxx.cpp文件中自动生成的。</p>
<p><strong>moc的本质就是反射器</strong>。</p>
<p><strong>信号槽的调用流程</strong>：</p>
<ul>
<li>MOC查找头文件中的signal与slots，标记出信号槽。将信号槽信息储存到类静态变量staticMetaObject中，并按照声明的顺序进行存放，建立索引。</li>
<li>connect链接，将信号槽的索引信息放到一个双向链表中，彼此配对。</li>
<li>emit被调用，调用信号函数，且传递发送信号的对象指针，元对象指针，信号索引，参数列表到active函数。</li>
<li>active函数在双向链表中找到所有与信号对应的槽索引，根据槽索引找到槽函数，执行槽函数。</li>
</ul>
<h2 id="Qt-MOC机制"><a href="#Qt-MOC机制" class="headerlink" title="Qt MOC机制"></a>Qt MOC机制</h2><p><strong>Qt程序编译顺序</strong>：MOC-预编译-编译-汇编-链接</p>
<p>元对象编译器MOC负责解析signals、slot、emit等标准C++不存在的关键字，以及处理Q_OBJECT、Q_PROPERTY、Q_INVOKABLE等相关的宏，生成moc_xxx.cpp的C++文件（使用黑魔法来变现语法糖）。比如信号函数只要声明、不需要自己写实现，就是在这个moc_xxx.cpp文件中自动生成的。</p>
<p>MOC一个重要作用是展开Q_OBJECT宏：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Q_OBJECT \public: \</span></span><br><span class="line"><span class="meta">    QT_WARNING_PUSH \</span></span><br><span class="line"><span class="meta">    Q_OBJECT_NO_OVERRIDE_WARNING \</span></span><br><span class="line"><span class="meta">    static const QMetaObject staticMetaObject; \</span></span><br><span class="line"><span class="meta">    virtual const QMetaObject *metaObject() const; \</span></span><br><span class="line"><span class="meta">    virtual void *qt_metacast(const char *); \</span></span><br><span class="line"><span class="meta">    virtual int qt_metacall(QMetaObject::Call, int, void **); \</span></span><br><span class="line"><span class="meta">    QT_TR_FUNCTIONS \private: \</span></span><br><span class="line"><span class="meta">    Q_OBJECT_NO_ATTRIBUTES_WARNING \</span></span><br><span class="line"><span class="meta">    Q_DECL_HIDDEN_STATIC_METACALL static void qt_static_metacall(QObject *, QMetaObject::Call, int, void **); \</span></span><br><span class="line"><span class="meta">    QT_WARNING_POP \</span></span><br><span class="line"><span class="meta">    struct QPrivateSignal &#123;&#125;; \</span></span><br><span class="line"><span class="meta">    QT_ANNOTATE_CLASS(qt_qobject, <span class="meta-string">&quot;&quot;</span>)</span></span><br></pre></td></tr></table></figure>

<h3 id="static-const-QMetaObject-staticMetaObject"><a href="#static-const-QMetaObject-staticMetaObject" class="headerlink" title="static const QMetaObject staticMetaObject"></a>static const QMetaObject staticMetaObject</h3><p>QMetaObject包含QObject中所谓的==元数据==，也就是QObject的一些描述信息：signal、slot、类型信息。</p>
<p><code>QObject::metaObject()</code>返回==重载==后的QObject的metaObject对象。</p>
<p>Qt的元对象系统：信号槽，属性系统，运行时类信息都储存在静态对象staticMetaObject中。</p>
<h3 id="类信息"><a href="#类信息" class="headerlink" title="类信息"></a>类信息</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//存储类中的函数及参数信息</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">qt_meta_stringdata_test_t</span> &#123;</span></span><br><span class="line">    QByteArrayData data[<span class="number">7</span>];<span class="comment">//函数加参数一共7个</span></span><br><span class="line">    <span class="keyword">char</span> stringdata0[<span class="number">60</span>];<span class="comment">//总字符串长60个字节</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//切分字符串</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QT_MOC_LITERAL(idx, ofs, len) \</span></span><br><span class="line"><span class="meta">    Q_STATIC_BYTE_ARRAY_DATA_HEADER_INITIALIZER_WITH_OFFSET(len, \</span></span><br><span class="line"><span class="meta">    qptrdiff(offsetof(qt_meta_stringdata_test_t, stringdata0) + ofs \</span></span><br><span class="line"><span class="meta">        - idx * sizeof(QByteArrayData)) \</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//初始化qt_meta_stringdata_test ，并且将所有函数拼接成字符串，中间用\0分开</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">qt_meta_stringdata_test_t</span> qt_meta_stringdata_test = &#123;</span><br><span class="line">    &#123;</span><br><span class="line"><span class="built_in">QT_MOC_LITERAL</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">4</span>), <span class="comment">// &quot;test&quot;    //类名 索引，偏移量，偏移长度)，类名</span></span><br><span class="line"><span class="built_in">QT_MOC_LITERAL</span>(<span class="number">1</span>, <span class="number">5</span>, <span class="number">12</span>), <span class="comment">// &quot;signal_test1&quot;    </span></span><br><span class="line"><span class="built_in">QT_MOC_LITERAL</span>(<span class="number">2</span>, <span class="number">18</span>, <span class="number">0</span>), <span class="comment">// &quot;&quot;</span></span><br><span class="line"><span class="built_in">QT_MOC_LITERAL</span>(<span class="number">3</span>, <span class="number">19</span>, <span class="number">12</span>), <span class="comment">// &quot;signal_test2&quot;</span></span><br><span class="line"><span class="built_in">QT_MOC_LITERAL</span>(<span class="number">4</span>, <span class="number">32</span>, <span class="number">5</span>), <span class="comment">// &quot;index&quot;   //信号的参数名</span></span><br><span class="line"><span class="built_in">QT_MOC_LITERAL</span>(<span class="number">5</span>, <span class="number">38</span>, <span class="number">10</span>), <span class="comment">// &quot;slot_test1&quot;</span></span><br><span class="line"><span class="built_in">QT_MOC_LITERAL</span>(<span class="number">6</span>, <span class="number">49</span>, <span class="number">10</span>) <span class="comment">// &quot;slot_test2&quot;</span></span><br><span class="line"> </span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;test\0signal_test1\0\0signal_test2\0index\0&quot;</span></span><br><span class="line">    <span class="string">&quot;slot_test1\0slot_test2&quot;</span>          <span class="comment">//以上两行为字符串</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> QT_MOC_LITERAL</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//存储元对象信息，包括信号和槽机制、运行时类型信息和动态属性系统</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> uint qt_meta_data_test[] = &#123;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// content:</span></span><br><span class="line">       <span class="number">7</span>,       <span class="comment">// revision</span></span><br><span class="line">       <span class="number">0</span>,       <span class="comment">// classname</span></span><br><span class="line">       <span class="number">0</span>,    <span class="number">0</span>, <span class="comment">// classinfo</span></span><br><span class="line">       <span class="number">4</span>,   <span class="number">14</span>, <span class="comment">// methods</span></span><br><span class="line">       <span class="number">0</span>,    <span class="number">0</span>, <span class="comment">// properties</span></span><br><span class="line">       <span class="number">0</span>,    <span class="number">0</span>, <span class="comment">// enums/sets</span></span><br><span class="line">       <span class="number">0</span>,    <span class="number">0</span>, <span class="comment">// constructors</span></span><br><span class="line">       <span class="number">0</span>,       <span class="comment">// flags</span></span><br><span class="line">       <span class="number">2</span>,       <span class="comment">// signalCount</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 信号 第一列是信号的索引1，3;对应第一列</span></span><br><span class="line"><span class="comment">QT_MOC_LITERAL(1, 5, 12), // &quot;signal_test1&quot;    </span></span><br><span class="line"><span class="comment">QT_MOC_LITERAL(2, 18, 0), // &quot;&quot;</span></span><br><span class="line"><span class="comment">QT_MOC_LITERAL(3, 19, 12), // &quot;signal_test2&quot;</span></span><br><span class="line"><span class="comment">      第二列是参数个数</span></span><br><span class="line"><span class="comment">      第三列是？暂未明白</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> <span class="comment">// signals: name, argc, parameters, tag, flags </span></span><br><span class="line">       <span class="number">1</span>,    <span class="number">0</span>,   <span class="number">34</span>,    <span class="number">2</span>, <span class="number">0x06</span> <span class="comment">/* Public */</span>,</span><br><span class="line">       <span class="number">3</span>,    <span class="number">1</span>,   <span class="number">35</span>,    <span class="number">2</span>, <span class="number">0x06</span> <span class="comment">/* Public */</span>,</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// slots: name, argc, parameters, tag, flags</span></span><br><span class="line">       <span class="number">5</span>,    <span class="number">0</span>,   <span class="number">38</span>,    <span class="number">2</span>, <span class="number">0x0a</span> <span class="comment">/* Public */</span>,</span><br><span class="line">       <span class="number">6</span>,    <span class="number">1</span>,   <span class="number">39</span>,    <span class="number">2</span>, <span class="number">0x0a</span> <span class="comment">/* Public */</span>,</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// signals: parameters</span></span><br><span class="line">    QMetaType::Void,</span><br><span class="line">    QMetaType::Void, QMetaType::Int,    <span class="number">4</span>,</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// slots: parameters</span></span><br><span class="line">    QMetaType::Void,</span><br><span class="line">    QMetaType::Void, QMetaType::Int,    <span class="number">4</span>,</span><br><span class="line"> </span><br><span class="line">       <span class="number">0</span>        <span class="comment">// eod</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>参考链接：<a href="https://blog.csdn.net/LIJIWEI0611/article/details/115056153">https://blog.csdn.net/LIJIWEI0611/article/details/115056153</a></p>
<h2 id="Qt反射机制"><a href="#Qt反射机制" class="headerlink" title="Qt反射机制"></a>Qt反射机制</h2><ul>
<li>继承自QObject，使用Q_OBJECT宏</li>
<li>使用<code>Q_PROPERTY(&#123;type&#125; &#123;name&#125; READ &#123;func1&#125; WRITE &#123;func2&#125; NOTIFY &#123;sig1&#125;)</code>宏注册属性</li>
<li>使用<code>Q_INVOKABLE fun1(args...)</code>宏注册类的成员函数</li>
</ul>
<p>参考链接：<a href="https://zhuanlan.zhihu.com/p/55883889">https://zhuanlan.zhihu.com/p/55883889</a></p>
<h2 id="TCP连接的断开"><a href="#TCP连接的断开" class="headerlink" title="TCP连接的断开"></a>TCP连接的断开</h2><p>除正常情况的==四次挥手==断开连接外，TCP断开连接有如下规则：</p>
<ul>
<li><p>TCP连接断开的==挥手==，在进程崩溃时，会由操作系统内核代劳</p>
</li>
<li><p>当TCP连接建立后，如果某一方断电或断网，如果此时刚好<strong>正在发送数据</strong>，TCP数据包发送失败后会==重试==，重试达到上限时也会直接断开连接</p>
<ul>
<li><blockquote>
<p>Linux下：</p>
<p>最小重传时间为==200ms==</p>
<p>最大重传时间为==120s==</p>
<p>重传次数为==15==</p>
</blockquote>
</li>
</ul>
</li>
<li><p>当TCP连接建立后，如果某一方断电或断网，且这条连接<strong>没有数据传输时</strong>：</p>
<ul>
<li>如果开启了==KeepAlive==机制，则会在一定心跳检测后断开连接，这个默认检测时间大概==2个多小时==，比较久</li>
<li>如果未开启KeepAlive机制，则连接<strong>永远存在</strong></li>
</ul>
</li>
<li><p>如果一方发送==RST包==给另一方，也是会强制对方断开连接的（断电/断网后某端重启再恢复，便会发送RST）</p>
</li>
</ul>
<p>参考链接：<a href="https://blog.51cto.com/u_15067225/4334375">https://blog.51cto.com/u_15067225/4334375</a></p>
<h2 id="C-函数调用过程"><a href="#C-函数调用过程" class="headerlink" title="C++函数调用过程"></a>C++函数调用过程</h2><p>在堆栈中变量分布是从高地址到低地址分布，EBP是指向栈底的指针，<strong>在调用过程中不变</strong>，又称为==帧指针==。ESP指向栈顶，程序执行时移动，ESP减小分配空间，ESP增大释放空间，ESP又称为==栈指针==。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> param1 ,<span class="keyword">int</span> param2,<span class="keyword">int</span> param3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> var1 = param1;</span><br><span class="line">        <span class="keyword">int</span> var2 = param2;</span><br><span class="line">        <span class="keyword">int</span> var3 = param3;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;var1=%d,var2=%d,var3=%d&quot;</span>,var1,var2,var3);</span><br><span class="line">        <span class="keyword">return</span> var1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="built_in">func</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>函数main执行，main各个参数<strong>从右向左逐步压入栈中，最后压入返回地址</strong>。</p>
</li>
<li><p>执行第15行，3个参数从左向右的顺序压入堆栈，栈内分布如下图：<br><img src="https://pic002.cnblogs.com/images/2012/426620/2012072014171977.jpg" alt="img"></p>
</li>
<li><p><strong>返回地址入栈</strong>，栈内分布如下：<br><img src="https://pic002.cnblogs.com/images/2012/426620/2012072014223353.jpg" alt="img"></p>
</li>
<li><p>函数调用，通过跳转指令进入函数，<strong>函数地址入栈后，EBP入栈，然后把当前ESP的值给EBP</strong>，对应的汇编指令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">push ebp</span><br><span class="line">mov ebp esp</span><br></pre></td></tr></table></figure>

<p>此时栈顶和栈底指向同一位置，栈内分布如下：</p>
<p><img src="https://pic002.cnblogs.com/images/2012/426620/2012072014393253.jpg" alt="img"></p>
</li>
<li><p>执行函数内容。按申明顺序依次储存。</p>
<p><img src="https://pic002.cnblogs.com/images/2012/426620/2012072014460755.jpg" alt="img"></p>
</li>
<li><p>输出结果。<strong>通过eax寄存器保存函数的返回值</strong>。</p>
</li>
<li><p>调用执行函数完毕，局部变量var3，var2，var3依次出栈，EBP恢复原值，返回地址出栈，找到原执行地址，param1，param2，param3依次出栈，函数调用执行完毕。</p>
</li>
</ol>
<h2 id="在堆上分配内存快还是栈上分配内存更快？"><a href="#在堆上分配内存快还是栈上分配内存更快？" class="headerlink" title="在堆上分配内存快还是栈上分配内存更快？"></a>在堆上分配内存快还是栈上分配内存更快？</h2><p><strong>在栈上分配释放内存更快</strong>。</p>
<p>栈是程序启动时，系统分配好了的。</p>
<p>堆是用的时候向系统申请，用了还回去，申请和交还的过程开销就比较大了。</p>
<h2 id="内存碎片"><a href="#内存碎片" class="headerlink" title="内存碎片"></a>内存碎片</h2><p>内存碎片的产生有两方面的原因：</p>
<ol>
<li><p><strong>动态内存分配的问题</strong>：</p>
<p>内存碎片即“碎片的内存”，描述一个系统中所有不可用的空闲内存，这些碎片之所以不能被使用，是因为负责<strong>动态分配内存的分配算法使得这些空闲的内存无法使用</strong>。空闲内存以小且不连续的方式出现在不同的位置。</p>
<p>空闲内存碎片有两种：<strong>a.内部碎片；b.外部碎片</strong></p>
<p><strong>内部碎片的产生</strong>：==所有内存分配必须起始于可被4、8或16整除的地址==，内存分配算法仅能把预定大小的内存块分配给永固，此时可能产生多余空间即内部碎片。</p>
<p><strong>外部碎片的产生</strong>：<strong>频繁的分配与回收物理界面导致大量的、连续且小的页面夹在已经分配的页面中间，就会产生外部碎片。</strong></p>
</li>
<li><p><strong>系统内存回收机制问题</strong>：</p>
<p>内存碎片是一个系统问题，反复的malloc和free，free后的内存又不能马上被系统回收利用，这个与系统对内存的回收机制有关。</p>
</li>
</ol>
<h2 id="静态链接与动态链接"><a href="#静态链接与动态链接" class="headerlink" title="静态链接与动态链接"></a>静态链接与动态链接</h2><p>静态链接与动态链接最大的区别就在于<strong>链接的时机不一样</strong>，静态链接是在形成可执行程序前，动态链接的进行则是在程序执行时。</p>
<h3 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h3><p>目标文件合成可执行文件，编译时进行重定位。</p>
<p>优点：</p>
<p>执行速度快。</p>
<p>缺点：</p>
<ol>
<li>浪费空间。</li>
<li>更新困难，需要重新编译链接。</li>
</ol>
<h3 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h3><p>程序按照模块拆分成各个相对独立的部分，在程序运行时才将它们链接在一起形成一个完整的程序。运行时执行重定位。</p>
<p>优点：</p>
<ol>
<li>不会有多个库的副本。</li>
<li>更新方便</li>
</ol>
<p>缺点：</p>
<p>运行时进行链接，性能略微损失。</p>
<h2 id="STL的内存分配原理"><a href="#STL的内存分配原理" class="headerlink" title="STL的内存分配原理"></a>STL的内存分配原理</h2><p>STL的默认allocator是一个==两级分配器==构成的内存管理器：</p>
<ul>
<li>当申请的内存大于128byte时，启动第一级分配器通过malloc直接向系统的堆空间申请分配内存</li>
<li>当申请的内存小于128byte时，启动第二级分配器，从一个 <strong>预先分配好</strong>的==内存池==中取一块内存交付给用户。这个内存池由16个大小不同（8的倍数，8~128byte）的空闲列表组成，allocator会根据申请内存的大小（将这个大小round up成8的倍数）从对应的空闲块列表取表头块给用户。</li>
</ul>
<p>优点：==小对象==</p>
<ul>
<li>小对象的快速分配。</li>
<li>避免了内存碎片的产生。</li>
</ul>
<h2 id="Qt-connect的第五个参数（信号槽连接方式）"><a href="#Qt-connect的第五个参数（信号槽连接方式）" class="headerlink" title="Qt connect的第五个参数（信号槽连接方式）"></a>Qt connect的第五个参数（信号槽连接方式）</h2><ol>
<li><code>Qt::AutoConnection</code>： 默认值，使用这个值则连接类型会在信号发送时决定。如果接收者和发送者在同一个线程，则自动使用Qt::DirectConnection类型。如果接收者和发送者不在一个线程，则自动使用Qt::QueuedConnection类型。</li>
<li><code>Qt::DirectConnection</code>：槽函数会在信号发送的时候直接被调用，槽函数运行于信号发送者所在线程。效果看上去就像是直接在信号发送位置调用了槽函数。这个在多线程环境下比较危险，可能会造成奔溃。</li>
<li><code>Qt::QueuedConnection</code>：槽函数在控制回到接收者所在线程的事件循环时被调用，槽函数运行于信号接收者所在线程。发送信号之后，槽函数不会立刻被调用，等到接收者的当前函数执行完，进入事件循环之后，槽函数才会被调用。多线程环境下一般用这个。</li>
<li><code>Qt::BlockingQueuedConnection</code>：槽函数的调用时机与Qt::QueuedConnection一致，不过发送完信号后发送者所在线程会阻塞，直到槽函数运行完。接收者和发送者绝对不能在一个线程，否则程序会死锁。在多线程间需要同步的场合可能需要这个。</li>
<li><code>Qt::UniqueConnection</code>：这个flag可以通过按位或（|）与以上四个结合在一起使用。当这个flag设置时，当某个信号和槽已经连接时，再进行重复的连接就会失败。也就是避免了重复连接。</li>
</ol>
<h2 id="HTTP的方法"><a href="#HTTP的方法" class="headerlink" title="HTTP的方法"></a>HTTP的方法</h2><p>超文本传输协议（HTTP）的设计目的是保证客户端于服务器之间的通信。</p>
<p>HTTP的工作方式是客户端与服务器之间的请求-应答协议。</p>
<ul>
<li><p><strong>GET</strong>：从指定的资源==请求数据==</p>
<p><strong>查询字符串（名称/值对）是在GET请求的URL中发送的</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/test/demo_form.php?name1=value1&amp;name2=value2</span><br></pre></td></tr></table></figure>

<ul>
<li>GET请求可被缓存</li>
<li>GET请求保留在浏览器历史记录中</li>
<li>GET请求可被收藏为书签</li>
<li>GET请求不应再处理敏感数据时使用</li>
<li>GET请求有长度限制</li>
<li>GET请求只应当用于取回数据</li>
</ul>
</li>
<li><p><strong>POST</strong>：向指定的资源==提交==要被处理的数据：</p>
<p><strong>查询字符串（名称/值对）时在POST请求的HTTP消息主体中发送的</strong>：</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/test/demo_form.php</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>runoob.com</span><br><span class="line">name1=value1&amp;name2=value2</span><br></pre></td></tr></table></figure>

<ul>
<li>POST请求不会被缓存</li>
<li>POST请求不会保存在浏览器历史记录中</li>
<li>POST不能被收藏为书签</li>
<li>POST请求对数据长度没有要求</li>
</ul>
</li>
<li><p>HEAD：与GET相同，但只返回HTTP报头，不返回文档主体</p>
</li>
<li><p>PUT：上传指定的URL表示</p>
</li>
<li><p>DELETE：删除指定资源</p>
</li>
<li><p>OPTIONS：返回服务器支持的HTTP方法</p>
</li>
<li><p>CONNECT：把请求连接转换到透明的TCP/IP通道</p>
</li>
</ul>
<h2 id="C-类对象的内存分布（内存对齐）"><a href="#C-类对象的内存分布（内存对齐）" class="headerlink" title="C++类对象的内存分布（内存对齐）"></a>C++类对象的内存分布（内存对齐）</h2><p>C++类初始化为一个对象后，该对象实例在内存中的分布情况：</p>
<h3 id="空类"><a href="#空类" class="headerlink" title="空类"></a>空类</h3><p>实例化一个空类，会在内存中占用1个字节，表示为类实例。</p>
<h3 id="只含基本数据，不含函数"><a href="#只含基本数据，不含函数" class="headerlink" title="只含基本数据，不含函数"></a>只含基本数据，不含函数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">	<span class="keyword">char</span> a;</span><br><span class="line">	<span class="keyword">int</span> b;</span><br><span class="line">	<span class="keyword">char</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>&#123;</span></span><br><span class="line">	<span class="keyword">char</span> a;</span><br><span class="line">	<span class="keyword">char</span> c;</span><br><span class="line">	<span class="keyword">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cout&lt;&lt;<span class="built_in"><span class="keyword">sizeof</span></span>(A)&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;<span class="built_in"><span class="keyword">sizeof</span></span>(B)&lt;&lt;endl;	</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>答案分别是：</p>
<p>12</p>
<p>8</p>
<p>原因在于C++类成员变量的内存分布式<strong>从上到下</strong>，按照<strong>内存对齐</strong>原则进行分布的。</p>
<p><strong>内存对齐原则</strong>：</p>
<blockquote>
<ol>
<li>==分配内存的顺序是按照声明的顺序。==</li>
<li>==每个变量相对于起始位置的偏移量必须是该变量类型大小的整数倍，不是整数倍空出内存，直到偏移量是整数倍位置。==</li>
<li>==最后整个类的大小必须是<strong>变量类型最大值</strong>的整数倍。==</li>
</ol>
</blockquote>
<p><strong>为什么要进行内存对齐：</strong></p>
<ol>
<li>平台原因（移植原因）：某些硬件平台只能在某些地址处取某些特定类型的数据，不能访问任意地址。</li>
<li>性能原因：访问未对其的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访问。</li>
</ol>
<h3 id="带成员函数的类"><a href="#带成员函数的类" class="headerlink" title="带成员函数的类"></a>带成员函数的类</h3><p>函数不占实例内存，一个类的函数时公共的，一个类的函数只有一份。</p>
<p>类的成员函数存放与具体编译器有关，有的放在只读区，有的存放在代码区。</p>
<h3 id="带虚函数的类"><a href="#带虚函数的类" class="headerlink" title="带虚函数的类"></a>带虚函数的类</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">E</span> &#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">func1</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;虚函数&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">char</span> a;</span><br><span class="line">  <span class="keyword">int</span> b;</span><br><span class="line">  <span class="keyword">char</span> c;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;成员函数&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>24</p>
<p>虚函数表指针占用了前8位。</p>
<h2 id="C-数据类型"><a href="#C-数据类型" class="headerlink" title="C++数据类型"></a>C++数据类型</h2><table>
<thead>
<tr>
<th align="left">类型名称</th>
<th align="left">字节</th>
<th align="left">其他名称</th>
<th align="left">值的范围</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong><code>int</code></strong></td>
<td align="left">4</td>
<td align="left"><strong><code>signed</code></strong></td>
<td align="left">-2,147,483,648 到 2,147,483,647</td>
</tr>
<tr>
<td align="left"><strong><code>unsigned int</code></strong></td>
<td align="left">4</td>
<td align="left"><strong><code>unsigned</code></strong></td>
<td align="left">0 到 4,294,967,295</td>
</tr>
<tr>
<td align="left"><strong><code>__int8</code></strong></td>
<td align="left">1</td>
<td align="left"><strong><code>char</code></strong></td>
<td align="left">-128 到 127</td>
</tr>
<tr>
<td align="left"><strong><code>unsigned __int8</code></strong></td>
<td align="left">1</td>
<td align="left"><strong><code>unsigned char</code></strong></td>
<td align="left">0 到 255</td>
</tr>
<tr>
<td align="left"><strong><code>__int16</code></strong></td>
<td align="left">2</td>
<td align="left"><strong><code>short</code></strong>, <strong><code>short int</code></strong>, <strong><code>signed short int</code></strong></td>
<td align="left">-32,768 到 32,767</td>
</tr>
<tr>
<td align="left"><strong><code>unsigned __int16</code></strong></td>
<td align="left">2</td>
<td align="left"><strong><code>unsigned short</code></strong>, <strong><code>unsigned short int</code></strong></td>
<td align="left">0 到 65,535</td>
</tr>
<tr>
<td align="left"><strong><code>__int32</code></strong></td>
<td align="left">4</td>
<td align="left"><strong><code>signed</code></strong>, <strong><code>signed int</code></strong>, <strong><code>int</code></strong></td>
<td align="left">-2,147,483,648 到 2,147,483,647</td>
</tr>
<tr>
<td align="left"><strong><code>unsigned __int32</code></strong></td>
<td align="left">4</td>
<td align="left"><strong><code>unsigned</code></strong>, <strong><code>unsigned int</code></strong></td>
<td align="left">0 到 4,294,967,295</td>
</tr>
<tr>
<td align="left"><strong><code>__int64</code></strong></td>
<td align="left">8</td>
<td align="left"><strong><code>long long</code></strong>, <strong><code>signed long long</code></strong></td>
<td align="left">-9,223,372,036,854,775,808 到 9,223,372,036,854,775,807</td>
</tr>
<tr>
<td align="left"><strong><code>unsigned __int64</code></strong></td>
<td align="left">8</td>
<td align="left"><strong><code>unsigned long long</code></strong></td>
<td align="left">0 到 18,446,744,073,709,551,615</td>
</tr>
<tr>
<td align="left"><strong><code>bool</code></strong></td>
<td align="left">1</td>
<td align="left">无</td>
<td align="left"><strong><code>false</code></strong> 或 <strong><code>true</code></strong></td>
</tr>
<tr>
<td align="left"><strong><code>char</code></strong></td>
<td align="left">1</td>
<td align="left">无</td>
<td align="left">-128 到 127 默认  0 to 255 when compiled by using <a href="https://docs.microsoft.com/zh-cn/cpp/build/reference/j-default-char-type-is-unsigned?view=msvc-170"><code>/J</code></a></td>
</tr>
<tr>
<td align="left"><strong><code>signed char</code></strong></td>
<td align="left">1</td>
<td align="left">无</td>
<td align="left">-128 到 127</td>
</tr>
<tr>
<td align="left"><strong><code>unsigned char</code></strong></td>
<td align="left">1</td>
<td align="left">无</td>
<td align="left">0 到 255</td>
</tr>
<tr>
<td align="left"><strong><code>short</code></strong></td>
<td align="left">2</td>
<td align="left"><strong><code>short int</code></strong>, <strong><code>signed short int</code></strong></td>
<td align="left">-32,768 到 32,767</td>
</tr>
<tr>
<td align="left"><strong><code>unsigned short</code></strong></td>
<td align="left">2</td>
<td align="left"><strong><code>unsigned short int</code></strong></td>
<td align="left">0 到 65,535</td>
</tr>
<tr>
<td align="left"><strong><code>long</code></strong></td>
<td align="left">4</td>
<td align="left"><strong><code>long int</code></strong>, <strong><code>signed long int</code></strong></td>
<td align="left">-2,147,483,648 到 2,147,483,647</td>
</tr>
<tr>
<td align="left"><strong><code>unsigned long</code></strong></td>
<td align="left">4</td>
<td align="left"><strong><code>unsigned long int</code></strong></td>
<td align="left">0 到 4,294,967,295</td>
</tr>
<tr>
<td align="left"><strong><code>long long</code></strong></td>
<td align="left">8</td>
<td align="left">无 (，但等效于 <strong><code>__int64</code></strong>)</td>
<td align="left">-9,223,372,036,854,775,808 到 9,223,372,036,854,775,807</td>
</tr>
<tr>
<td align="left"><strong><code>unsigned long long</code></strong></td>
<td align="left">8</td>
<td align="left">无 (，但等效于 <strong><code>unsigned __int64</code></strong>)</td>
<td align="left">0 到 18,446,744,073,709,551,615</td>
</tr>
<tr>
<td align="left"><strong><code>enum</code></strong></td>
<td align="left">多种多样</td>
<td align="left">无</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><strong><code>float</code></strong></td>
<td align="left">4</td>
<td align="left">无</td>
<td align="left">3.4E +/- 38（7 位数）</td>
</tr>
<tr>
<td align="left"><strong><code>double</code></strong></td>
<td align="left">8</td>
<td align="left">无</td>
<td align="left">1.7E +/- 308（15 位数）</td>
</tr>
<tr>
<td align="left"><strong><code>long double</code></strong></td>
<td align="left">与 <strong><code>double</code></strong></td>
<td align="left">无</td>
<td align="left">与 <strong><code>double</code></strong> 相同</td>
</tr>
<tr>
<td align="left"><strong><code>wchar_t</code></strong></td>
<td align="left">2</td>
<td align="left"><strong><code>__wchar_t</code></strong></td>
<td align="left">0 到 65,535</td>
</tr>
</tbody></table>
<h2 id="指针和引用的区别是什么？"><a href="#指针和引用的区别是什么？" class="headerlink" title="指针和引用的区别是什么？"></a>指针和引用的区别是什么？</h2><ol>
<li>引用必须定义时<strong>初始化</strong>，不能像指针一样仅<code>int* a;</code>这样定义，必须<code>int &amp;b=a;</code>。</li>
<li><code>int &amp; const r = a</code>这样写错误，因为引用本身就不能改变指向，<strong>添加const多次一举。</strong></li>
<li>指针可以有多级<strong>但引用只能有一级</strong>。</li>
<li>指针的++，–代表下一个数据，<strong>引用的++，–代表数据本身的加减。</strong></li>
<li>sizeof引用得到的是所指向的变量（对象）的大小，而sizeof指针得到的是指针本身的大小；</li>
<li>当指针和引用作为函数参数的时候，指针传递参数会生成一个临时变量，引用传递的参数不会生成一个临时变量。</li>
</ol>
<p>指针传递的本质是值传递复制实参的地址到函数的栈中，然后在形参中对地址取值操作。而引用的形参是给实参起了一个别名，可以直接操控实参从而实现对实参的控制。</p>
<p>参考链接：<a href="https://link.zhihu.com/?target=https://www.cnblogs.com/dingxiaoqiang/p/8012578.html">C++ 值传递、指针传递、引用传递详解</a></p>
<p>题外话：</p>
<p>引用的本质就是指针，它的出现是为了书写方便，不要动不动有<code>*a=10</code>。</p>
<p><code>int &amp;b=a;</code>这里&amp;a，&amp;b取址相同，并不代表引用b不占用内存，而是系统自动将&amp;b转换成对b中内容的读取。而b里面保存的是a的地址。后台实际运行时，<code>int *b=&amp;a;b=12</code>就是<code>*b=12</code>。</p>
<h2 id="C-程序运行时进程的内存分布情况"><a href="#C-程序运行时进程的内存分布情况" class="headerlink" title="C++程序运行时进程的内存分布情况"></a>C++程序运行时进程的内存分布情况</h2><p><img src="https://img-blog.csdnimg.cn/db0745b0bb634a62847e3eb2b18bb6d0.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4OTczNzEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>内存分为5部分，从高地址到低地址为：</p>
<ul>
<li><strong>栈</strong>：空间向下</li>
<li><strong>堆</strong>：空间向上</li>
<li><strong>未初始化的数据段</strong>（==bss==）：该段数据在程序开始之前由操作系统内核初始化为0，包含所有==初始化为0==和==没有显式初始化==的==全局变量==和==静态变量==</li>
<li><strong>初始化的数据段</strong>（==data==）：==初始化==的==全局变量==和==静态变量==</li>
<li><strong>代码段</strong>（==text==）：存放程序的二进制代码</li>
</ul>
<h2 id="C-变量的内存分配"><a href="#C-变量的内存分配" class="headerlink" title="C++变量的内存分配"></a>C++变量的内存分配</h2><p>C的储存区分为：</p>
<ul>
<li><strong>栈</strong>：编译器自动分配释放</li>
<li><strong>堆</strong>：程序员分配释放</li>
<li><strong>全局区（静态区）</strong>：全局变量与静态变量存放在一起，初始化与未初始化的全局变量和静态变量分别存放在两块相邻的区域。-程序结束释放</li>
<li><strong>常量区</strong>：程序结束释放</li>
</ul>
<p>C++的储存区分为：</p>
<ul>
<li><strong>栈</strong>：由编译器在需要的时候分配，在不需要的时候自动清除的变量的存储区。里面的变量通常是局部变脸、函数参数等。</li>
<li><strong>堆</strong>：==new==分配的内存块，他们的释放由程序员负责。若程序员没有释放掉，程序结束后操作系统会自动回收。</li>
<li><strong>自由存储区</strong>：==malloc==分配的内存块，他和堆是十分相似的，区别是用free来结束自己的声明。</li>
<li><strong>全局/静态存储区</strong>：全局变量和静态变量被分配到同一块内存中，在C语言中，全局变量和静态变量分为初始化的和未初始化的，在C++中无区分，共同占用同一块内存区</li>
<li><strong>常量存储区</strong>：里面存放常量</li>
</ul>
<p>判断规则：</p>
<ul>
<li>函数体中定义的变量通常是在==栈==上</li>
<li>用malloc，new等分配内存的函数分配得到的在==堆==上</li>
<li>全局变量存在==全局区==</li>
<li>所有静态变量存在==全局区==</li>
<li>“abcd”字符串常量存放在==常量区==</li>
</ul>
<blockquote>
<p><code>char s[] = &quot;hello&quot;</code>，s为全局变量，存放在==数据段==（简称“==数据段==”）的==读写区域==；</p>
<p><code>char *ss = &quot;world&quot;</code>，ss为全局变量，存放在==数据段==的==只读部分==</p>
</blockquote>
<h2 id="C-的多态"><a href="#C-的多态" class="headerlink" title="C++的多态"></a>C++的多态</h2><p>面向对象的三大特征：<strong>封装</strong>、<strong>继承</strong>和<strong>多态</strong>。</p>
<p>多态分为<strong>编译时的多态</strong>与<strong>运行时的多态</strong>。</p>
<p>编译时的多态就是==函数重载==，包括==运算符重载==，编译时根据实参决定调用哪个函数。</p>
<p>运行时的多态与==继承==、==虚函数==有关。</p>
<h2 id="一次完整的HTTP请求"><a href="#一次完整的HTTP请求" class="headerlink" title="一次完整的HTTP请求"></a>一次完整的HTTP请求</h2><p>当我们在web浏览器的地址栏输入<a href="http://www.baidu.com时，简单来说发生了下述行为：">www.baidu.com时，简单来说发生了下述行为：</a></p>
<p><strong>概述</strong>：</p>
<ol>
<li>对<a href="http://www.baidu.com这个网址进行dns域名解析,得到对应的ip地址./">www.baidu.com这个网址进行DNS域名解析，得到对应的IP地址。</a></li>
<li>根据这个IP，找到对应的服务器，发起TCP的三次握手。</li>
<li>建立TCP连接后发起HTTP请求。</li>
<li>服务器相应HTTP请求，浏览器获得HTML代码。</li>
<li>浏览器解析HTML代码，并请求HTML代码中的资源（如JS、CSS、图片等）（==先得到HTML代码，才能去找这些资源==）。</li>
<li>浏览器对页面进行渲染呈现给用户。</li>
<li>服务器关闭TCP连接。</li>
</ol>
<p>注：</p>
<ol>
<li><p>DNS怎么找到域名？</p>
<blockquote>
<p>DNS域名解析采用的是递归查询的方式，过程是，先去找DNS缓存-&gt;缓存找不到就去根域名服务器-&gt;根域名又会去找下一级，这样递归查找之后，找到了，给我们的web浏览器</p>
</blockquote>
</li>
<li><p>为什么HTTP协议要基于TCP来实现？</p>
<blockquote>
<p>TCP是一个端到端的可靠的面向连接的协议，HTTP基于传输层TCP协议不用担心数据传输的各种问题（当发生错误时，会重传）</p>
</blockquote>
</li>
<li><p>最后一步浏览器是如何对页面进行渲染的？</p>
<blockquote>
<p>a) 解析HTML文件形成DOM树</p>
<p>b) 解析CSS文件构成渲染树</p>
<p>c) 边解析，边渲染</p>
<p>d) JS单线程运行，JS有可能修改DOM结构，意味着JS执行完成前，后续所有资源的下载是没有必要的，所以JS是单线程，会阻塞后续资源下载。</p>
</blockquote>
</li>
</ol>
<h3 id="服务器关闭TCP连接"><a href="#服务器关闭TCP连接" class="headerlink" title="服务器关闭TCP连接"></a>服务器关闭TCP连接</h3><p>一般情况下，一旦Web服务器向浏览器发送了请求数据，它就要关闭TCP连接，然后如果浏览器或者服务器在其头信息加入了这行代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Connection:keep-alive </span><br></pre></td></tr></table></figure>

<p>TCP连接在发送后将仍然保持打开状态，于是，浏览器可以继续通过相同的连接发送请求。保持连接节省了为每个请求新连接所需的时间，还节约了网络带宽。</p>
<h2 id="QCoreApplication，QGuiApplication，QApplication之间的关系"><a href="#QCoreApplication，QGuiApplication，QApplication之间的关系" class="headerlink" title="QCoreApplication，QGuiApplication，QApplication之间的关系"></a>QCoreApplication，QGuiApplication，QApplication之间的关系</h2><p><code>QObject</code>-&gt;<code>QCoreApplication</code>-&gt;<code>QGuiApplication</code>-&gt;<code>QApplication</code></p>
<p>使用QWidget时应使用<code>QApplication</code>。</p>
<h2 id="Qt的D指针（d-ptr）与Q指针（q-ptr）"><a href="#Qt的D指针（d-ptr）与Q指针（q-ptr）" class="headerlink" title="Qt的D指针（d_ptr）与Q指针（q_ptr）"></a>Qt的D指针（<code>d_ptr</code>）与Q指针（<code>q_ptr</code>）</h2><h3 id="D指针"><a href="#D指针" class="headerlink" title="D指针"></a>D指针</h3><p>==PIMPL==模式，指向一个包含所有数据的私有数据结构体。</p>
<ul>
<li>私有的结构体可以随意改变，而不需要重新编译整个工程项目</li>
<li>隐藏实现细节</li>
<li>头文件中没有任何实现细节，可以作为API使用</li>
<li>原本在头文件的实现部分转移到乐源文件，所以编译速度有所提高</li>
</ul>
<h3 id="Q指针"><a href="#Q指针" class="headerlink" title="Q指针"></a>Q指针</h3><p>私有的结构体中储存一个指向公有类的Q指针。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>Qt中的一个类常用一个PrivateXXX类来处理内部逻辑，使得内部逻辑与外部接口分开，这个PrivateXXX对象通过D指针来访问；在PrivateXXX中有需要引用Owner的内容，通过Q指针来访问。</li>
<li>由于D和Q指针是从基类继承下来的，子类中由于继承导致类型发生变化，需要通过<code>static_cast</code>类型转化，所以<code>DPTR()</code>与<code>QPTR()</code>宏定义实现了转换。</li>
</ul>
<h2 id="Qt的智能指针"><a href="#Qt的智能指针" class="headerlink" title="Qt的智能指针"></a>Qt的智能指针</h2><p>Qt的智能指针包括：</p>
<ul>
<li>QSharedPointer</li>
<li>QScopedPointer</li>
<li>QScopedArrayPointer</li>
<li>QWeakPointer</li>
<li>QPointer</li>
<li>QSharedDataPointer</li>
</ul>
<h3 id="QSharedPointer"><a href="#QSharedPointer" class="headerlink" title="QSharedPointer"></a>QSharedPointer</h3><p>相当于<code>std::shared_ptr</code>，内部维持着对拥有的内存资源的引用计数，引用计数下降到0时，这个内存资源就被释放了。</p>
<p>QSharedPointer是==线程安全==的，多个线程同时修改QSharedPointer对象也不需要加锁，但是QSharedPointer指向的内存区域不一定是线程安全的，所以多个线程同时修改QSharedPointer指向的数据时还要考虑加锁。</p>
<h3 id="QWeakPointer"><a href="#QWeakPointer" class="headerlink" title="QWeakPointer"></a>QWeakPointer</h3><p>类似于<code>std::weak_ptr</code>。</p>
<h3 id="QScopedPointer"><a href="#QScopedPointer" class="headerlink" title="QScopedPointer"></a>QScopedPointer</h3><p>相当于<code>std::unique_ptr</code>，内存数据只在一处被使用。</p>
<h3 id="QScopedArrayPointer"><a href="#QScopedArrayPointer" class="headerlink" title="QScopedArrayPointer"></a>QScopedArrayPointer</h3><p>类似于QScopedPointer，用于指向的内存数据是一个数组时的场景。</p>
<h3 id="QPointer"><a href="#QPointer" class="headerlink" title="QPointer"></a>QPointer</h3><p>QPointer只能用于指向==QObject及派生类的对象==。当一个QObject或派生类对象被删除后，QPointer能自动将其内部的指针设置为0，这样在使用QPointer之前就可以判断一下是否有效乐。</p>
<p><strong>QPointer对象超出作用域时，并不会删除它指向的内存对象。</strong></p>
<h3 id="QSharedPointer-1"><a href="#QSharedPointer-1" class="headerlink" title="QSharedPointer"></a>QSharedPointer</h3><p>用于实现数据的隐式共享。Qt中大量使用了隐式共享与写时拷贝技术，例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QString str1 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">QString str2 = str1;</span><br><span class="line">str2[<span class="number">2</span>] = <span class="string">&quot;X&quot;</span>; </span><br></pre></td></tr></table></figure>

<p>第二行执行完后，str2和str1指向同一片内存数据。第三句执行时，Qt会为str2的内部数据重新分配内存。这样做的好处是可以有效地减少大片数据拷贝的次数，提高程序的运行效率。</p>
<p>Qt中隐式共享和写时拷贝就是利用QSharedDataPointer和QSharedData这两个类实现的。</p>
<h2 id="std-string的写时拷贝与内存共享"><a href="#std-string的写时拷贝与内存共享" class="headerlink" title="std::string的写时拷贝与内存共享"></a>std::string的写时拷贝与内存共享</h2><p>std::string实现了内存共享与写时拷贝。共享的内存何时析构是利用引用计数实现的。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>C++11</tag>
        <tag>C++17</tag>
        <tag>学习心得</tag>
        <tag>Qt</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>C++类对象的内存分布</title>
    <url>/2022/05/11/cpp_memory/</url>
    <content><![CDATA[<h1 id="C-类对象的内存分布"><a href="#C-类对象的内存分布" class="headerlink" title="C++类对象的内存分布"></a>C++类对象的内存分布</h1><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>C++类初始化成一个对象之后，该对象实例在内存中是如何分布的呢？</p>
<p>C++类对象的内存分布是面试的热点话题，几次C++研发岗的面试十有八九面试官都会问到类对象的内存分布问题。于是乎我整理了一下这阵子关于类对象内存分布的笔记，整理成一篇博客供大家参考。</p>
<p>本文将类对象的内存分布分为种情况：<strong>空类情况</strong>，<strong>含成员变量，不含成员函数的情况</strong>，<strong>带成员函数的情况</strong>，<strong>带虚函数的情况</strong>。在讨论内存分布时，我们也将探讨C++中一个极为重要的原则，<strong>内存对齐原则</strong>。</p>
<span id="more"></span>

<h2 id="空类情况"><a href="#空类情况" class="headerlink" title="空类情况"></a>空类情况</h2><p>如果实例化一个空类，这个对象会在内存中占用1个字节（标识作用）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Em</span> &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(Em) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure>



<h2 id="含成员变量，不含成员函数的情况"><a href="#含成员变量，不含成员函数的情况" class="headerlink" title="含成员变量，不含成员函数的情况"></a>含成员变量，不含成员函数的情况</h2><p>首先我们给出一个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">  <span class="keyword">char</span> a;</span><br><span class="line">  <span class="keyword">int</span> b;</span><br><span class="line">  <span class="keyword">double</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line">  <span class="keyword">char</span> a;</span><br><span class="line">  <span class="keyword">double</span> b;</span><br><span class="line">  <span class="keyword">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(A) &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(B) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设我们处在64位系统下，char占用1字节，int占用4字节，double占用8字节。上面代码的结果会是什么呢？看起来A与B都包含相同数量、相同类型的成员变量。</p>
<p>答案分别是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">16</span><br><span class="line">24</span><br></pre></td></tr></table></figure>

<p>通过这个例子我们便可以猜到C++的类实例内存分布与<strong>成员变量的声明顺序</strong>有关。</p>
<p>C++类成员变量的内存分布是：按照声明顺序，<strong>从上到下</strong>，按照<strong>内存对齐</strong>的原则进行分布的。</p>
<p>这里引出了我们马上要谈论的重要内容，内存对齐。</p>
<h3 id="内存对齐"><a href="#内存对齐" class="headerlink" title="内存对齐"></a>内存对齐</h3><p>内存对齐的原则如下：</p>
<blockquote>
<ol>
<li>内存分配的顺序是按照声明的顺序。</li>
<li>每个变量相对于起始位置的偏移量（offset）必须是该变量类型大小的整数倍，不是整数倍则空出内存（padding），直到偏移量为整数倍为止。</li>
<li>最后整个类的大小必须是里面变量类型大小最大值的整数倍。</li>
</ol>
</blockquote>
<p>根据上面的原则，我们便可以分别推断A类和B类的大小。</p>
<p>A类的大小：</p>
<ol>
<li><code>char a</code>占1个字节，偏移值为0，目前A类占1字节。</li>
<li><code>int b</code>占4个字节，根据内存对齐原则的第二条，b起始位置的偏移量应该4的整数倍，所以b要在a后面空3个字节，然后放入，因此偏移值为4，目前为止A类占用8个字节（3个padding）。</li>
<li><code>double c</code>占8个字节，可以直接从b后的第一个字节开始放入，偏移值为8。此时A类占用16字节，符合内存对齐的第三条原则，整个类的大小（16）是成员变量类型大小最大值（8）的整数倍，因此不需要补齐。所以A类总共占用16字节。</li>
</ol>
<p>同理，B类的大小：</p>
<ol>
<li><code>char a</code>占1个字节，偏移值为0，目前B类占1字节。</li>
<li><code>double b</code>占8个字节，根据第二条规则，b要在a后面空7个字节，然后开始放入，因此偏移值为8，目前为止B类占用16个字节（7个padding）。</li>
<li><code>int c</code>占4个字节，可以直接从b后的第一个字节开始放入，偏移值为16，此时B类占用20个字节。根据内存对齐的第三条原则，整个类的大小应该是成员变量类型大小最大值（8）的整数倍，因此需要补齐3个字节到24字节。所以B类总共占用24字节。</li>
</ol>
<blockquote>
<p>关于内存对齐的补充：</p>
<ol>
<li>除了类，结构体也是这样的对齐规则。</li>
<li>对齐的原因：<ul>
<li>平台原因：某些硬件平台只能在某些地址处取某些特定类型的数据，不能访问任意地址。</li>
<li>性能原因：访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访问</li>
</ul>
</li>
</ol>
</blockquote>
<h2 id="带成员函数的情况"><a href="#带成员函数的情况" class="headerlink" title="带成员函数的情况"></a>带成员函数的情况</h2><p>还是先给个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> &#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="keyword">char</span> a;</span><br><span class="line">  <span class="keyword">int</span> b;</span><br><span class="line">  <span class="keyword">double</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(C) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">16</span><br></pre></td></tr></table></figure>

<p>可以看到，C类所占用的内存空间大小与A类相同。因为一个对象所占的空间大小只取决于该对象的数据成员所占的空间，而与成员函数无关（虚函数后面讨论）。</p>
<p>用类取定义对象时，系统会为每一个对象分配储存空间。如果一个类包括了数据和函数，数据的内存分布如第二种情况所示，而函数是不占实例内存的，因为一个类的函数是公共的，一个类的函数只有一份。</p>
<h2 id="带虚函数的情况"><a href="#带虚函数的情况" class="headerlink" title="带虚函数的情况"></a>带虚函数的情况</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">funA</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">char</span> a;</span><br><span class="line">  <span class="keyword">int</span> b;</span><br><span class="line">  <span class="keyword">double</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(D) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">24</span><br></pre></td></tr></table></figure>

<p>上面刚刚讨论过带成员函数的类实例内存空间，成员函数并不会占用类实例的内存空间，那为什么虚函数还会占用类实例内存空间呢？答案与C++的运行时多态（虚函数）的实现有关。</p>
<p>在类含有虚函数时，为了实现基类继承类之间虚函数的准确调用，使用了一个虚函数表来记录类实例的虚函数的实际地址，而该虚函数表并不位于类实例的内存空间中。相反的，在每个含有虚函数的类的内存空间首部，都会有一个<strong>虚函数表指针</strong>（vptr），指向对应的虚函数表。</p>
<p>假设我们处于64位系统下，指针占用8个字节，那么很容易便能推出类D的内存空间：</p>
<ol>
<li><code>vptr</code>占8个字节，偏移值为0，目前D类占8字节</li>
<li><code>char a</code>占1个字节，偏移值为8，目前D类占9字节</li>
<li><code>int b</code>占4个字节，根据内存对齐原则的第二条，b起始位置的偏移量应该4的整数倍，所以b要在a后面空3个字节，然后放入，因此偏移值为12，目前为止D类占用16个字节（3个padding）。</li>
<li><code>double c</code>占8个字节，可以直接从b后的第一个字节开始放入，偏移值为16。此时D类占用24字节，符合内存对齐的第三条原则，整个类的大小（24）是成员变量类型大小最大值（8）的整数倍，因此不需要补齐。所以D类总共占用16字节。</li>
</ol>
<h2 id="写在最后，推荐一个VS-Code插件"><a href="#写在最后，推荐一个VS-Code插件" class="headerlink" title="写在最后，推荐一个VS Code插件"></a>写在最后，推荐一个VS Code插件</h2><p>VS Code扩展市场里官方的C/CPP插件真心不好用，还容易造成卡顿。可以关闭C/CPP插件的语法检查功能，安装LLVM在扩展市场里提供的clangd插件。</p>
<p><img src="clangd.png" alt="clangd"></p>
<p>clangd插件与官方的C/CPP插件相比，自动补全速度稍慢一些，但是提示信息更加丰富，目前clangd插件也已经能搭配最新的clangd14用上inlay hints功能。</p>
<p><img src="inlayhint.png" alt="inlay hint"></p>
<p>当然，在这篇文章种特别推荐clangd插件，还是因为它对查看类内存布局的支持：</p>
<p><img src="class1.png" alt="整个类的内存布局"></p>
<p><img src="class2.png" alt="类成员变量的offset与padding"></p>
<p>简直不要太便利！</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>学习心得</tag>
      </tags>
  </entry>
  <entry>
    <title>无锁编程简介（翻译）——译自《An Introduction to Lock-Free Programming》</title>
    <url>/2022/02/26/%E6%97%A0%E9%94%81%E7%BC%96%E7%A8%8B%E7%AE%80%E4%BB%8B%EF%BC%88%E7%BF%BB%E8%AF%91%EF%BC%89%E2%80%94%E2%80%94%E8%AF%91%E8%87%AA%E3%80%8AAn%20Introduction%20to%20Lock-Free%20Programming%E3%80%8B/</url>
    <content><![CDATA[<h1 id="无锁编程简介（翻译）——译自《An-Introduction-to-Lock-Free-Programming》"><a href="#无锁编程简介（翻译）——译自《An-Introduction-to-Lock-Free-Programming》" class="headerlink" title="无锁编程简介（翻译）——译自《An Introduction to Lock-Free Programming》"></a>无锁编程简介（翻译）——译自《An Introduction to Lock-Free Programming》</h1><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>本文翻译自经典博文<a href="https://preshing.com/20120612/an-introduction-to-lock-free-programming/">《An Introduction to Lock-Free Programming》</a>，是一篇有关于无锁编程的经典文章。由于译者水平优先，如有谬误实所难免，还请指正。</p>
<span id="more"></span>

<h2 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h2><p>无锁编程是一个不小的挑战。它不仅难在实现这个任务本身的复杂度，还难在对这个任务自身的理解上。</p>
<p>我很幸运第一次接触到无锁编程的介绍是Bruce Dawson写的博文——《<a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ee418650(v=vs.85).aspx">Lockless Programming Considerations</a>》（无锁编程的相关注意事项），这篇文章是一篇完美的读物，且通俗易懂。与其他人一样，我有很多机会将Bruce讲的建议应用到实际的开发和调试工作中，例如Xbox 360平台。</p>
<p>从那时起，市面上陆续出现了许多关于无锁编程的优秀的资料，这些资料涉及了从抽象的理论和正确性的证明到实际的应用和硬件的细节。我也在文末列了一些参考文献。与此同时，我发现很多信息，在不同的资料中甚至会出现混淆的情况：例如，一些材料中假设了<a href="http://en.wikipedia.org/wiki/Sequential_consistency">顺序一致性</a>的情况，忽略了内存顺序的问题。然而顺序一致性带来的问题，反而是影响C/C++无锁编程的一些代表性问题。C++11标准带来的<a href="http://en.cppreference.com/w/cpp/atomic">原子类型标准库</a>也给我们的无锁编程带来了新的挑战，甚至改变了我们许多人对无锁算法的理解。</p>
<p>在这篇文章中，我将重新介绍无锁编程。首先，我会对无锁编程进行定义，然后我会对无锁编程提炼出几个关键的概念。我会利用流程图来展示这些概念之间的相互关系，然后一一对它们进行解释。在开始讲之前，我希望任何一个希望使用无锁编程的程序员都最好已经理解如何使用互斥锁和其他的高级同步工具（例如信号量和消息队列）来编写正确的多线程代码。</p>
<h2 id="什么是无锁编程"><a href="#什么是无锁编程" class="headerlink" title="什么是无锁编程"></a>什么是无锁编程</h2><p>人们经常将无锁编程理解为没有互斥锁的编程方式。这是正确的，但是只说了一个方面。基于学术论文中被普遍接受的定义比这要全面一些。从它的本质来说，无锁编程描述的是代码的特性，并不涉及实际代码的编写。</p>
<p>基本上，如果你程序的某一部分代码满足下图情况，则可以认为这部分代码是无锁的。相反，如果你的这部分代码并不满足这些情况，则说明这些代码不是无锁的。</p>
<p align="center">
<img src="https://preshing.com/images/its-lock-free.png" alt="its-lock-free"/>
</p>

<p>在这里，“锁”并不是简单地指互斥锁，而是代表使整个程序陷入锁住状态的可能性。引起这种情况的原因各种各样，例如死锁、活锁，甚至是你的死对头故意做了一些对你的程序不利的线程调度的决策。最后一种原因听起来很荒谬很可笑，但实际上是可能出现。在某种情况下，共享的互斥锁会被轻易攻破进而造成程序陷入锁住的状态：你的程序的某个线程获取到一个共享锁后，你的死对头可以仅仅再也不调度这个进程从而导致你的整个程序陷入锁住态。当然，这仅仅是我们的一个假想，实际上真正的操作系统并不会这样做。</p>
<p>这里举一个没有互斥锁、但依旧不是无锁编程的例子。刚开始，<code>X=0</code>。作为对读者的一个锻炼，请你们思考一下两个线程怎么来调度使它们都不会退出这个循环。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (X == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    X = <span class="number">1</span> - X;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>没有人会期望一个大的应用程序是完全无锁的。一般来说，我们只是希望在整个基础代码中指出一些特殊的无锁操作集合。比如，在一个无锁队列中，它可能会有一个无锁的操作，比如<code>push</code>，<code>pop</code>,<code>isEmpty</code>等等。</p>
<p>《<a href="http://www.amazon.com/gp/product/0123973376/ref=as_li_ss_tl?ie=UTF8&tag=preshonprogr-20&linkCode=as2&camp=1789&creative=390957&creativeASIN=0123973376">The Art of Multiprocessor Programming</a>》（多处理器编程艺术）的作者Herlihy和Shavit，倾向于把这些操作表示为类的方法，然后得出了关于无锁的如下简介定义：在一个有限的执行中，一些方法的调用一定会有限的结束。换句话说，只要程序能够保持调用这些无锁的操作，结束的操作的数量不管怎样都能保持增加。在进行那些操作时，系统从算法角度来说是不可能把程序锁住的。</p>
<p>无锁编程的一个重要意义是如果你中止了一个线程，它将不会阻止其他组内的线程的操作，因为它们有自己的无锁操作。这也表明了在编写中断处理程序和实时系统时无锁编程的价值，因为在这些情境下，无论系统处于什么状态，一定的任务一定能在一定的时间范围内完成。</p>
<p>最后我们还需要纠正一个概念：被设计来阻塞线程的操作并不会降低算法的质量。比如说，一个队列的出队列操作在队列为空时可能会倾向于阻塞，但其他的代码分支同样可以认为是无锁的。</p>
<h2 id="无锁编程技术"><a href="#无锁编程技术" class="headerlink" title="无锁编程技术"></a>无锁编程技术</h2><p>当你尝试在无锁编程中实现无阻塞，有一系列的技术可以实现，例如原子操作、内存屏障、避免ABA问题等。这也是无锁编程变得如此复杂的原因之一。</p>
<p>那么这些技术之间有什么联系呢？为了展示它们的关系，我将它们都画在了下面的流程图中。然后我会详尽地介绍下面地的每一种技术。</p>
<p align="center">
<img src="https://preshing.com/images/techniques.png" alt="无锁编程技术"/>
</p>

<h2 id="原子RMD（Read-Modify-Write）操作"><a href="#原子RMD（Read-Modify-Write）操作" class="headerlink" title="原子RMD（Read-Modify-Write）操作"></a>原子RMD（Read-Modify-Write）操作</h2><p>原子操作是一种不可分割的对内存进行操作的方式——没有线程可以得到完成一半的操作。在现代处理器中，很多操作已经是原子的了，例如对简单数据类型的对齐的读写操作。</p>
<p>RMW操作更进一步允许你去原子地进行更复杂地数据操作。如果一个无锁的算法需要多个写操作时，它们将显得更加有用。因为当多个线程同时在同一个内存地址中尝试RMW操作时，它们能很有效率地排成一队，并分时地执行这些操作。我已经在之前的博文中讨论过RMW操作的应用，例如<a href="http://preshing.com/20120226/roll-your-own-lightweight-mutex">lightweight mutex</a>（轻量级互斥锁）， <a href="http://preshing.com/20120305/implementing-a-recursive-mutex">recursive mutex</a>（递归互斥锁）和<a href="http://preshing.com/20120522/lightweight-in-memory-logging">lightweight logging system</a>（轻量级的日志系统）。</p>
<p align="center">
<img src="https://preshing.com/images/rmw-turnstile-2.png" alt="RMW"/>
</p>

<p>RMW操作的例子包括Win32下的<a href="http://msdn.microsoft.com/en-us/library/2ddez55b(v=vs.90).aspx"><code>_InterlockedIncrement</code></a>，IOS下的<a href="http://developer.apple.com/library/ios/#DOCUMENTATION/System/Conceptual/ManPages_iPhoneOS/man3/OSAtomicAdd32.3.html"><code>OSAtomicAdd32</code></a>，和C++11下的<a href="http://www.stdthread.co.uk/doc/headers/atomic/atomic/specializations/integral/fetch_add.html"><code>std::atomic::fetch_add</code></a>。需要我们注意的是，C++11中，原子操作标准并不保证这个操作在所有平台下都是无锁的，所以最好能够了解你使用的平台是否符合。你可以通过调用<a href="http://www.stdthread.co.uk/doc/headers/atomic/atomic/specializations/integral/is_lock_free.html"><code>std::atomic&lt;&gt;::is_lock_free</code></a>来确认。</p>
<p>不同的CPU家族有<a href="https://jfdube.wordpress.com/2011/11/30/understanding-atomic-operations/">不同的方式</a>来支持RMW操作。像PowerPC和ARM这样的处理器有<a href="http://en.wikipedia.org/wiki/Load-link/store-conditional">load-link/store-conditional</a>指令，这将能有效的帮助你在底层实现自己的RMW操作，虽然它不是经常用到。同时，通用的RMW操作一般也是够用的。</p>
<p>就像在流程图中展示的那样，即使在单核系统中，原子的RMW操作也是无锁编程的一个必要组成部分。没有原子性，一个线程可以在执行操作的中途被打断，而这可能会导致不一致的状态。</p>
<h2 id="CAS（Compare-And-Swap）循环"><a href="#CAS（Compare-And-Swap）循环" class="headerlink" title="CAS（Compare-And-Swap）循环"></a>CAS（Compare-And-Swap）循环</h2><p>可能讨论最多的RMW操作就是<a href="http://en.wikipedia.org/wiki/Compare-and-swap">compare-and-swap</a>（CAS）。在Win32中，CAS通过一系列的内联函数来提供，比如<a href="http://msdn.microsoft.com/en-us/library/ttk2z1ws.aspx"><code>_InterlockedCompareExchange</code></a>。通常，程序员在一个循环中使用CAS来重复尝试一个操作。这个模型典型的操作包括：将一个共享变量复制到一个局部变量中，进行一些特殊的操作，然后尝试使用CAS来修改该共享变量：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LockFreeQueue::push</span><span class="params">(Node* newHead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Copy a shared variable (m_Head) to a local.</span></span><br><span class="line">        Node* oldHead = m_Head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Do some speculative work, not yet visible to other threads.</span></span><br><span class="line">        newHead-&gt;next = oldHead;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Next, attempt to publish our changes to the shared variable.</span></span><br><span class="line">        <span class="comment">// If the shared variable hasn&#x27;t changed, the CAS succeeds and we return.</span></span><br><span class="line">        <span class="comment">// Otherwise, repeat.</span></span><br><span class="line">        <span class="keyword">if</span> (_InterlockedCompareExchange(&amp;m_Head, newHead, oldHead) == oldHead)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这些循环仍然被认为是无锁的，因为如果一个线程的测试失败了，这就意味着它一定在另一个线程中成功了——即使一些体系结构提供了一个差的CAS变体。当进行CAS循环时，特殊需要注意的地方使操作必须防止出现<a href="https://en.wikipedia.org/wiki/ABA_problem">ABA问题</a>。</p>
<h2 id="顺序一致性"><a href="#顺序一致性" class="headerlink" title="顺序一致性"></a>顺序一致性</h2><p>顺序一致性表示所有的线程都具有相同的内存操作顺序，同时这个顺序与程序源代码中的执行顺序保持一致。在顺序一致性的前提下，<a href="http://preshing.com/20120515/memory-reordering-caught-in-the-act">之前博客</a>中出现的内存重新排序的情况就不会出现。</p>
<p>一个简单但不切实际的实现顺序一致性的方法是关掉编译器优化，同时强制要求所有的线程跑在同一核中。在一个核中，即使线程先得到或者随意的线程调度的情况下也不会出现内存乱序的情况。</p>
<p>一些编程语言即使在多核环境下也提供了包括顺序一致性的优化代码。在C++11中，你可以将共享变量声明为C++11中有默认内存顺序限制的原子类型。在Java中，你可以将共享变量声明为volatile类型。这里是用C++11的方式重写的<a href="http://preshing.com/20120515/memory-reordering-caught-in-the-act">之前博客</a>的例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">std::atomic&lt;<span class="keyword">int</span>&gt; <span class="title">X</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">Y</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="keyword">int</span> r1, r2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    X.<span class="built_in">store</span>(<span class="number">1</span>);</span><br><span class="line">    r1 = Y.<span class="built_in">load</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Y.<span class="built_in">store</span>(<span class="number">1</span>);</span><br><span class="line">    r2 = X.<span class="built_in">load</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为C++11的原子类型保证了顺序一致性，所以结果不可能为<code>r1=r2=0</code>。为了实现这种效果，编译器必须增加额外的指令——内存屏障和/或RMW操作。相比于那些程序员直接处理内存顺序来说，这些额外的指令让应用的执行效率更低。</p>
<h2 id="内存顺序"><a href="#内存顺序" class="headerlink" title="内存顺序"></a>内存顺序</h2><p>就像在流程图中所建议的，任何时候你使用多核做无锁编程时，你的环境都不能保证顺序一致性，所以你必须考虑如何防止内存乱序。</p>
<p>在当今的体系结构下，保证正确的内存顺序一般有三种方向，它们能同时防止<a href="http://preshing.com/20120625/memory-ordering-at-compile-time">编译器乱序</a>和<a href="http://preshing.com/20120710/memory-barriers-are-like-source-control-operations">处理器乱序</a>：</p>
<ul>
<li>一个轻量级的同步或者内存屏障指令，这个我会在<a href="http://preshing.com/20120913/acquire-and-release-semantics">以后的博客</a>中解释；</li>
<li>一个完整的内存屏障指令，我<a href="http://preshing.com/20120522/lightweight-in-memory-logging">之前的博客</a>已经描述过了；</li>
<li>提供Acquire或release semantics的内存操作。</li>
</ul>
<p>Acquire semantics能够防止操作指令后面的内存操作乱序，而release semantics能够防止操作指令前面的内存操作乱序。这些操作尤其适合出现生产者/消费者关系的情况，也就是一个线程修改一些信息而另一个线程获得信息。我将会在<a href="http://preshing.com/20120913/acquire-and-release-semantics">以后的博客</a>里讨论这个问题。</p>
<h2 id="不同的处理器有不同的内存模型"><a href="#不同的处理器有不同的内存模型" class="headerlink" title="不同的处理器有不同的内存模型"></a>不同的处理器有不同的内存模型</h2><p>当出现内存乱序时，<a href="http://www.linuxjournal.com/node/8212/print">不同的CPU都有不同的习惯</a>。规则是由每一个CPU供应商制定的，同时该CPU在硬件上严格地服从这个规则。比如，PowerPC和ARM处理器自己可以改变和指令相关的内存存储的顺序，但是，通常X86/64系列的CPU从英特尔到AMD系列都不能实现。所以我们说前者的CPU应有一个更加<a href="http://preshing.com/20120930/weak-vs-strong-memory-models">自由的内存模型</a>。</p>
<p>这里有一些方案来抽象这些硬件平台相关的细节，尤其是C++11给我们一种标准的方法来写可移植的无所代码。但是现在，我认为大多数的无锁编程程序员都至少有些还在意平台的不同。如果这里有一个最重要的平台不同点需要被记住的话，那一定是在X86/64指令集中，每一次从内存中获得数据会产生一次Acquire semantics，每一次将数据存到内存会产生一次release semantics——至少对无SSE指令和没有写结合操作的内存操作来说如此。所以，以前的无锁代码可以很好的在X86/64平台上运行，但是<a href="http://www.drdobbs.com/parallel/208801974">其他机器</a>中可能会失效。</p>
<p>如果你对硬件怎么实现内存乱序和为什么要有内存乱序感兴趣的话，我建议你看一下附录C中提到的《<a href="https://mirrors.edge.kernel.org/pub/linux/kernel/people/paulmck/perfbook/perfbook.2011.01.02a.pdf">Is Parallel Programming Hard, And, If So, What Can You Do About It?</a>》（并行编程难么？）这本书。另外你也应注意内存乱序也会由于编译器将指令乱序而出现。</p>
<p>在过去，我很少讲无锁编程的实际应用层面：比如什么时候使用它？我们有多需要使用它？我也很少提到验证无锁代码有效性的重要性。然而，我希望读者们明白的是，这个介绍只是提供了一些基本的无锁编程的概念所以你需要阅读一些其他的资料来进行更加深入的研究。</p>
<h2 id="附加资料"><a href="#附加资料" class="headerlink" title="附加资料"></a>附加资料</h2><ul>
<li><a href="http://www.justsoftwaresolutions.co.uk/blog/">Anthony Williams’ blog</a> and his book, <a href="http://www.amazon.com/gp/product/1933988770/ref=as_li_ss_tl?ie=UTF8&tag=preshonprogr-20&linkCode=as2&camp=1789&creative=390957&creativeASIN=1933988770">C++ Concurrency in Action</a></li>
<li><a href="http://www.1024cores.net/">Dmitriy V’jukov’s website</a> and various <a href="https://groups.google.com/forum/?fromgroups#!forum/lock-free">forum discussions</a></li>
<li><a href="http://bartoszmilewski.com/">Bartosz Milewski’s blog</a></li>
<li>Charles Bloom’s <a href="http://cbloomrants.blogspot.ca/2012/06/06-12-12-another-threading-post-index.html">Low-Level Threading series</a> on his blog</li>
<li>Doug Lea’s <a href="http://g.oswego.edu/dl/jmm/cookbook.html">JSR-133 Cookbook</a></li>
<li>Howells and McKenney’s <a href="http://www.kernel.org/doc/Documentation/memory-barriers.txt">memory-barriers.txt</a> document</li>
<li>Hans Boehm’s <a href="http://www.hpl.hp.com/personal/Hans_Boehm/c++mm/">collection of links</a> about the C++11 memory model</li>
<li>Herb Sutter’s <a href="http://www.gotw.ca/publications/">Effective Concurrency</a> series</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>C++11</tag>
        <tag>C++并发</tag>
        <tag>学习心得</tag>
      </tags>
  </entry>
  <entry>
    <title>Never Say Goodbye 写于2.18离珠海前夜</title>
    <url>/2022/02/18/Never_Say_Goodbye/</url>
    <content><![CDATA[<h1 id="Never-Say-Goodbye-写于2-18离珠海前夜"><a href="#Never-Say-Goodbye-写于2-18离珠海前夜" class="headerlink" title="Never Say Goodbye 写于2.18离珠海前夜"></a>Never Say Goodbye 写于2.18离珠海前夜</h1><p>这几天一直过得浑浑噩噩的。</p>
<span id="more"></span>

<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=1842025914&auto=1&height=66"></iframe>

<p>一两年前一直很发愁，铁定了心不想升学，本科就出去当社畜，可是心里真的完全没底。本科就出去当社畜，最好的途径就是校招，校招要比社招难度低不少吧？不过我对这种事情也不算特别清楚。但是自己水平实在是菜的很，将来简历上都没什么好写的。只能靠笨鸟先飞，读书的时候就提前找实习积累一下经验，也能增加自己的竞争力。可是问题就出在这，之前一直很发愁，我到底能不能找到<del>合适的</del>实习工作呢？为了找实习工作，也需要积累项目经验，需要刷算法题，需要刷面试题。项目实在写不了多少了，太菜，算法题也是刷着刷着就不想刷了，太累太费脑子，一直在拖拖拖摆烂。最后被兄弟提醒了一下，大三上的寒假就可以试着找实习工作了，立马紧张的不行，从兄弟那请教怎么写简历，在什么平台上找工作发简历，大体了解了一下面试的流程。</p>
<p>虽然说是想着谁要我我就去谁那里工作，但是心里对未来工作的城市多少还是有点要求的，比如不想去北京上海这两个超级大城市，能在成都这样的新一线城市工作最好。抱着试一试的心，在牛客上浏览了成都武汉深圳杭州几个城市的所有正在招人的C++岗位，看到适合的就投了一下，甚至还投了一个还是两个字节的岗位来着。哦对，忘记说了，我还是挺想去字节工作的，虽然是一个令人恶心的互联网大厂，不过可能是因为A-SOUL，字节对我有巨大的吸引力。后面有三家公司的HR打来了电话回复，一个在上课被我直接挂掉了（悲），一个认为我投的不合适，想问问我还会不会考虑其他岗位，那自然也是pass了。最后一个就是宽德私募，也就是我后面来实习的这家公司。宽德看中了我的简历，认为有培养的潜力，也要工作需要的项目经验，很自然地约了一周之后的周末面试。一周的准备时间，项目和算法题是肯定来不及了，只能狂刷面试题，面试题也是随便百度了一下，找到了一个作者在知乎上总结的两篇C++面试文章，抱着临阵磨枪不快也光的心态去刷。刷面试题那会甚至把所有能翘掉的课都翘掉了，很多娱乐活动也推辞掉了，专心背面试题。还好我还是有一点C++基础的，刷起来也没那么痛苦，边摸编刷，提前一天完成了任务。然后就是面试，直接是CTO面的，做完自我介绍后就开始讨论我的项目经验，也就是之前写的那个订餐系统。那个订餐系统最早的版本是当作C++课的大作业来写的，几乎是边学C++和Qt边写出来的，可以说是一个很简陋的玩具。后来C++和Qt的水平不断精进，也渐渐有了重写订餐系统的想法，但真正的重构拖到了大三上学期，花了一个多月的事件，陆陆续续地把订餐系统进行了一次程度相当大的重构，让这个玩具变得没那么简陋了，当然，还只是玩具而已。</p>
<p>回到正题，前面说关于这个订餐系统面试官跟我聊了好久，主要就是在问订餐系统TCP通信的部分。在交流时我提到了这个系统对网络稳定性的要求比较高，实时性很强，不能容忍太大的延迟。可能就是这几句话引起了面试官的兴趣，他告诉我，我这个项目的所谓的“实时性、低延迟”之类的其实都是很不像样子的，跟宽德在搞的系统比起来完全是小儿科。后面问了TCP的报文结构，我没怎么答上来。然后又问了我STL容器相关的问题，刚好是我在面试题里复习到的内容，对答如流。最后很顺利地通过了面试，HR后面就约谈了薪资和工作地点问题。当时投宽德我是冲着它的成都分部的岗位去的，但公司希望我能来珠海总部实习。本来我就已经从山东到遥远的四川成都上学，再去趟珠海实习一下也完全没什么好吧，立马答应了。答应后还花了很大精力去说服父母支持我去珠海实习，现在想想还挺有趣的。</p>
<p>大三上最后一门考试是1月5号，6号上午我就坐飞机来珠海到公司报到，7号正式开始实习生活。</p>
<p>实习被年假分成了两个阶段，年前是一月七号到一月二十八号（实际上年前我二十九号、三十号两天也在公司申请了加班）。三十一号的凌晨回到了山东老家开始<del>享受</del>年假，年后初六（二月六号）就坐飞机飞回了珠海，初七开始正式年后的实习，一直实习到二月二十八号上午去办理离职手续。</p>
<p>年前一到宽德就意识到了这家公司的福利有多好：一日三餐，实习生甚至提供酒店住宿，报销一个来回的机票。公司里有健身器材，有很多零食水果和饮料，每周三下午都会有肯德基、必胜客和奈雪外卖组成的下午茶。考勤弹性很大，一周工作五天，周末也不会加班。工资也不错，一天300。对我来说简直是捡到宝了。公司提供的酒店是一家老旧的连锁酒店，破破烂烂的，但是好在卫生条件说得过去，离公司也只有步行五分钟的距离。年前那会公司里也没有几个实习生，我自己一个人住，住在一间挤挤巴巴的单人间，窗户很小，空间也很小。房间进门就是床，越过床就是卫生间的门，整个屋子都很潮湿，有一股霉味。在房门和床之间、床和卫生间的门之间各有一个小空道，两个小空道靠着床头的位置各塞了一个小床头柜。床头柜前空间小的塞不进椅子，不过房间里也没提供椅子。晚上我想玩自己的笔记本电脑，就只能把电脑放在其中的一个床头柜上（另外一个床头柜放了A-SOUL跟欧莱雅男士联名的化妆品盒，我从成都带过来用），外接键盘因为太长还要放一部分在床上，没有椅子，就直接坐着自己的行李箱，就这样每晚挤挤巴巴地用电脑打守望先锋，床上摆着平板或者手机挂着A-SOUL的直播。</p>
<p>年前的任务量比较大，我工作态度也特别认真。年前的任务是低延迟系统的核心通信部分，基于Solarflare专业网卡的网络通信，我的任务是阅读官方的API文档，再根据一个现成的开源库，去封装一个网络通信库。这是我第一次做这么底层的东西，也是第一次实际见到以纳秒为工作单位的系统。那阵子虽然一边摸鱼一边研究，但是一整个白天下来天天都很累。珠海疫情没爆发前，每晚上在公司吃完饭，都要先出去溜达一圈散散步放松一下身心，再回到酒店挤在床头柜前打游戏、看直播，跟前女友聊天。晚上溜达的时候还发现了一家粤式饮品店，从外面看起来挺不错的样子。后来也进去了两次，喝姜撞奶，很好喝。年前一共有四个周末，这四个周末的周六我都主动申请或者被动（年假调休）在公司里加班。主动申请加班也是因为窝在酒店没啥事情做，还不如去公司摸摸鱼，赚加班费。休息或出去玩的话，周日一天就够了。第一周的周日去周边的小公园玩了一下，顺便爬了一下山，沿着步行山道散了很远的步，也爬到一座山的山顶远眺大海和海上的港珠澳大桥，我甚至觉得自己看到了澳门。公司在的珠海香洲区，有几座连在一起的山，一直绵延到海边。我的工位刚好靠着落地窗，从落地窗往外望就可以看到旁边的山。天晴的话，可以看到山上的步行山道有很小很小的行人经过，阴天下雨的话，会从海那边飘来很多云雾，给山围上一圈丝带，看起来仙气十足。</p>
<p>年前发生了一个挺倒霉的事情，刚买了快一年的小米11手机WIFI模块烧坏了，用不了WIFI，只能用流量上网。其实小米11刚发售就已经有很多用户因为WIFI模块失效申请售后（主板设计问题），我那会还很庆幸自己的小米11没有遇到这个问题，觉得自己运气不错，结果年前还是遭了。手机遭了，自己也很糟心，只能周末骑自行车跑到了一个很远的售后点去检查，然后申请了免费换新机的服务，又等了好几天才去取到新手机。不过售后点刚好在横琴区海边。我很喜欢海。第一次去售后点，返程的时候先沿着海边走了一段路，那会刚好疫情爆发没多久，路上几乎没什么行人。又在海边的一个公园买了肯德基当午饭，边看海边吃汉堡炸鸡，吃完才满足地回酒店休息。</p>
<p>年前的工资计算到一月二十五号，二十八号放假那天才发现二十六号就已经发工资了，申请的从成都到珠海的机票报销也已经到账了，一共发了4500+500=5000块钱。二十八号放假当晚，想了一下，决定咬咬牙奢侈一把，于是人生第一次自己单独去了公司楼下一家西餐厅吃完饭。平日里在工位上透过落地窗就可以看到那家西餐厅，那会就很羡慕那些坐在椅子上慢慢喝酒吃西餐的人，很想亲身体验一下他们这种悠哉游哉的生活。那顿晚饭点了茴香土豆、意面、三明治，甚至还点了一杯鸡尾酒，吃得很撑。因为年前疫情的原因，我一度以为自己不能回家过年了因而十分郁闷，不过还好最后还是回家了。但是直到快到放假前珠海才降为低风险地区，因此我也只能订了三十号晚上的机票，因为三十号的机票相对要便宜一点。我也就顺便申请了二十九、三十号两天在公司里加一下班，赚一下加班费。说是加班，其实更多是在摸鱼，在工位上玩手机刷B站，用公司电脑刷知乎，写回答发表文章。二十九号下午也早早地离开了公司，做完核酸后又骑自行车到第二个周末修手机时去的海边玩。那次海边热闹多了，熙熙攘攘的很多人，沙滩也终于解封了。我脱鞋踩着海水散了一会步，还禁不住馋买了一串糖葫芦边走边吃。也顺便去拍了珠海渔女雕像，珠海的知名地标。晚上从海边回去，找了一家牛肉火锅店，准备尝一尝惦记了很久的牛肉火锅。很可惜，我完全不知道怎么吃牛肉火锅，不知道哪些肉好吃，不知道各种肉分别需要涮几秒钟而不是直接一股脑倒进锅里。牛肉丸子也因为太大只，中间尝了三四次都没完全熟透，就扔在里面一直煮到最后才吃，肉都老的嚼不动了。三十号简简单单地休息了下，下午多睡了会，很晚才去机场。记得去机场的路上用B站后台播放了很多遍珈乐的歌。</p>
<p>年假挺快乐的，见到了父母，见到了一些想见到的亲戚，见到了前女友，也见到了关系最好的那群朋友，像往常一样，跟朋友们一起在其中一个朋友家做披萨之类的美食。初四还跟前女友一起去了百盛购物商场，让她帮忙挑着买了几件衣服。买的衣服挺贵的，狠狠地肉疼了一下，不过这也是第一次用自己赚的钱去买衣服。年假很短，过得很快。</p>
<p>年后初六下午我就回了珠海，在酒店安顿好后去了酒店旁边的一家餐饮店解决了午餐，开始期待年后的实习生活。那会还不知道年后会遇到什么。</p>
<p>年后公司的实习生变多了，公司为了节省开支，每两个实习生一起合住一间双人间。双人间面积大了很多很多，甚至在窗边还有一张小桌子和椅子，我立马霸占了那张小桌子和椅子，晚上打游戏看直播也终于不用那么挤挤巴巴了。舍友是个才大二的后辈，很开朗，人挺好的。他的基础不太行，所以晚上下班后经常会来找我请教问题。有时候晚上饿了，还会一起去（接近十二点）酒店楼下的一个路边摊吃重庆小面。</p>
<p>年后工作时间比较短，任务比较少，我的工作态度也变得摸了不少。一开始给我分配的任务是做一个决策树，我的妈，这可难倒我了，结果马上就换成了做一个高速查表类，其实就是哈希表，也有一个现成的开源库来研究。我变得摸了不少，决定慢慢拖工期，在DDL之前大体研究明白然后做个简单封装得了。周末也终于把放假前的心愿了结了，去广州找一个朋友玩。周六上午就坐高铁去了广州，全程才一个小时左右。朋友领着在广州逛了很多地方，吃了一些特色的食品，比如菠萝炒饭，作为一个山东人很难相信广东这边竟然会把菠萝看成番茄一样的存在，又是蔬菜又是水果，可以直接吃也可以用来做饭。晚上被朋友领着去吃了真正的牛肉火锅，见识到了地道的牛肉火锅的吃法，不同种类的牛肉要涮多久，也终于尝到了朋友一直说的独家自制调料，确实好吃。那顿牛肉火锅拯救了我对牛肉火锅的印象。我宣布从今往后火锅只有三种，四川火锅，潮汕牛肉火锅，其他火锅。晚上还去参观了广州塔，灯光很漂亮。广州塔附近的地段很繁华，高耸入云的摩天大厦，大厦里的公司几乎都是我们公司的友商或者同行，各种私募投资公司、证券公司和银行，不得不感叹广州金融业的发达。不过的确，也就只有这种行业能够买的起这附近的地皮了。第二天中午朋友领着吃了早午茶，吃了很多粤式小吃，早饭午饭一起解决。下午又坐高铁回到珠海，收心准备下一周的工作。</p>
<p>接着到来的就是情人节，情人节也没什么特别的，依旧是白天摸鱼和工作，晚上下班立马回到酒店休息。情人节晚上有A-SOUL的情人节限定直播，边打游戏边看直播，平常的日子平常的快乐。不过毕竟情人节，还是要庆祝一下的，发了一条QQ空间动态表示了一下。很平常的情人节的晚上，不过那会没想到这会是暴风雨前的宁静。晚上快12点，本来看似聊得好好的前女友突然心情不好，停止了聊天。我郁闷了一会，觉得没什么，就准备溜一下直播的录播切片然后睡觉。当晚嘉然的直播效果很好。嘉然在许愿的时候说了一句话，“你要相信你自己哦，你一直都超棒的”。这句话对我的杀伤力很大，这么多年来，身边的人几乎都在告诉我，你要怎么做，你应该怎么做，很少会有人会给我鼓励。那一段我窝在被子里反复看了很多遍，竟然哭了出来。孤身一人跑到这么远的地方来工作实习，深夜悄悄地破防。我上次哭应该还是大一下学期的期末考试，物理挂科，把这个消息告诉父母之后，父母问了一下详细情况，出乎意料地没有批评我而是鼓励我好好复习争取补考通过。晚上爸爸还发了一段录像，是父母和奶奶在家里吃完饭，很日常的晚饭，也没刻意做什么事情，只是录了一下奶奶和餐桌上的饭菜，那晚我看了很多遍这个录像，边看边哭。</p>
<p>十五号正常去工作，前女友一直到下午才愿意来跟我说话。问清冷战的原因后吵了一架，我很生气，提出了分手后删了她的好友。后面我冷静了下来，但是没有改变自己的决定。通过她的好友申请后，编辑发送了一段文字，大抵意思是我们两人不适合，还是分开，对彼此都好。这个分手的想法不是一时起意，实际上可能已经萌生了很久，每次大的争吵后可能都让这个想法越来越强烈。于是十五号彻底结束了持续了六年的恋情，变成一条单身狗。</p>
<p>年后原本就越来越不想工作了，甚至想要早点开学回学校休息。比起工作，读书真的轻松太多。分手之后，整个人浑浑噩噩的，更是什么事情也不想做了。刚分手的那两天，我甚至完全吃不进饭，扒两口就恶心的不行，反胃。时常会胸口痛，巨大的缺失感。这才明白之前感到的孤独其实都是假的，因为那会无论感到多孤独，实际上永远都会有一个人默默地等在那里，听我絮絮叨叨，听我各种抱怨，听我讲各种琐事，各种开心的事情烦恼的事情，无论听不听得懂，始终都在听。后面几天做的事情其实几乎跟之前是一样的，工作、摸鱼，吃饭，但又完全不一样。经常会下意识地打开手机，想要把刚刚遇到的事情分享给她，然后才意识到那个她已经不在那里等着我了。十五号晚上流着泪删光了动态，删光了留言，删光了照片。我把过去删了个干净，但好像组成自己的一部分也被删掉了，自己被删掉的那部分像一个黑洞，不断吸引着我、提醒着我，一种难以言表的缺失感、空虚感。后面几天，尤其是在见过她发了一条跟闺蜜出去吃火锅的动态后，自己逐渐没有刚开始那么难受，心里也只想着早日结束实习逃回学校。今天中午又在楼下那家餐饮店吃的午饭，点了一份上次因为不会念“粿”这个字而没点的粿条，顺便也点了上次也点过的汤。记得初六那次来，点了一份牛腩汤泡饭。那天专门拍了自己点的菜发给了她，想让她看看清淡的广东菜。她还说看起来好寒碜，因为她不喜欢像牛腩这种大肉块。今天吃时与当时完全是不同的两种心情。还好，明天就能逃回学校了。</p>
<p>这六年来我们两个人的故事，我想说成一个早已预料到结局、但还是心甘情愿地做了六年的梦，现在梦醒了。结局似乎在最初就已经可以预料到了，两家的关系太近，会受到各种阻力，除此之外，最重要的是两个人之间的不适合，性格很难相处，各方面的不适合。十四号那晚她不开心，是因为明明情人节，我却没有做什么特殊的表示，送花、送礼物或者最简单的发红包都没有做，这些事情其实都是很简单的，都是顺手就能做到的事情。关键的不在于形式，而是情感的表达。并非是这一次情感表达的缺失让她难过，而是日积月累的缺失让她彻底失望了。一直以来我以为自己明白喜欢是一种陪伴，是一种习惯，其实却一直都没有真正明白。六年来我一直在当烂人，没有珍惜这份感情，把这份感情当作理所应当，落得这个结局也是必然。就像她之前说的那样，明明是最好的时光，我们却一直用来等待。我的幼稚彻底毁了这段感情。</p>
<p>无论如何，我还是很感谢这六年来她愿意陪我去做这个梦。从小认识，初中再熟络起来，高一不明不白地在一起，高二经历了一次又一次地争吵，高三趋于稳定，大学成为异地恋，一直到今年。很感谢六年来的陪伴。翻照片时回忆起高二高三，每次大休，只有不到一天的休息时间，都要挤时间见面，还互相送过饭。大一暑假陪我去海边，晚上在海边散步，去逛海底世界。某年情人节家里下了大雪，一起在河边的雪地上画画……这些回忆我可能要花很久时间才能忘掉，最后可能也忘不掉。很不舍得结束，但是结束对两人都是最好的选择。她没必要再束缚在我身上，可以去争取本就应该属于她的更好的未来。我也应该学会怎样独立地活在这个世界上，去做一个坚强的大人而不是像现在这样懦弱幼稚的烂人。希望未来我们都能在彼此选择的道路上熠熠生辉。</p>
<p>这次珠海的实习之旅，得到了很多，也失去了很多。生活还在继续，我也不应停下自己的脚步。</p>
<p>Never Say Goodbye。</p>
<p>写于2022.2.18，离珠海前夜。实际上写完已经十九日凌晨。</p>
<blockquote>
<p>晚风中闪过 几帧从前啊<br>飞驰中旋转 已不见了吗</p>
</blockquote>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>关于std::thread的二三事</title>
    <url>/2022/02/01/%E5%85%B3%E4%BA%8Estd_thread%E7%9A%84%E4%BA%8C%E4%B8%89%E4%BA%8B/</url>
    <content><![CDATA[<h1 id="关于std-thread的二三事"><a href="#关于std-thread的二三事" class="headerlink" title="关于std::thread的二三事"></a>关于std::thread的二三事</h1><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>很早之前写过一篇关于线程池文章，《<a href="https://zhuanlan.zhihu.com/p/367309864">基于C++11实现线程池</a>》，一直被网友翻出来，对里面的一些细节实现提了许多问题。其实更推荐大家去阅读后来写的另外一篇关于线程池的文章，《<a href="https://zhuanlan.zhihu.com/p/444375447">当我谈线程池时我谈些什么——线程池学习笔记</a>》。原因很简单，写第一篇线程池文章的时候，自己属实是菜的不行（现在依旧是菜的不行），花了很长时间去学习一些里面用到的C++11的新语法，文章里面讲的重点也是涉及到的C++11语法。所以，更关心线程池本身的实现的话，更适合去看新文章《<a href="https://zhuanlan.zhihu.com/p/444375447">当我谈线程池时我谈些什么——线程池学习笔记</a>》，作为现代C++语法的新学者，想花更多精力在学习现代C++语法的话，适合去看老文章《<a href="https://zhuanlan.zhihu.com/p/367309864">基于C++11实现线程池</a>》。</p>
<p>言归正传，在那篇老文章里有挺多网友提了一些<code>std::thread</code>相关的问题。今天看了会cppreference，写了点代码实践了下，集中回答了一些问题，顺便水篇文章算是学习笔记了。</p>
<span id="more"></span>

<h2 id="std-thread对象构建的新线程何时开始执行"><a href="#std-thread对象构建的新线程何时开始执行" class="headerlink" title="std::thread对象构建的新线程何时开始执行"></a>std::thread对象构建的新线程何时开始执行</h2><p>线程在构造关联的线程对象时立即开始执行，从提供给作为构造函数参数的顶层函数开始。</p>
<p>有几点需要注意：</p>
<ul>
<li>顶层函数的返回值将被忽略，而且若它以抛异常终止，则调用<code>std::terminate</code>。在需要获取返回值时，顶层函数可以通过<code>std::promise</code>或者修改共享变量（可能需要锁机制进行线程同步）。</li>
<li>当使用不带参数的默认构造函数<code>thread()</code>构造<code>std::thread</code>对象时，该对象不表示任何线程，也不会有新线程产生。</li>
<li>当时用移动构造函数<code>thread(thread&amp;&amp;other)</code>构造<code>std::thread</code>对象时，该对象会被构造为表示曾为<code>other</code>所表示的执行线程的<code>std::thread</code>对象。此调用后<code>other</code>不再表示执行线程。</li>
<li><code>std::thread</code>对象不可复制（复制构造函数已被删除）。没有两个<code>std::thread</code>对象会表示同一执行线程。</li>
</ul>
<h2 id="std-thread对象构建新线程时可以传入什么东西作为参数"><a href="#std-thread对象构建新线程时可以传入什么东西作为参数" class="headerlink" title="std::thread对象构建新线程时可以传入什么东西作为参数"></a>std::thread对象构建新线程时可以传入什么东西作为参数</h2><p><code>std::thread</code>常用的构造函数如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; class Function, class... Args &gt;</span></span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">thread</span><span class="params">( Function&amp;&amp; f, Args&amp;&amp;... args )</span></span>;</span><br></pre></td></tr></table></figure>

<p>其中，<code>f</code>为任意可调用对象（Callable），<code>args</code>为任意数目的作为可调用对象<code>f</code>的参数。</p>
<p>可调用对象（Callable）是C++的一个具名要求，常见的函数、成员函数、仿函数（函数对象）都属于可调用对象。</p>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>传入函数的情况最常见也最简单，例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Thread 1 executing\n&quot;</span>;</span><br><span class="line">        ++n;</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">10</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">   <span class="function">std::thread <span class="title">t</span><span class="params">(f1, n + <span class="number">1</span>)</span></span>;</span><br><span class="line">   t.<span class="built_in">join</span>();</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>仅需将函数名与函数参数分别传入即可。</p>
<h3 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h3><p>当需要传入类时，有两种情况，第一种是比较复杂的情况，我们需要传入类的成员函数。例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Thread 3 executing\n&quot;</span>;</span><br><span class="line">            ++n;</span><br><span class="line">            std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">10</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    foo f;</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(&amp;foo::bar, &amp;f)</span></span>; <span class="comment">// t 在对象 f 上运行 foo::bar()</span></span><br><span class="line">   	t.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们需要以<code>std::thread(&amp;类名::成员函数名, &amp;类实例)</code>的格式传入新线程。</p>
<h3 id="仿函数（函数对象）"><a href="#仿函数（函数对象）" class="headerlink" title="仿函数（函数对象）"></a>仿函数（函数对象）</h3><p>仿函数（或称函数对象）便是传入类的第二种情况，此时该类的工作比较简单（单一，并非指实际工作难度），例如标准库中的<code>std::function</code>, <code>std::bind</code>等，又例如第一篇文章中的<code>ThreadWorker</code>类。成为仿函数的类，一般来说需要**重载函数调用运算符()**。在<code>std::thread</code>对象构建新线程后，会自动进行INVOKE操作执行传入的可调用对象。INVOKE操作执行对象为仿函数时，会自动调用仿函数重载的函数调用运算符<code>operator()</code>。例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">baz</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Thread 4 executing\n&quot;</span>;</span><br><span class="line">            ++n;</span><br><span class="line">            std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">10</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(b)</span></span>; <span class="comment">// t 在对象 b 的副本上运行 baz::operator()</span></span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，新线程运行的仿函数实际上是传入时指定的仿函数的副本，这同时也就要求该仿函数是可拷贝的。</p>
<h3 id="函数参数传引用"><a href="#函数参数传引用" class="headerlink" title="函数参数传引用"></a>函数参数传引用</h3><p><code>std::thread</code>对象构造新线程时，会移动或按值复制线程函数的参数。若需要传递引用参数给线程函数，则必须包装它（例如用<code>std::ref</code>或<code>std::cref</code>）。例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">int</span>&amp; n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Thread 2 executing\n&quot;</span>;</span><br><span class="line">        ++n;</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">10</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(f2, std::ref(n))</span></span>; <span class="comment">// 按引用传递</span></span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>暂时就总结了这些，后续若有内容再更新。</p>
<h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><p><a href="https://zh.cppreference.com/w/cpp/thread/thread">std::thread-cppreference.com</a></p>
<p><a href="https://skykeyjoker.com/2021/04/22/C%2B%2B%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">C++并发编程</a></p>
<p><a href="https://paul.pub/cpp-memory-model/">C++内存模型</a></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>C++11</tag>
        <tag>C++14</tag>
        <tag>C++17</tag>
        <tag>C++并发</tag>
        <tag>学习心得</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux低延迟服务器调优</title>
    <url>/2022/01/27/Linux%E4%BD%8E%E5%BB%B6%E8%BF%9F%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%B0%83%E4%BC%98/</url>
    <content><![CDATA[<h1 id="Linux低延迟服务器调优"><a href="#Linux低延迟服务器调优" class="headerlink" title="Linux低延迟服务器调优"></a>Linux低延迟服务器调优</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>本文基于饶萌大佬的《Linux低延迟服务器系统调优》一文总结整理，自行补充了一些细节。大佬博文指路：</p>
<p><a href="https://zhuanlan.zhihu.com/p/58669088">Linux低延迟服务器系统调优</a></p>
<p>低延迟关键不在于低，而在于<strong>稳定</strong>，稳定即可预期，可掌控，这对高频领域来说尤其重要。谈及Linux低延迟技术时，人们经常提到“Kernel Bypass”（内核旁路），即绕过内核，这是因为内核处理不仅慢且延迟不稳定。因此一个延迟要求很高的实时任务是不能触碰内核的，“避免触碰”是一个比Bypass更高的要求：不能以<strong>任何</strong>方式进入内核。中断（Interrupt）是进入内核的方式之一，本文的关键点也在于避免关键线程被中断。即使中断发生时线程是空闲的，但重新回到用户态后CPU缓存被污染了，下一次处理请求的延迟也会变得不稳定。</p>
<span id="more"></span>

<h2 id="绑定核心"><a href="#绑定核心" class="headerlink" title="绑定核心"></a>绑定核心</h2><p>中断是CPU Core收到的，可以让关键线程<strong>绑定</strong>在某个Core上，然后避免各种中断源（IRQ）向这个Core发送中断。</p>
<p>绑定程序在一个核上运行，有两种方法：<code>taskset</code>和<code>sched_setaffinity</code>。</p>
<h3 id="CPU-Affinity"><a href="#CPU-Affinity" class="headerlink" title="CPU Affinity"></a>CPU Affinity</h3><p>中文译作“CPU亲和力”，是指在CMP结构下，能够将一个或多个进程绑定到一个或多个处理器上运行。</p>
<h3 id="查看进程分配的CPU-Core"><a href="#查看进程分配的CPU-Core" class="headerlink" title="查看进程分配的CPU Core"></a>查看进程分配的CPU Core</h3><p>可以使用<code>taskset</code>命令查看：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">taskset -c -p &lt;pid&gt;</span><br></pre></td></tr></table></figure>

<p>运行结构：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">pid 17147&#x27;s current affinity list: 3-5</span><br></pre></td></tr></table></figure>

<p>该CPU亲和力列表表明该进程可能会被安排在3-5中任意一个CPU Core上。</p>
<p>更具体地查看某进程当前正运行在哪个CPU Core上，我们可以使用<code>top</code>命令查看：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">top -p &lt;uid&gt;</span><br></pre></td></tr></table></figure>

<h3 id="taskset"><a href="#taskset" class="headerlink" title="taskset"></a>taskset</h3><p>使用<code>taskset</code>命令将进程绑定到指定核：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">taskset -cp &lt;core&gt; &lt;pid&gt;</span><br></pre></td></tr></table></figure>

<p>如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">taskset -cp 1,2,3 31693</span><br></pre></td></tr></table></figure>

<p>该例会将PID为31693的进程绑定到1-3核上运行。</p>
<h3 id="sched-setaffinity"><a href="#sched-setaffinity" class="headerlink" title="sched_setaffinity"></a>sched_setaffinity</h3><p>编写代码时，我们可以通过<code>sched_setaffinity()</code>函数设置CPU亲和力的掩码，从而将该线程或者进程与指定的CPU绑定。</p>
<p>一个CPU的亲和力掩码用一个<code>cpu_set_t</code>结构体来表示一个CPU集合，下面这几个宏分别对掩码集进行操作：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">CPU_ZERO</span>(<span class="keyword">cpu_set_t</span>* cpusetp);               <span class="comment">// 清空一个集合</span></span><br><span class="line"><span class="built_in">CPU_SET</span>(<span class="keyword">size_t</span> cpu, <span class="keyword">cpu_set_t</span>* cpusetp);    <span class="comment">// 加入CPU Core到集合</span></span><br><span class="line"><span class="built_in">CPU_CLR</span>(<span class="keyword">size_t</span> cpu, <span class="keyword">cpu_set_t</span>* cpusetp);    <span class="comment">// 从集合中删除指定的CPU Core</span></span><br><span class="line"><span class="built_in">CPU_ISSET</span>(<span class="keyword">size_t</span> cpu, <span class="keyword">cpu_set_t</span>* cpusetp);  <span class="comment">// 检查一个CPU Core是否在集合中</span></span><br></pre></td></tr></table></figure>

<p>使用<code>sched_setaffinity()</code>与<code>sched*_*getaffinity()</code>等函数需要引进头文件<code>sched.h</code>。</p>
<ul>
<li>头文件：<code>sched.h</code></li>
<li><code>int sched_setaffinity(pid_t pid, size_t cpusetsize, const cpu_set_t* mask)</code><br>该函数将PID为<em>pid</em>的进程设置为运行在<em>mask</em>指定的CPU Core上。<br>* 若<em>pid</em>为0，则表示指定当前进程。<br>* <em>cpusetsize</em>为<em>mask</em>的大小，通常为<code>sizeof(cpu_set_t)</code>。<br>* <em>cpuset</em>即用<code>cpu_set_t</code>结构体表示的CPU Core集合。<br>* 函数返回0表示成功，失败则返回-1。</li>
<li><code>int sched_getaffinity(pid_t pid, size_t cpusetsize, cpu_set_t* mask)</code><br>函数获取PID为<em>pid</em>的进程CPU亲和力掩码，并保存在<em>mask</em>结构体中，即获得指定pid当前可以运行在哪些CPU上。<br>* 若<em>pid</em>为0，则表示指定当前进程。<br>* <em>cpusetsize</em>为<em>mask</em>的大小，通常为<code>sizeof(cpu_set_t)</code>。<br>* <em>cpuset</em>即用<code>cpu_set_t</code>结构体表示的CPU Core集合。<br>* 函数返回0表示成功，失败则返回-1。</li>
</ul>
<p>使用示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __USE_GNU</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// CPU Core Binded sched_setaffinity</span></span><br><span class="line">    <span class="keyword">cpu_set_t</span> mask;  <span class="comment">// CPU Core Set</span></span><br><span class="line">    <span class="built_in">CPU_ZERO</span>(&amp;mask);  <span class="comment">// Set Zero</span></span><br><span class="line">    <span class="built_in">CPU_SET</span>(<span class="number">6</span>, &amp;mask);  <span class="comment">// Add core to set</span></span><br><span class="line">    <span class="built_in">CPU_SET</span>(<span class="number">7</span>, &amp;mask);</span><br><span class="line">    <span class="built_in">CPU_SET</span>(<span class="number">8</span>, &amp;mask);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> rc;</span><br><span class="line">    <span class="keyword">if</span>((rc = <span class="built_in">sched_setaffinity</span>(<span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(mask), &amp;mask))</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Warning: Set affinity failed!&quot;</span>&lt;&lt;<span class="built_in">strerror</span>(rc)&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">cpu_set_t</span> get;</span><br><span class="line">        <span class="keyword">if</span>((rc = <span class="built_in">sched_getaffinity</span>(<span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(get), &amp;get)))</span><br><span class="line">        &#123;</span><br><span class="line">             cout&lt;&lt;<span class="string">&quot;Waring: Could not get thread affinity.&quot;</span>&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">pid_t</span> pid = <span class="built_in">getpid</span>();</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Current PID: &quot;</span>&lt;&lt;pid&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">size_t</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="built_in">sysconf</span>(_SC_NPROCESSORS_CONF); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">CPU_ISSUE</span>(i, &amp;get))</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;Running on processor: &quot;</span>&lt;&lt;i&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：若使用到pthread，则需要将pthread.h放到sched.h之后，并在sched.h之前声明#define __USE_GNU，否则会出现undefined reference CPU_ZERO等错误。</p>
</blockquote>
<h2 id="屏蔽硬中断（硬盘、网卡）"><a href="#屏蔽硬中断（硬盘、网卡）" class="headerlink" title="屏蔽硬中断（硬盘、网卡）"></a>屏蔽硬中断（硬盘、网卡）</h2><p>中断源（IRQ）向CPU Core发送中断，CPU Core调用中断处理程序对中断进程处理。我们可以通过改写<code>/proc/irq/*/smp_affinity</code>文件，避免中断源（IRQ）向某些CPU Core发送中断。该方法对硬盘、网卡等设备引起的硬中断有效。</p>
<h3 id="查看设备中断数据"><a href="#查看设备中断数据" class="headerlink" title="查看设备中断数据"></a>查看设备中断数据</h3><p>通过查看<code>/proc/interrupts</code>文件可查看设备中断数据：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">           CPU0       CPU1       CPU2       CPU3       CPU4       CPU5       CPU6       CPU7       </span><br><span class="line">  0:         17          0          0          0          0          0          0          0   IO-APIC   2-edge      timer</span><br><span class="line">  8:          0          0          0          0          0          1          0          0   IO-APIC   8-edge      rtc0</span><br><span class="line">  9:       4058        258        157         14        464        454         34        134   IO-APIC   9-fasteoi   acpi</span><br><span class="line"> 16:     137153      19574      11430      10138      47072      27502      15934      10113   IO-APIC  16-fasteoi   ahci[0000:05:00.0], xhci-hcd:usb1, nvkm</span><br><span class="line"> 17:         16          3          1          9         35          2          2          1   IO-APIC  17-fasteoi   snd_hda_intel:card1</span><br><span class="line"> 18:      88952       2170       1592       1253       4255       5430       1790       1738   IO-APIC  18-fasteoi   wlp3s0</span><br><span class="line"> 22:     172111       2954       2515       1897       5000       3684       2479       2513   IO-APIC  22-fasteoi   snd_hda_intel:card0</span><br><span class="line">NMI:          0          0          0          0          0          0          0          0   Non-maskable interrupts</span><br><span class="line">LOC:     395090     279787     239243     235695     233918      90471      94234      90479   Local timer interrupts</span><br><span class="line">SPU:          0          0          0          0          0          0          0          0   Spurious interrupts</span><br><span class="line">PMI:          0          0          0          0          0          0          0          0   Performance monitoring interrupts</span><br><span class="line">IWI:          0          0          0          1          1          1          0          3   IRQ work interrupts</span><br><span class="line">RTR:          6          0          0          0          0          0          0          0   APIC ICR read retries</span><br><span class="line">RES:       7425       5663       4375       3801       3051       2825       1963       1787   Rescheduling interrupts</span><br><span class="line">CAL:         31         29         24         22         36         28         34         31   Function call interrupts</span><br><span class="line">TLB:      10387      11374      10758      11769       7566       8508       8799       7195   TLB shootdowns</span><br><span class="line">TRM:          2          2          2          2          2          2          2          2   Thermal event interrupts</span><br><span class="line">THR:          0          0          0          0          0          0          0          0   Threshold APIC interrupts</span><br><span class="line">MCE:          0          0          0          0          0          0          0          0   Machine check exceptions</span><br><span class="line">MCP:         17         17         17         17         17         17         17         17   Machine check polls</span><br><span class="line">ERR:          0</span><br><span class="line">MIS:          0</span><br><span class="line">PIN:          0          0          0          0          0          0          0          0   Posted-interrupt notification event</span><br><span class="line">PIW:          0          0          0          0          0          0          0          0   Posted-interrupt wakeup event</span><br></pre></td></tr></table></figure>

<ul>
<li>第一列是IRQ号</li>
<li>第二列开始表示某CPU内核被多少次中断。</li>
</ul>
<h3 id="SMP-AFFINITY"><a href="#SMP-AFFINITY" class="headerlink" title="SMP_AFFINITY"></a>SMP_AFFINITY</h3><p>SMP，即symmetric multiprocessing（对称多处理器），通过多个处理器处理程序的方式。smp_affinity文件处理一个IRQ的中断亲和性。在smp_affinity文件结合每个IRQ号在<code>/proc/irq/&#123;IRQ_NUMBER&#125;/smp_affinity</code>文件。该文件的值是一个16进制掩码表示系统的所有CPU核。</p>
<p>例如，Solarflare网卡的设备名为eth1，其中断如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grep eth1 /proc/interrupts</span><br></pre></td></tr></table></figure>

<p>输出如下：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">64:    95218  168786727  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  IR-PCI-MSI-edge  eth1-0</span><br><span class="line">65:    38440  53649095   0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  IR-PCI-MSI-edge  eth1-1</span><br><span class="line">66:    6207   1011519    0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  IR-PCI-MSI-edge  eth1-ptp</span><br></pre></td></tr></table></figure>

<p>可以看到eth1设备共有三个IRQ号：64,65,66，其相对应的smp_afffinity文件时：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat /proc/irq/64/smp_affinity</span><br><span class="line">cat /proc/irq/65/smp_affinity</span><br><span class="line">cat /proc/irq/66/smp_affinity</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000,00000000,00000000,0000000f</span><br><span class="line">0000,00000000,00000000,0000000f</span><br><span class="line">0000,00000000,00000000,0000000f</span><br></pre></td></tr></table></figure>

<p>smp_affinity是16进制表示，f就是二进制的1111，表示0-3这四个CPU Core都会参与处理中断。</p>
<p>假设我们想要指定仅0-1这两个核心处理中断，则可以写入如下数据到smp_affinity：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> 3 &gt; /proc/irq/64/smp_affinity</span><br><span class="line"><span class="built_in">echo</span> 3 &gt; /proc/irq/65/smp_affinity</span><br><span class="line"><span class="built_in">echo</span> 3 &gt; /proc/irq/66/smp_affinity</span><br></pre></td></tr></table></figure>

<h2 id="屏蔽软中断（Work-queue）"><a href="#屏蔽软中断（Work-queue）" class="headerlink" title="屏蔽软中断（Work queue）"></a>屏蔽软中断（Work queue）</h2><p>workqueue是自kernel2.6引入的一种任务执行机制，和softirq，tasklet并称下半部（bottom half）三剑客。workqueue在进程上下文异步执行任务，能够进行睡眠。可以通过改写<code>/sys/devices/virtual/workqueue/*/cpumask</code>文件实现屏蔽Work queue的软中断。</p>
<p><code>/sys/devices/virtual/workqueue/cpumask</code>文件中记录了全局的cpumask，可以影响所有的workqueue。文件内容格式与smp_affinity相同：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat /sys/devices/virtual/workqueue/cpumask</span><br></pre></td></tr></table></figure>

<p>输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000,00000000,00000000,00000007</span><br></pre></td></tr></table></figure>

<p>代表0-2这三个CPU Core用来处理work queue，我们可以通过写入”f”来仅让与核心进程无关的0-3这四个CPU Core参与work queue处理：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;f&#x27;</span> &gt; /sys/devices/virtual/workqueue/cpumask</span><br></pre></td></tr></table></figure>

<h2 id="屏蔽软中断（Local-Timer-Interrupt）"><a href="#屏蔽软中断（Local-Timer-Interrupt）" class="headerlink" title="屏蔽软中断（Local Timer Interrupt）"></a>屏蔽软中断（Local Timer Interrupt）</h2><p>Linux的scheduler time slice是通过LOC实现的，如果我们让一个线程独占一个CPU Core，就不需要scheduler在这个CPU Core上切换进程。可以通过<code>isolcpus</code>系统启动选项隔离一些核，让他们只能被绑定的线程使用。同时，我们还可以启用“adaptive-ticks”模式，达到减少独占线程收到LOC频率的效果，这可以通过<code>nohz_full</code>和<code>rcu_nocbs</code>启动选项实现。</p>
<p>假设令6-8三个核心屏蔽软中断，我们需要在系统启动选项中加入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nohz=on nohz_full=6-8 rcu_nocbs=6-8</span><br></pre></td></tr></table></figure>

<p>进入adaptive-ticks模式后，如果CPU Core上的running task只有一个时，系统向其发送的LOC频率会显著降低，但LOC不能被完全屏蔽，系统内核的一些操作比如计算CPU负载等仍然需要周期性的LOC。</p>
<h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><p>中断和smp_affinity：</p>
<p><a href="https://huataihuang.gitbooks.io/cloud-atlas/content/os/linux/kernel/cpu/interrupt_and_smp_affinity.html">中断和smp_affinity</a></p>
<p>SolarFlare资源汇总：</p>
<p><a href="https://williamlfang.github.io/shared/2019-12-20-solarflare%E8%B5%84%E6%BA%90%E6%B1%87%E6%80%BB/">SolarFlare资源汇总</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>学习心得</tag>
        <tag>Linux</tag>
        <tag>低延迟系统</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt实现简易心跳包机制</title>
    <url>/2022/01/01/tcpheart/</url>
    <content><![CDATA[<h1 id="Qt实现简易心跳包机制"><a href="#Qt实现简易心跳包机制" class="headerlink" title="Qt实现简易心跳包机制"></a>Qt实现简易心跳包机制</h1><p>因为网络通信的不稳定性，在一些实时性、网络稳定性要求较高的情境下，我们需要一个实时检测客户端与服务端之间的连接状态和通信功能是否运行正常的机制，心跳包机制便是其中之一。接下来我会讲一下在之前的一个小项目中，利用Qt实现的简易心跳包检测机制。</p>
<span id="more"></span>

<h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p><img src="%E5%AE%A2%E6%88%B7%E7%AB%AF.jpg" alt="客户端"></p>
<p><img src="%E6%9C%8D%E5%8A%A1%E7%AB%AF.jpg" alt="服务端"></p>
<p>心跳包检测的原理是客户端定时向服务端发送心跳包，服务端收到心跳包后立即回复客户端。此间客户端检查心跳包是否发送成功以及是否超时。在一些实时性要求比较高的情境下，检测心跳包超时是有必要的。可以通过记录等待回复的心跳包数来实现检测心跳包超时。</p>
<h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><h3 id="启动定时器"><a href="#启动定时器" class="headerlink" title="启动定时器"></a>启动定时器</h3><p>客户端的核心在于定时发送心跳包，这里我们利用一个<em>TcpHeart</em>类来实现定时发送心跳包。</p>
<p><em>TcpHeart</em>类声明如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QObject&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QTimer&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TcpHeart</span> :</span> <span class="keyword">public</span> QObject &#123;</span><br><span class="line">	Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">TcpHeart</span><span class="params">(QObject* parent = <span class="number">0</span>)</span></span>;</span><br><span class="line">	~<span class="built_in">TcpHeart</span>() <span class="keyword">noexcept</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">startHeartTimer</span><span class="params">()</span></span>;  <span class="comment">// 启动定时器</span></span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">sigHeartBad</span><span class="params">()</span></span>;  <span class="comment">// 心跳包错误信号</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">sigHeartReq</span><span class="params">()</span></span>;  <span class="comment">// 发送心跳包信号</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">slotTimeOut</span><span class="params">()</span></span>;  <span class="comment">// 定时事件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">slotHeartBack</span><span class="params">()</span></span>;  <span class="comment">// 收到服务端心跳包回复</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	QTimer* m_heart_timer;</span><br><span class="line">	<span class="keyword">int</span> m_count;  <span class="comment">// 等待回复心跳包累计数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><em>TcpHeart</em>核心是利用QTimer实现一个定时任务：启动一个定时器，定时器timeOut消息发出后，检测当前等待回复的心跳包数量。<strong>若等待回复的心跳包数量≤3</strong>，则可以继续发送心跳包，并增加等待回复的心跳包数量；否则采取心跳包超时处理，停止计时器并发送心跳包错误消息。</p>
<p>定时事件<code>slotTimeOut()</code>实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpHeart::slotTimeOut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (m_count &gt; <span class="number">2</span>) &#123;</span><br><span class="line">		m_count = <span class="number">0</span>;</span><br><span class="line">		m_heart_timer-&gt;<span class="built_in">stop</span>();</span><br><span class="line">		<span class="function">emit <span class="title">sigHeartBad</span><span class="params">()</span></span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	m_count++;</span><br><span class="line">	<span class="function">emit <span class="title">sigHeartReq</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在收到服务端心跳包回复后，我们需要将等待回复的心跳包计数清零。这里需要直接将计数清零，因为每次收到回复后，超时检测机制都应重新启动。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpHeart::slotHeartBack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	m_count = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>TcpHeart</em>的完整实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">TcpHeart::<span class="built_in">TcpHeart</span>(QObject *parent)</span><br><span class="line">	: <span class="built_in">QObject</span>(parent) &#123;</span><br><span class="line">	m_heart_timer = <span class="keyword">new</span> <span class="built_in">QTimer</span>(<span class="keyword">this</span>);</span><br><span class="line">	m_count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">connect</span>(m_heart_timer, &amp;QTimer::timeout, <span class="keyword">this</span>, &amp;TcpHeart::slotTimeOut);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TcpHeart::~<span class="built_in">TcpHeart</span>() <span class="keyword">noexcept</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpHeart::startHeartTimer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	m_heart_timer-&gt;<span class="built_in">start</span>(<span class="number">2000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpHeart::slotTimeOut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (m_count &gt; <span class="number">2</span>) &#123;</span><br><span class="line">		m_count = <span class="number">0</span>;</span><br><span class="line">		m_heart_timer-&gt;<span class="built_in">stop</span>();</span><br><span class="line">		<span class="function">emit <span class="title">sigHeartBad</span><span class="params">()</span></span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	m_count++;</span><br><span class="line">	<span class="function">emit <span class="title">sigHeartReq</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpHeart::slotHeartBack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	m_count = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="发送心跳包"><a href="#发送心跳包" class="headerlink" title="发送心跳包"></a>发送心跳包</h3><p>正式实现心跳包机制的类是<em>StatusClient</em>。<em>StatusClient</em>类声明如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QDebug&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QObject&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QTcpSocket&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;TcpHeart.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;json.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StatusClient</span> :</span> <span class="keyword">public</span> QObject &#123;</span><br><span class="line">	Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">StatusClient</span><span class="params">(<span class="keyword">const</span> QString host, <span class="keyword">const</span> <span class="keyword">int</span> port, QObject *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">connectedToServer</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">sigHeartBack</span><span class="params">()</span></span>;              <span class="comment">// 心跳包返回</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">signalDisconnectedToServer</span><span class="params">()</span></span>;<span class="comment">//  心跳包断连</span></span><br><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">slotStatusReadyRead</span><span class="params">()</span></span>; <span class="comment">// 客户端状态信道</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">slotWriteHeartSocket</span><span class="params">()</span></span>;<span class="comment">// 写心跳包</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">slotHeartBad</span><span class="params">()</span></span>;        <span class="comment">// 心跳包掉线处理</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">// 客户端状态信道</span></span><br><span class="line">	QTcpSocket *_statusSocket;<span class="comment">// 客户端状态信道</span></span><br><span class="line">	TcpHeart *heart;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	QString m_host;</span><br><span class="line">	<span class="keyword">int</span> m_port;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在我之前的那个小项目中，客户端服务端利用JSON进行通信，定义了一些双方之间通信的一些消息格式，如code字段区分正常消息与心跳包消息。</p>
<p><em>StatusClient</em>首先与心跳包服务器建立链接，在收到服务器端的”OK”消息后，便利用<em>TcpHeart</em>类开启定时器，定时向服务器发送心跳包。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StatusClient::slotStatusReadyRead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 收到服务端发来的客户端状态查询</span></span><br><span class="line">	QByteArray data;</span><br><span class="line">	data = _statusSocket-&gt;<span class="built_in">readAll</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">using</span> Json = nlohmann::json;</span><br><span class="line">	<span class="comment">// 判断是否为状态查询</span></span><br><span class="line">	QString dataStr = QString::<span class="built_in">fromUtf8</span>(data);</span><br><span class="line">	Json json = Json::<span class="built_in">parse</span>(dataStr.<span class="built_in">toUtf8</span>(), <span class="literal">nullptr</span>, <span class="literal">false</span>);</span><br><span class="line">	<span class="keyword">int</span> code = json[<span class="string">&quot;code&quot;</span>].get&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (code == <span class="number">2</span>) &#123;</span><br><span class="line">		QString msgStr = QString::<span class="built_in">fromStdString</span>(json[<span class="string">&quot;Msg&quot;</span>].get&lt;std::string&gt;());</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (msgStr == <span class="string">&quot;OK&quot;</span>)<span class="comment">// 服务器返回&quot;OK&quot;，开启心跳包检测</span></span><br><span class="line">		&#123;</span><br><span class="line">			heart = <span class="keyword">new</span> TcpHeart;</span><br><span class="line">			<span class="comment">// 开始心跳检测</span></span><br><span class="line">			heart-&gt;<span class="built_in">startHeartTimer</span>();</span><br><span class="line">			<span class="built_in">connect</span>(heart, &amp;TcpHeart::sigHeartReq, <span class="keyword">this</span>, &amp;StatusClient::slotWriteHeartSocket);<span class="comment">// 发送心跳包</span></span><br><span class="line">			<span class="built_in">connect</span>(<span class="keyword">this</span>, &amp;StatusClient::sigHeartBack, heart, &amp;TcpHeart::slotHeartBack);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 处理心跳包异常</span></span><br><span class="line">			<span class="built_in">connect</span>(heart, &amp;TcpHeart::sigHeartBad, <span class="keyword">this</span>, &amp;StatusClient::slotHeartBad);</span><br><span class="line">		&#125;</span><br><span class="line">        </span><br><span class="line">		...</span><br><span class="line">           </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>向服务端定时发送心跳包消息，若发送失败，进行心跳包掉线处理：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StatusClient::slotWriteHeartSocket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	QByteArray data;</span><br><span class="line">	<span class="comment">// 构建状态返回</span></span><br><span class="line">	<span class="keyword">using</span> Json = nlohmann::json;</span><br><span class="line">	Json jsonValue;</span><br><span class="line">	jsonValue[<span class="string">&quot;code&quot;</span>] = <span class="number">2</span>;</span><br><span class="line">	jsonValue[<span class="string">&quot;Msg&quot;</span>] = <span class="string">&quot;Heart&quot;</span>;</span><br><span class="line">	data = QString::<span class="built_in">fromStdString</span>(jsonValue.<span class="built_in">dump</span>(<span class="number">2</span>)).<span class="built_in">toUtf8</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 状态信道，向服务端发送心跳包</span></span><br><span class="line">	<span class="built_in">qDebug</span>() &lt;&lt; <span class="keyword">this</span>-&gt;<span class="built_in">thread</span>() &lt;&lt; <span class="string">&quot;发送一次心跳包&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 状态信道</span></span><br><span class="line">	<span class="keyword">bool</span> ret = _statusSocket-&gt;<span class="built_in">write</span>(data);</span><br><span class="line">	_statusSocket-&gt;<span class="built_in">waitForBytesWritten</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!ret) &#123;</span><br><span class="line">		<span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;发送心跳包失败&quot;</span>;</span><br><span class="line">		<span class="function">emit <span class="title">signalDisconnectedToServer</span><span class="params">()</span></span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>若从客户端收到心跳包回复，则重启<em>TcpHeart</em>对象的超时检测机制：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StatusClient::slotStatusReadyRead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 收到服务端发来的客户端状态查询</span></span><br><span class="line">	QByteArray data;</span><br><span class="line">	data = _statusSocket-&gt;<span class="built_in">readAll</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">using</span> Json = nlohmann::json;</span><br><span class="line">	<span class="comment">// 判断是否为状态查询</span></span><br><span class="line">	QString dataStr = QString::<span class="built_in">fromUtf8</span>(data);</span><br><span class="line">	Json json = Json::<span class="built_in">parse</span>(dataStr.<span class="built_in">toUtf8</span>(), <span class="literal">nullptr</span>, <span class="literal">false</span>);</span><br><span class="line">	<span class="keyword">int</span> code = json[<span class="string">&quot;code&quot;</span>].get&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (code == <span class="number">2</span>) &#123;</span><br><span class="line">		QString msgStr = QString::<span class="built_in">fromStdString</span>(json[<span class="string">&quot;Msg&quot;</span>].get&lt;std::string&gt;());</span><br><span class="line"></span><br><span class="line">		...</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 心跳反馈</span></span><br><span class="line">		<span class="keyword">if</span> (msgStr == <span class="string">&quot;HEART_BACK&quot;</span>) &#123;</span><br><span class="line">			<span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;HEART BACK ONCE&quot;</span>;</span><br><span class="line">			<span class="function">emit <span class="title">sigHeartBack</span><span class="params">()</span></span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="心跳包掉线处理"><a href="#心跳包掉线处理" class="headerlink" title="心跳包掉线处理"></a>心跳包掉线处理</h3><p>收到<em>TcpHeart</em>的心跳包超时消息后，进行相应的掉线处理：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StatusClient::slotHeartBad</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 断线处理</span></span><br><span class="line">	<span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;心跳包断线&quot;</span>;</span><br><span class="line">	_statusSocket-&gt;<span class="built_in">disconnectFromHost</span>();</span><br><span class="line">	<span class="function">emit <span class="title">signalDisconnectedToServer</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="完整实现"><a href="#完整实现" class="headerlink" title="完整实现"></a>完整实现</h3><p>客户端完整实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">StatusClient::<span class="built_in">StatusClient</span>(<span class="keyword">const</span> QString host, <span class="keyword">const</span> <span class="keyword">int</span> port, QObject *parent)</span><br><span class="line">	: <span class="built_in">m_host</span>(host),</span><br><span class="line">	  <span class="built_in">m_port</span>(port),</span><br><span class="line">	  <span class="built_in">QObject</span>(parent) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StatusClient::connectedToServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	_statusSocket = <span class="keyword">new</span> QTcpSocket;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">connect</span>(_statusSocket, &amp;QTcpSocket::readyRead, <span class="keyword">this</span>, &amp;StatusClient::slotStatusReadyRead);</span><br><span class="line">	<span class="built_in">connect</span>(_statusSocket, &amp;QTcpSocket::disconnected, <span class="keyword">this</span>, &amp;StatusClient::signalDisconnectedToServer);</span><br><span class="line"></span><br><span class="line">	_statusSocket-&gt;<span class="built_in">connectToHost</span>(m_host, m_port);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!_statusSocket-&gt;<span class="built_in">waitForConnected</span>()) &#123;</span><br><span class="line">		<span class="function">emit <span class="title">signalDisconnectedToServer</span><span class="params">()</span></span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StatusClient::slotStatusReadyRead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 收到服务端发来的客户端状态查询</span></span><br><span class="line">	QByteArray data;</span><br><span class="line">	data = _statusSocket-&gt;<span class="built_in">readAll</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">using</span> Json = nlohmann::json;</span><br><span class="line">	<span class="comment">// 判断是否为状态查询</span></span><br><span class="line">	QString dataStr = QString::<span class="built_in">fromUtf8</span>(data);</span><br><span class="line">	Json json = Json::<span class="built_in">parse</span>(dataStr.<span class="built_in">toUtf8</span>(), <span class="literal">nullptr</span>, <span class="literal">false</span>);</span><br><span class="line">	<span class="keyword">int</span> code = json[<span class="string">&quot;code&quot;</span>].get&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (code == <span class="number">2</span>) &#123;</span><br><span class="line">		QString msgStr = QString::<span class="built_in">fromStdString</span>(json[<span class="string">&quot;Msg&quot;</span>].get&lt;std::string&gt;());</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (msgStr == <span class="string">&quot;OK&quot;</span>)<span class="comment">// 服务器返回&quot;OK&quot;，开启心跳包检测</span></span><br><span class="line">		&#123;</span><br><span class="line">			heart = <span class="keyword">new</span> TcpHeart;</span><br><span class="line">			<span class="comment">// 开始心跳检测</span></span><br><span class="line">			heart-&gt;<span class="built_in">startHeartTimer</span>();</span><br><span class="line">			<span class="built_in">connect</span>(heart, &amp;TcpHeart::sigHeartReq, <span class="keyword">this</span>, &amp;StatusClient::slotWriteHeartSocket);<span class="comment">// 发送心跳包</span></span><br><span class="line">			<span class="built_in">connect</span>(<span class="keyword">this</span>, &amp;StatusClient::sigHeartBack, heart, &amp;TcpHeart::slotHeartBack);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 处理心跳包异常</span></span><br><span class="line">			<span class="built_in">connect</span>(heart, &amp;TcpHeart::sigHeartBad, <span class="keyword">this</span>, &amp;StatusClient::slotHeartBad);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 心跳反馈</span></span><br><span class="line">		<span class="keyword">if</span> (msgStr == <span class="string">&quot;HEART_BACK&quot;</span>) &#123;</span><br><span class="line">			<span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;HEART BACK ONCE&quot;</span>;</span><br><span class="line">			<span class="function">emit <span class="title">sigHeartBack</span><span class="params">()</span></span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StatusClient::slotWriteHeartSocket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	QByteArray data;</span><br><span class="line">	<span class="comment">// 构建状态返回</span></span><br><span class="line">	<span class="keyword">using</span> Json = nlohmann::json;</span><br><span class="line">	Json jsonValue;</span><br><span class="line">	jsonValue[<span class="string">&quot;code&quot;</span>] = <span class="number">2</span>;</span><br><span class="line">	jsonValue[<span class="string">&quot;Msg&quot;</span>] = <span class="string">&quot;Heart&quot;</span>;</span><br><span class="line">	data = QString::<span class="built_in">fromStdString</span>(jsonValue.<span class="built_in">dump</span>(<span class="number">2</span>)).<span class="built_in">toUtf8</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 状态信道，向服务端发送心跳包</span></span><br><span class="line">	<span class="built_in">qDebug</span>() &lt;&lt; <span class="keyword">this</span>-&gt;<span class="built_in">thread</span>() &lt;&lt; <span class="string">&quot;发送一次心跳包&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 状态信道</span></span><br><span class="line">	<span class="keyword">bool</span> ret = _statusSocket-&gt;<span class="built_in">write</span>(data);</span><br><span class="line">	_statusSocket-&gt;<span class="built_in">waitForBytesWritten</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!ret) &#123;</span><br><span class="line">		<span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;发送心跳包失败&quot;</span>;</span><br><span class="line">		<span class="function">emit <span class="title">signalDisconnectedToServer</span><span class="params">()</span></span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StatusClient::slotHeartBad</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 断线处理</span></span><br><span class="line">	<span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;心跳包断线&quot;</span>;</span><br><span class="line">	_statusSocket-&gt;<span class="built_in">disconnectFromHost</span>();</span><br><span class="line">	<span class="function">emit <span class="title">signalDisconnectedToServer</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><p>服务端<em>StatusServer</em>声明如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QDebug&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QObject&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QTcpServer&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QTcpSocket&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;json.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StatusServer</span> :</span> <span class="keyword">public</span> QObject &#123;</span><br><span class="line">	Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">StatusServer</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> statusPort, QObject *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">serverEstablished</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">serverError</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">establishServer</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">slotNewStatusConnection</span><span class="params">()</span></span>;<span class="comment">// 状态信道链接</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">slotStatusReadyRead</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">// 状态信道</span></span><br><span class="line">	QTcpServer *_tcpStatusServer;</span><br><span class="line">	QList&lt;QTcpSocket *&gt; _tcpStatusClients;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> m_statusPort;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>服务端逻辑很简单，启动监听，保存客户端的链接，向客户端发送心跳初始化消息并回复客户端的心跳包。完整实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">StatusServer::<span class="built_in">StatusServer</span>(<span class="keyword">const</span> <span class="keyword">int</span> statusPort, QObject *parent)</span><br><span class="line">	: <span class="built_in">m_statusPort</span>(statusPort),</span><br><span class="line">	  <span class="built_in">QObject</span>(parent) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StatusServer::establishServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	_tcpStatusServer = <span class="keyword">new</span> QTcpServer;</span><br><span class="line">	<span class="keyword">bool</span> ret = _tcpStatusServer-&gt;<span class="built_in">listen</span>(QHostAddress::Any, m_statusPort);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!ret) &#123;</span><br><span class="line">		<span class="function">emit <span class="title">serverError</span><span class="params">()</span></span>;</span><br><span class="line">		<span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;状态服务器建立失败&quot;</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span></span><br><span class="line">		emit <span class="built_in">serverEstablished</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">connect</span>(_tcpStatusServer, &amp;QTcpServer::newConnection, <span class="keyword">this</span>, &amp;StatusServer::slotNewStatusConnection);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StatusServer::slotNewStatusConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 处理状态信道的新连接</span></span><br><span class="line">	QTcpSocket *currentSocket = _tcpStatusServer-&gt;<span class="built_in">nextPendingConnection</span>();</span><br><span class="line">	_tcpStatusClients.<span class="built_in">push_back</span>(currentSocket);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 向客户端发送初始化消息，启动心跳包</span></span><br><span class="line">	<span class="keyword">using</span> Json = nlohmann::json;</span><br><span class="line">	QByteArray sendData;</span><br><span class="line">	Json sendJsonData;</span><br><span class="line">	sendJsonData[<span class="string">&quot;code&quot;</span>] = <span class="number">2</span>;</span><br><span class="line">	sendJsonData[<span class="string">&quot;Msg&quot;</span>] = <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">	sendData = QString::<span class="built_in">fromStdString</span>(sendJsonData.<span class="built_in">dump</span>(<span class="number">2</span>)).<span class="built_in">toUtf8</span>();</span><br><span class="line">	currentSocket-&gt;<span class="built_in">write</span>(sendData);</span><br><span class="line">	currentSocket-&gt;<span class="built_in">flush</span>();</span><br><span class="line">	currentSocket-&gt;<span class="built_in">waitForBytesWritten</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">connect</span>(currentSocket, &amp;QTcpSocket::readyRead, <span class="keyword">this</span>, &amp;StatusServer::slotStatusReadyRead);</span><br><span class="line">	<span class="built_in">connect</span>(currentSocket, &amp;QTcpSocket::disconnected, [=, <span class="keyword">this</span>]() &#123;</span><br><span class="line">		_tcpStatusClients.<span class="built_in">removeAll</span>(currentSocket);</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StatusServer::slotStatusReadyRead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;心跳包thread&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;<span class="built_in">thread</span>();</span><br><span class="line">	<span class="comment">// 状态信道，处理客户端发来的心跳包</span></span><br><span class="line">	QTcpSocket *currentSocket = (QTcpSocket *) <span class="built_in">sender</span>();</span><br><span class="line">	QByteArray msgData = currentSocket-&gt;<span class="built_in">readAll</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">using</span> Json = nlohmann::json;</span><br><span class="line">	Json jsonData = Json::<span class="built_in">parse</span>(msgData.<span class="built_in">data</span>(), <span class="literal">nullptr</span>, <span class="literal">false</span>);</span><br><span class="line">	<span class="keyword">int</span> code = jsonData[<span class="string">&quot;code&quot;</span>].get&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (code == <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="built_in">qDebug</span>() &lt;&lt; currentSocket &lt;&lt; <span class="string">&quot;收到一次心跳包&quot;</span>;</span><br><span class="line">		QString msg = QString::<span class="built_in">fromStdString</span>(jsonData[<span class="string">&quot;Msg&quot;</span>].get&lt;std::string&gt;());</span><br><span class="line">		<span class="keyword">if</span> (msg == <span class="string">&quot;Heart&quot;</span>) &#123;</span><br><span class="line">			QByteArray sendData;</span><br><span class="line">			Json sendJsonData;</span><br><span class="line">			sendJsonData[<span class="string">&quot;code&quot;</span>] = <span class="number">2</span>;</span><br><span class="line">			sendJsonData[<span class="string">&quot;Msg&quot;</span>] = <span class="string">&quot;HEART_BACK&quot;</span>;</span><br><span class="line">			sendData = QString::<span class="built_in">fromStdString</span>(sendJsonData.<span class="built_in">dump</span>(<span class="number">2</span>)).<span class="built_in">toUtf8</span>();</span><br><span class="line">			currentSocket-&gt;<span class="built_in">write</span>(sendData);</span><br><span class="line">			currentSocket-&gt;<span class="built_in">flush</span>();</span><br><span class="line">			currentSocket-&gt;<span class="built_in">waitForBytesWritten</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>学习心得</tag>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title>当我谈线程池时我谈些什么</title>
    <url>/2021/12/12/%E5%BD%93%E6%88%91%E8%B0%88%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%97%B6%E6%88%91%E8%B0%88%E4%BA%9B%E4%BB%80%E4%B9%88/</url>
    <content><![CDATA[<h1 id="当我谈线程池时我谈些什么"><a href="#当我谈线程池时我谈些什么" class="headerlink" title="当我谈线程池时我谈些什么"></a>当我谈线程池时我谈些什么</h1><p>最近跟着purecpp社区里的两篇博文复习了一下两种线程池的C++实现（单任务队列、多任务队列），相比于之前那篇C++11实现线程池的博文，语言版本进行了一点小更新（C++14-C++17）。在这里结合代码记录一下学习心得。</p>
<blockquote>
<p>12.12，然然首播一周年辣（嘉然小姐首播周年快乐）</p>
</blockquote>
<span id="more"></span>

<h2 id="单任务队列线程池"><a href="#单任务队列线程池" class="headerlink" title="单任务队列线程池"></a>单任务队列线程池</h2><p>用现代的C++标准库（线程+锁+条件变量）实现一个单任务队列的线程池非常简单。就像之前那篇博文里面讲的一样，原理非常简单，对新手而言最复杂的其实就是C++11众多的新语言特性罢了。</p>
<p>一个简易的单任务队列线程池的实现思路：在线程池构造时初始化线程数，在析构时停止线程池。对外也只需要提供提交任务的接口就够了。</p>
<h3 id="接口设计"><a href="#接口设计" class="headerlink" title="接口设计"></a>接口设计</h3><h4 id="返回类型"><a href="#返回类型" class="headerlink" title="返回类型"></a>返回类型</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">ThreadPool</span><span class="params">(<span class="keyword">size_t</span> threads = std::thread::hardware_concurrency())</span></span>;  <span class="comment">// 构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">enqueue</span><span class="params">(F &amp;&amp;f, Args &amp;&amp;...args)</span></span>; <span class="comment">// 入队接口</span></span><br></pre></td></tr></table></figure>

<p>入队接口<code>enqueue()</code>这个模板函数返回值使用了<code>auto</code>关键字进行推导，实际上的返回值其实是一个future。future的类型如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> return_type = std::<span class="keyword">invoke_result_t</span>&lt;F, Args...&gt;;</span><br><span class="line">std::future&lt;return_type&gt; res;</span><br></pre></td></tr></table></figure>

<p>也就是说这个future返回的类型实际上是任务的返回类型。</p>
<h4 id="输入参数"><a href="#输入参数" class="headerlink" title="输入参数"></a>输入参数</h4><p>输入参数是一个可调用对象和它的参数，这里利用了C++11的可变参数模板来实现传递任意数量的可调用对象的参数。</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadPool</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">ThreadPool</span><span class="params">(<span class="keyword">size_t</span> threads = std::thread::hardware_concurrency())</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function">	<span class="keyword">auto</span> <span class="title">enqueue</span><span class="params">(F &amp;&amp;f, Args &amp;&amp;...args)</span></span>;</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">ThreadPool</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::vector&lt;std::thread&gt; workers;</span><br><span class="line">	std::queue&lt;std::function&lt;<span class="keyword">void</span>()&gt;&gt; tasks;</span><br><span class="line">	std::mutex queue_mutex;</span><br><span class="line">	std::condition_variable condition;</span><br><span class="line">	<span class="keyword">bool</span> stop;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个简易单任务队列线程池的成员只有一个线程组，一个任务队列。为了保证任务队列的线程安全，我们还提供了一个锁。同时我们还提供了一个条件变量，利用锁和条件变量，我们可以实现线程通知机制。线程通知机制指的是，刚开始时线程池中是没有任务的，所有的线程都等待任务的到来，当一个任务进入到线程池中，就会通知<strong>一个</strong>线程去处理到来的任务。</p>
<p>同时我们又提供了一个stop变量，用来在析构的时候停止和清理任务和线程。因为懒（高情商：RAII风格线程池，生命周期基本上与应用的生命周期一致），没有提供stop接口。</p>
<p>下面是具体实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Diana &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// * 简易多线程单任务队列线程池，使用线程安全队列，接口更人性化。</span></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">ThreadPool</span> &#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="keyword">explicit</span> <span class="title">ThreadPool</span><span class="params">(<span class="keyword">size_t</span> threads = std::thread::hardware_concurrency())</span> : stop(false) &#123;</span></span><br><span class="line">			<span class="comment">// 根据threads数量创建多个线程</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; threads; ++i) &#123;</span><br><span class="line">				workers.<span class="built_in">emplace_back</span>([<span class="keyword">this</span>]() &#123;</span><br><span class="line">					<span class="keyword">for</span> (;;) &#123;<span class="comment">// 工作线程就是一个死循环，不停查询任务队列并取出任务执行</span></span><br><span class="line">						std::function&lt;<span class="built_in"><span class="keyword">void</span></span>()&gt; task;</span><br><span class="line"></span><br><span class="line">						&#123;</span><br><span class="line">							std::unique_lock&lt;std::mutex&gt; <span class="built_in">lock</span>(<span class="keyword">this</span>-&gt;queue_mutex);</span><br><span class="line">							<span class="keyword">this</span>-&gt;condition.<span class="built_in">wait</span>(lock,</span><br><span class="line">												 [<span class="keyword">this</span>]() &#123;</span><br><span class="line">													 <span class="keyword">return</span> <span class="keyword">this</span>-&gt;stop || !<span class="keyword">this</span>-&gt;tasks.<span class="built_in">empty</span>();<span class="comment">// 条件变量等待线程池不为空或者stop</span></span><br><span class="line">												 &#125;);</span><br><span class="line">							<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;stop &amp;&amp; <span class="keyword">this</span>-&gt;tasks.<span class="built_in">empty</span>())<span class="comment">// 线程池为空且stop，证明线程池结束，退出线程</span></span><br><span class="line">								<span class="keyword">return</span>;</span><br><span class="line">							task = std::<span class="built_in">move</span>(<span class="keyword">this</span>-&gt;tasks.<span class="built_in">front</span>());<span class="comment">// 取出任务</span></span><br><span class="line">							<span class="keyword">this</span>-&gt;tasks.<span class="built_in">pop</span>();</span><br><span class="line">						&#125;</span><br><span class="line"></span><br><span class="line">						<span class="built_in">task</span>();<span class="comment">// 执行任务</span></span><br><span class="line">					&#125;</span><br><span class="line">				&#125;);<span class="comment">// lambda表达式构建</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function">		<span class="keyword">auto</span> <span class="title">enqueue</span><span class="params">(F &amp;&amp;f, Args &amp;&amp;...args)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">using</span> return_type = std::<span class="keyword">invoke_result_t</span>&lt;F, Args...&gt;;</span><br><span class="line">			<span class="keyword">auto</span> task = std::make_shared&lt;std::packaged_task&lt;<span class="built_in">return_type</span>()&gt;&gt;(</span><br><span class="line">					std::<span class="built_in">bind</span>(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...));<span class="comment">// 完美转发，构造任务仿函数的指针</span></span><br><span class="line">			std::future&lt;return_type&gt; res = task-&gt;<span class="built_in">get_future</span>();                  <span class="comment">// 获得函数执行的future返回</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(queue_mutex)</span></span>;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (stop) &#123;</span><br><span class="line">					<span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;enqueue on stopped Thread pool&quot;</span>);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				tasks.<span class="built_in">emplace</span>([task = std::<span class="built_in">move</span>(task)]() &#123; (*task)(); &#125;);<span class="comment">// 塞入任务队列</span></span><br><span class="line">			&#125;                                                            <span class="comment">// 入队列后即可解锁</span></span><br><span class="line">			condition.<span class="built_in">notify_one</span>();                                      <span class="comment">// 仅唤醒一个线程，避免无意义的竞争</span></span><br><span class="line">			<span class="keyword">return</span> res;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		~<span class="built_in">ThreadPool</span>() &#123;</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(queue_mutex)</span></span>;</span><br><span class="line">				stop = <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			condition.<span class="built_in">notify_all</span>();<span class="comment">// 唤醒所有线程，清理任务</span></span><br><span class="line">			<span class="keyword">for</span> (std::thread &amp;worker: workers)</span><br><span class="line">				worker.<span class="built_in">join</span>();<span class="comment">// 阻塞，等待所有线程执行结束</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		std::vector&lt;std::thread&gt; workers;</span><br><span class="line">		std::queue&lt;std::function&lt;<span class="keyword">void</span>()&gt;&gt; tasks;</span><br><span class="line">		std::mutex queue_mutex;</span><br><span class="line">		std::condition_variable condition;</span><br><span class="line">		<span class="keyword">bool</span> stop;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">&#125;;<span class="comment">// namespace Diana</span></span><br></pre></td></tr></table></figure>

<p>细节上的东西，注释已经写完了。</p>
<p>注意在有队伍进入队列时，仅需要notify_one()，避免无意义的线程竞争；在停止线程池时，要notify_all()唤醒所有进程。由于线程在等待stop标志，所以当唤醒之后才会把队列中的任务取出执行直到队列为空的时候才会退出线程。</p>
<h3 id="重构：分离队列代码，编写线程安全任务队列"><a href="#重构：分离队列代码，编写线程安全任务队列" class="headerlink" title="重构：分离队列代码，编写线程安全任务队列"></a>重构：分离队列代码，编写线程安全任务队列</h3><p>这里进行一次重构，像之前那片博文一样，封装一个线程安全队列：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Diana &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// * 线程安全队列</span></span><br><span class="line">	<span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">SafeQueue</span> &#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> T &amp;item)</span> </span>&#123;</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="function">std::scoped_lock <span class="title">lock</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">				queue_.<span class="built_in">push</span>(item);</span><br><span class="line">			&#125;</span><br><span class="line">			cond_.<span class="built_in">notify_one</span>();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T &amp;&amp;item)</span> </span>&#123;<span class="comment">// 两个push方法，此处不是万能引用而是单纯右值</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="function">std::scoped_lock <span class="title">lock</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">				queue_.<span class="built_in">push</span>(std::<span class="built_in">move</span>(item));</span><br><span class="line">			&#125;</span><br><span class="line">			cond_.<span class="built_in">notify_one</span>();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">bool</span> <span class="title">pop</span><span class="params">(T &amp;item)</span> </span>&#123;</span><br><span class="line">			<span class="function">std::unique_lock <span class="title">lock</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">			cond_.<span class="built_in">wait</span>(lock, [&amp;]() &#123;</span><br><span class="line">				<span class="keyword">return</span> !queue_.<span class="built_in">empty</span>() || stop_;</span><br><span class="line">			&#125;);</span><br><span class="line">			<span class="keyword">if</span> (queue_.<span class="built_in">empty</span>())</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			item = std::<span class="built_in">move</span>(queue_.<span class="built_in">front</span>());</span><br><span class="line">			queue_.<span class="built_in">pop</span>();</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function">std::<span class="keyword">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">			<span class="function">std::scoped_lock <span class="title">lock</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">			<span class="keyword">return</span> queue_.<span class="built_in">size</span>();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">			<span class="function">std::scoped_lock <span class="title">lock</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">			<span class="keyword">return</span> queue_.<span class="built_in">empty</span>();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="function">std::scoped_lock <span class="title">lock</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">				stop_ = <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			cond_.<span class="built_in">notify_all</span>();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		std::condition_variable cond_;</span><br><span class="line">		<span class="keyword">mutable</span> std::mutex mtx_;</span><br><span class="line">		std::queue&lt;T&gt; queue_;</span><br><span class="line">		<span class="keyword">bool</span> stop_ = <span class="literal">false</span>;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">&#125;;<span class="comment">// namespace Diana</span></span><br></pre></td></tr></table></figure>

<p>线程安全任务队列需要注意的细节不多。注意一下这里写了两个push方法，原因是在该模板类特化后，T已经是一个具体的类型，T&amp;&amp;就不再是泛型编程中常见的万能引用，而是一个单纯的右值了。我们可以通过再添加一个模板成员函数来合并两个push：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(U&amp;&amp; item)</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in"><span class="keyword">static_assert</span></span>(std::is_same&lt;U,T&gt;::value==<span class="literal">true</span>);</span><br><span class="line">        <span class="function">std::scoped_lock <span class="title">lock</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">        queue_.<span class="built_in">push</span>(std::forward(item));</span><br><span class="line">    &#125;</span><br><span class="line">    cond_.<span class="built_in">notify_one</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要注意的是，记得判断一下U和T的类型是一样的。</p>
<p>利用这个安全队列，我们可以重写一下单任务队列的线程池：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Diana &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">using</span> WorkItem = std::function&lt;<span class="built_in"><span class="keyword">void</span></span>()&gt;;</span><br><span class="line">	<span class="comment">// * 简易多线程单任务队列线程池，使用SafeQueue线程安全队列。</span></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">SimplePool</span> &#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="keyword">explicit</span> <span class="title">SimplePool</span><span class="params">(<span class="keyword">size_t</span> threads = std::thread::hardware_concurrency())</span> </span>&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; threads; ++i) &#123;</span><br><span class="line">				workers_.<span class="built_in">emplace_back</span>([<span class="keyword">this</span>]() &#123;</span><br><span class="line">					<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">						std::function&lt;<span class="built_in"><span class="keyword">void</span></span>()&gt; task;</span><br><span class="line">						<span class="keyword">if</span> (!queue_.<span class="built_in">pop</span>(task))</span><br><span class="line">							<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">						<span class="keyword">if</span> (task)</span><br><span class="line">							<span class="built_in">task</span>();</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(WorkItem item)</span> </span>&#123;</span><br><span class="line">			queue_.<span class="built_in">push</span>(std::<span class="built_in">move</span>(item));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		~<span class="built_in">SimplePool</span>() &#123;</span><br><span class="line">			queue_.<span class="built_in">stop</span>();</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; thd: workers_)</span><br><span class="line">				thd.<span class="built_in">join</span>();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		SafeQueue&lt;WorkItem&gt; queue_;</span><br><span class="line">		std::vector&lt;std::thread&gt; workers_;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">&#125;;<span class="comment">// namespace Diana</span></span><br></pre></td></tr></table></figure>

<p>入队接口enqueue()史诗级简化。当然，这种简化也带来一些不便：使用std::function&lt;void()&gt;作为参数，不想前面的那个传入可调用对象及其参数，在实际使用时需要用户进行包装，这个会在后面功能测试的时候讲。</p>
<hr>
<h2 id="多任务队列线程池"><a href="#多任务队列线程池" class="headerlink" title="多任务队列线程池"></a>多任务队列线程池</h2><p>其实多任务队列的线程池的设计思路也是很简单的：每个线程对应着一个自己的任务队列。因为前面对任务队列进行了抽取重构，编写一个多任务队列的线程池也非常简单。</p>
<p>我们对原本单任务队列的线程池的入队接口进行改造：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">schedule_by_id</span><span class="params">(WorkItem fn, <span class="keyword">size_t</span> id = <span class="number">-1</span>)</span></span></span><br></pre></td></tr></table></figure>

<p>当提交一个任务时，我们可以指定它放到任意一个线程的任务队列中。在用户没有指定任务队列时，就为该任务随机选择一个线程所对应的任务队列。</p>
<h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><p>简单多任务队列线程池实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Diana &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">using</span> WorkItem = std::function&lt;<span class="built_in"><span class="keyword">void</span></span>()&gt;;</span><br><span class="line">	<span class="comment">// * 简易多线程多任务队列线程池，使用SafeQueue线程安全队列。</span></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">MultiplePool</span> &#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="keyword">explicit</span> <span class="title">MultiplePool</span><span class="params">(<span class="keyword">size_t</span> thread_num = std::thread::hardware_concurrency())</span></span></span><br><span class="line"><span class="function">			: queues_(thread_num),</span></span><br><span class="line"><span class="function">			  thread_num_(thread_num) &#123;</span></span><br><span class="line">			<span class="keyword">auto</span> worker = [<span class="keyword">this</span>](<span class="keyword">size_t</span> id) &#123;</span><br><span class="line">				<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">					WorkItem task&#123;&#125;;</span><br><span class="line">					<span class="keyword">if</span> (!queues_[id].<span class="built_in">pop</span>(task))</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">					<span class="keyword">if</span> (task)</span><br><span class="line">						<span class="built_in">task</span>();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;;</span><br><span class="line"></span><br><span class="line">			workers_.<span class="built_in">reserve</span>(thread_num_);</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; thread_num_; ++i) &#123;</span><br><span class="line">				workers_.<span class="built_in">emplace_back</span>(worker, i);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">int</span> <span class="title">schedule_by_id</span><span class="params">(WorkItem fn, <span class="keyword">size_t</span> id = <span class="number">-1</span>)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (fn == <span class="literal">nullptr</span>)</span><br><span class="line">				<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (id == <span class="number">-1</span>) &#123;</span><br><span class="line">				id = <span class="built_in">rand</span>() % thread_num_;<span class="comment">// 随机插入到一个线程的任务队列中</span></span><br><span class="line">				queues_[id].<span class="built_in">push</span>(std::<span class="built_in">move</span>(fn));</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="built_in">assert</span>(id &lt; thread_num_);<span class="comment">// 插入指定线程的任务队列</span></span><br><span class="line">				queues_[id].<span class="built_in">push</span>(std::<span class="built_in">move</span>(fn));</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		~<span class="built_in">MultiplePool</span>() &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; queue: queues_) &#123;</span><br><span class="line">				queue.<span class="built_in">stop</span>();<span class="comment">// 停止每一个任务队列</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; worker: workers_) &#123;</span><br><span class="line">				worker.<span class="built_in">join</span>();<span class="comment">// 阻塞，等待每个线程执行结束</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		std::vector&lt;Diana::SafeQueue&lt;WorkItem&gt;&gt; queues_;<span class="comment">// 每个线程对应一个任务队列</span></span><br><span class="line">		<span class="keyword">size_t</span> thread_num_;</span><br><span class="line">		std::vector&lt;std::thread&gt; workers_;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">&#125;;<span class="comment">// namespace Diana</span></span><br></pre></td></tr></table></figure>

<p>需要注意的细节也在代码注释中写明了。</p>
<hr>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>我们编写如下测试代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_thread_pool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;test_thread_pool()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	Diana::ThreadPool threadPool;</span><br><span class="line">	threadPool.<span class="built_in">enqueue</span>([] &#123; std::cout &lt;&lt; <span class="string">&quot;hello\n&quot;</span>; &#125;);</span><br><span class="line">	<span class="keyword">auto</span> future = threadPool.<span class="built_in">enqueue</span>([](std::string str) &#123; <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span> + str; &#125;, <span class="string">&quot;world&quot;</span>);</span><br><span class="line">	std::cout &lt;&lt; future.<span class="built_in">get</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">funA</span><span class="params">(std::string str)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;hello&quot;</span> + str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_simple_thread_pool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;test_simple_thread_pool()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	Diana::SimplePool threadPool;</span><br><span class="line">	threadPool.<span class="built_in">enqueue</span>([] &#123; std::cout &lt;&lt; <span class="string">&quot;hello\n&quot;</span>; &#125;);</span><br><span class="line">	<span class="comment">// * 此处必须使用shared_ptr进行包装，</span></span><br><span class="line">	<span class="comment">// * 否则在std::function&lt;void()&gt;中会尝试生成std::packaged_task的拷贝构造函数，</span></span><br><span class="line">	<span class="comment">// ! std::packaged_task禁止拷贝操作</span></span><br><span class="line">	<span class="keyword">auto</span> task = std::make_shared&lt;std::packaged_task&lt;std::<span class="built_in">string</span>()&gt;&gt;(std::<span class="built_in">bind</span>(funA, <span class="string">&quot;world&quot;</span>));</span><br><span class="line">	std::future&lt;std::string&gt; res = task-&gt;<span class="built_in">get_future</span>();</span><br><span class="line">	threadPool.<span class="built_in">enqueue</span>([task = std::<span class="built_in">move</span>(task)] &#123; (*task)(); &#125;);</span><br><span class="line">    <span class="comment">// ! 以下实现方法是错误的</span></span><br><span class="line">	<span class="comment">//	auto task = std::packaged_task&lt;std::string()&gt;(std::bind(funA, &quot;world&quot;));</span></span><br><span class="line">	<span class="comment">//	std::future&lt;std::string&gt; res = task.get_future();</span></span><br><span class="line">	<span class="comment">//	threadPool.enqueue(std::move(task));</span></span><br><span class="line">	std::cout &lt;&lt; res.<span class="built_in">get</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_multiple_thread_pool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;test_multiple_thread_pool&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	Diana::MultiplePool threadPool;</span><br><span class="line">	threadPool.<span class="built_in">schedule_by_id</span>([] &#123; std::cout &lt;&lt; <span class="string">&quot;hello\n&quot;</span>; &#125;);</span><br><span class="line">	<span class="keyword">auto</span> task = std::make_shared&lt;std::packaged_task&lt;std::<span class="built_in">string</span>()&gt;&gt;(std::<span class="built_in">bind</span>(funA, <span class="string">&quot;world&quot;</span>));</span><br><span class="line">	std::future&lt;std::string&gt; res = task-&gt;<span class="built_in">get_future</span>();</span><br><span class="line">	threadPool.<span class="built_in">schedule_by_id</span>([task = std::<span class="built_in">move</span>(task)] &#123; (*task)(); &#125;);</span><br><span class="line">	std::cout &lt;&lt; res.<span class="built_in">get</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们分别为三个版本的线程池（未重构的单任务队列线程池+重构后的单任务队列线程池+多任务队列线程池）编写了接口测试。</p>
<p>未重构的单任务队列线程池，因为接口简单，没有什么需要特别注意的东西。</p>
<p>重构后的单任务队列线程池和多任务队列线程池，可以看到我写了一些注释，还注释了一些错误的任务提交方式。还记得前面重构时，我们把提交任务的接口参数改成了std::function&lt;void()&gt;嘛？为了配合这个参数格式，以及利用future进行异步编程，我们需要对异步获取结果的方法进行包装（之前的版本在入队接口中为用户做了这些事情）。比较需要注意的一点是我们需要用一个shared_ptr智能指针来对packaged_task进行包装，这是因为在std::function&lt;void()&gt;中会尝试生成std::packaged_task的拷贝构造函数，而std::packaged_task是禁止进行拷贝操作的，这会引起编译器的报错（感谢群里的大佬帮我整明白了这个事情）。</p>
<blockquote>
<p><a href="https://zh.cppreference.com/w/cpp/utility/functional/function">cppreference-std::funtion：</a></p>
<p>类模板 <code>std::function</code> 是通用多态函数包装器。 <code>std::function</code> 的实例能存储、复制及调用任何<a href="https://zh.cppreference.com/w/cpp/named_req/CopyConstructible"><em>可复制构造</em> <em>(CopyConstructible)</em> </a>的<a href="https://zh.cppreference.com/w/cpp/named_req/Callable"><em>可调用</em> <em>(Callable)</em> </a><em>目标</em>——函数、 <a href="https://zh.cppreference.com/w/cpp/language/lambda">lambda 表达式</a>、 <a href="https://zh.cppreference.com/w/cpp/utility/functional/bind">bind 表达式</a>或其他函数对象，还有指向成员函数指针和指向数据成员指针。</p>
<p>存储的可调用对象被称为 <code>std::function</code> 的<em>目标</em>。若 <code>std::function</code> 不含目标，则称它为<em>空</em>。调用<em>空</em> <code>std::function</code> 的<em>目标</em>导致抛出 <a href="https://zh.cppreference.com/w/cpp/utility/functional/bad_function_call">std::bad_function_call</a> 异常。</p>
<p><code>std::function</code> 满足<a href="https://zh.cppreference.com/w/cpp/named_req/CopyConstructible"><em>可复制构造</em> <em>(CopyConstructible)</em> </a>和<a href="https://zh.cppreference.com/w/cpp/named_req/CopyAssignable"><em>可复制赋值</em> <em>(CopyAssignable)</em> </a>。</p>
</blockquote>
<blockquote>
<p><a href="https://zh.cppreference.com/w/cpp/thread/packaged_task/packaged_task">cppreference-std::packaged_task构造函数：</a></p>
<p>构造新的 <code>std::packaged_task</code> 对象。</p>
<ol>
<li><p>…</p>
</li>
<li><p>复制构造函数被删除， <code>std::packaged_task</code> 仅可移动。</p>
</li>
<li><p>…</p>
</li>
</ol>
</blockquote>
<h2 id="性能比较"><a href="#性能比较" class="headerlink" title="性能比较"></a>性能比较</h2><p>根据性能测试，重构和未重构版本的单任务队列线程池有着细微的性能差别（未重构版本略优）。而在数据量足够大的情况下，因为多任务队列的设计，多任务队列线程池性能甚至达到了单任务队列线程池的两倍。</p>
<h2 id="写在后面"><a href="#写在后面" class="headerlink" title="写在后面"></a>写在后面</h2><p>后面大概还会继续研究一下work steal线程池，也会写篇学习心得=。=</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol>
<li><a href="http://www.purecpp.org/detail?id=2260">Purecpp：聊聊线程池（一）</a></li>
<li><a href="http://www.purecpp.org/detail?id=2261">Purecpp：聊聊线程池（二）</a></li>
</ol>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>C++11</tag>
        <tag>C++14</tag>
        <tag>C++17</tag>
        <tag>C++并发</tag>
        <tag>学习心得</tag>
      </tags>
  </entry>
  <entry>
    <title>C++日期与时间编程（C++11-C++17）</title>
    <url>/2021/05/19/C++%E6%97%A5%E6%9C%9F%E4%B8%8E%E6%97%B6%E9%97%B4%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="C-日期与时间编程（C-11-C-17）"><a href="#C-日期与时间编程（C-11-C-17）" class="headerlink" title="C++日期与时间编程（C++11-C++17）"></a>C++日期与时间编程（C++11-C++17）</h1><h2 id="0x00-导言"><a href="#0x00-导言" class="headerlink" title="0x00 导言"></a>0x00 导言</h2><p>日期和时间是在编程中常常接触到的东西，而C++也为程序员提供了强（复）大（杂）的日期和时间编程的相关支持。在C++20标准中，C++的<code>chrono</code>库继C++11标准后也迎来了空前绝后大更新，但本文讨论的重点主要集中在C++11至C++17标准中日期和时间相关的内容，C++20标准中的<code>chrono</code>新东西完全可以另开一个坑。</p>
<p>在翻了N篇cppreference标准、chrome爽吃我800Mb的内存之后，我果断决定把这次的学习心得记下来，以防以后全部忘光光（实在太多了.jpg）。本片学习心得纯新手向，求大佬轻喷。</p>
<span id="more"></span>

<h2 id="0x01-概论"><a href="#0x01-概论" class="headerlink" title="0x01 概论"></a>0x01 概论</h2><p>先给两个例子：</p>
<ol>
<li>获取当前时间</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 实现1 **/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">time_t</span> now = <span class="built_in">time</span>(<span class="literal">nullptr</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Now is: &quot;</span> &lt;&lt; <span class="built_in">ctime</span>(&amp;now);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 实现2 **/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> now = chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line">	<span class="keyword">time_t</span> time = chrono::system_clock::<span class="built_in">to_time_t</span>(now);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Now is: &quot;</span> &lt;&lt; <span class="built_in">ctime</span>(&amp;time) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>计算时间差</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 实现1 **/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">time_t</span> time1 = <span class="built_in">time</span>(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000000</span>; i++) &#123;</span><br><span class="line">  		sum += <span class="built_in">sqrt</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">time_t</span> time2 = <span class="built_in">time</span>(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">double</span> time_diff = <span class="built_in">difftime</span>(time2, time1);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;time1: &quot;</span> &lt;&lt; time1 &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;time2: &quot;</span> &lt;&lt; time2 &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;time_diff: &quot;</span> &lt;&lt; time_diff &lt;&lt; <span class="string">&quot;s&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 实现2 **/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> start = chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line">	<span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000000</span>; i++) &#123;</span><br><span class="line">    	sum += <span class="built_in">sqrt</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">auto</span> end = chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">auto</span> time_diff = end - start;</span><br><span class="line">	<span class="keyword">auto</span> duration = chrono::duration_cast&lt;chrono::seconds&gt;(time_diff);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Operation cost : &quot;</span> &lt;&lt; duration.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot;s&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上文的两个要求都分别给出了两种实现方法，那接下来要说的事情已经显而易见了：</p>
<p><strong>C++给出了两类日期时间API，分别是：</strong></p>
<ul>
<li>C-Style日期时间库，主要位于<code>&lt;ctime&gt;</code>头文件（原C语言<code>&lt;time.h&gt;</code>头文件的C++版本）中。</li>
<li><code>chrono</code>库：C++11新增的API。</li>
</ul>
<p>在C++11引入<code>chrono</code>库之前，C++程序员只能使用C-Style的日期时间库。然而，C-Style日期时间库有着鲜明的缺点：<strong>精度只有秒级别</strong>（当时），这对于对时间有着高精度要求的程序来说是完全不够用的。而C++11引入的<code>chrono</code>库解决了这个问题，它极大地扩展了对精度的支持。当然，针对习惯C-Style日期时间库的程序员来说，C++17也进行了精度的扩充，详情请见下文。</p>
<p>本文也会分为C-Style和<code>chrono</code>两个板块进行讲解。</p>
<h2 id="0x02-必备的知识"><a href="#0x02-必备的知识" class="headerlink" title="0x02 必备的知识"></a>0x02 必备的知识</h2><p>在正式进入日期时间库的讨论之前，我们应该先复习一下与日期时间相关的必要知识。</p>
<h3 id="UTC时间"><a href="#UTC时间" class="headerlink" title="UTC时间"></a>UTC时间</h3><p><strong>协调世界时</strong>（<strong>C</strong>oordinated <strong>U</strong>niversial <strong>T</strong>ime，简称<strong>UTC</strong>）是最主要的时间标准，其以原子时秒长为基础，在时刻上尽量接近于格林威治标准时间。</p>
<p>协调世界时是世界上调节时钟和时间的主要时间标准，它与0度经线的平太阳时相差不超过1秒。因此UTC时间+8即可获得北京标准时间（UTC+8）。</p>
<h3 id="本地时间"><a href="#本地时间" class="headerlink" title="本地时间"></a>本地时间</h3><p>本地时间与当地的时区相关，例如中国当地时间采用了北京标准时间（UTC+8）.</p>
<h3 id="纪元时间"><a href="#纪元时间" class="headerlink" title="纪元时间"></a>纪元时间</h3><p><strong>纪元时间</strong>（Epoch time）又被称为Unix时间（常用Linux的小伙伴可能会比较熟悉）。它表示1970年1月1日00:00UTC以来所经历的<strong>秒数</strong>（不考虑闰秒）。</p>
<p>例如北京时间2021年5月18日晚上9点07分32秒的纪元时间为：<code>1621372052</code>。</p>
<p>作为一个敏感的CPP程序员，你应该很快就意识到这个大整数在储存会产生很多问题，例如溢出。然而事实正是如此，在一些历史机器上，使用了32位的有符号整数来储存这个时间戳，因此产生在结果就是：在2038-01-19 03:14:07这一刻，该值会溢出。</p>
<p>另外，如果你对为什么选1970-1-1日零点做位纪元时间起点，可以看一下这个帖子：</p>
<p><a href="https://stackoverflow.com/questions/1090869/why-is-1-1-1970-the-epoch-time">Why is 1/1/1970 the “epoch time”?</a></p>
<h2 id="0x03-C-Style-日期时间库"><a href="#0x03-C-Style-日期时间库" class="headerlink" title="0x03 C-Style 日期时间库"></a>0x03 C-Style 日期时间库</h2><p>C-Style日期时间库主要位于<code>&lt;ctime&gt;</code>头文件中，下面给出头文件中包含的常用的<em>类型</em>和<em>函数</em>。</p>
<h3 id="常用类型与函数"><a href="#常用类型与函数" class="headerlink" title="常用类型与函数"></a>常用类型与函数</h3><p><strong>类型</strong></p>
<table>
<thead>
<tr>
<th>类型名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>clock_t</td>
<td>进程运行时间</td>
</tr>
<tr>
<td>size_t</td>
<td>sizeof运算符返回的无符号整数类型</td>
</tr>
<tr>
<td>time_t</td>
<td>从纪元起的时间类型</td>
</tr>
<tr>
<td>tm</td>
<td>日历时间类型</td>
</tr>
<tr>
<td>timespec*(C++17)*</td>
<td>以秒和纳秒表示的时间（C++17）</td>
</tr>
</tbody></table>
<p><strong>函数</strong></p>
<table>
<thead>
<tr>
<th>函数名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>std::clock_t clock()</td>
<td>返回自程序启动时起的原始处理器时钟时间</td>
</tr>
<tr>
<td>std::time_t time(std::time_t* arg)</td>
<td>返回自纪元起计的系统当前时间</td>
</tr>
<tr>
<td>double difftime(std::time_t time_end, std::time_t time_beg)</td>
<td>计算时间之间的差</td>
</tr>
<tr>
<td>int timespec_get(std::timespec* ts, int base)<em>(C++17)</em></td>
<td>返回基于给定时间基底的日历时间（C++17）</td>
</tr>
<tr>
<td>char* ctime(const std::time_t* time)</td>
<td>转换 time_t 对象为文本表示</td>
</tr>
<tr>
<td>char* asctime(const std::tm* time_ptr)</td>
<td>转换 tm 对象为文本表示</td>
</tr>
<tr>
<td>std::size_t strftime(char* str, std::size_t count, const char* format, const std::tm* time)</td>
<td>转换 tm 对象到自定义的文本表示</td>
</tr>
<tr>
<td>std::size_t wcsftime( wchar_t* str, std::size_t count, const wchar_t* format, const std::tm* time)</td>
<td>转换 tm 对象为定制的宽字符串文本表示</td>
</tr>
<tr>
<td>std::tm* gmtime(const std::time_t* time)</td>
<td>将time_t转换成UTC表示的时间</td>
</tr>
<tr>
<td>std::tm* localtime(const std::time_t *time)</td>
<td>将time_t转换成本地时间</td>
</tr>
<tr>
<td>std::time_t mktime(std::tm* time)</td>
<td>将tm格式的时间转换成time_t表示的时间</td>
</tr>
</tbody></table>
<p>函数和数据类型又多又杂有木有，刚开始接触的时候很容易弄混且不太容易记住，这里借鉴一下大佬的一张图来理解记忆：</p>
<p><img src="C:\Users\Skykey\Desktop\ctime.png"></p>
<p>这幅图中，以数据类型为中心，带方向的实心箭头表示该函数返回相应类型的结果。</p>
<ul>
<li>clock函数比较特别，它返回进程运行的时间，因而是相对独立的。</li>
<li>time_t描述纪元时间（精确到秒），使用time函数获得。</li>
<li>timespec类型在time_t的基础上增加了纳秒的精度，需要通过timespec_get函数获取。该类型与函数为C++17新增内容。</li>
<li>tm是日历类型，包含了年月日等信息。可以通过gmtime，localtime和mktime函数进行time_t和tm类型的相互转化。</li>
<li>gmtime和localtime两个函数存在时区差异相关问题。</li>
<li>time_t和tm结构都可以用字符串格式输出。ctime和asctime输出的格式是固定的，如果需要自定义格式，需要使用strftime或者wcsftime函数。</li>
</ul>
<h3 id="计算进程运行的时间"><a href="#计算进程运行的时间" class="headerlink" title="计算进程运行的时间"></a>计算进程运行的时间</h3><p>clock函数会返回从关联到进程开始执行的实现定义时期的起，进程所用的粗略处理器时间。将此值除以<code>CLOCKS_PER_SEC</code>常量可转换为秒。</p>
<p>这里给出cppreference上clock函数示例的简化版：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;threads.h&gt;</span> <span class="comment">// POSIX 中的 pthread.h</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 函数 f() 做一些耗时的工作</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">void</span>* thr_data)</span> <span class="comment">// POSIX 中返回 void*</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">double</span> d = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n=<span class="number">0</span>; n&lt;<span class="number">10000</span>; ++n)</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> m=<span class="number">0</span>; m&lt;<span class="number">10000</span>; ++m)</span><br><span class="line">           d += d*n*m;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">clock_t</span> t1 = <span class="built_in">clock</span>();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">thrd_t</span> thr1, thr2;  <span class="comment">// C11 ；POSIX 中用 pthread_t</span></span><br><span class="line">    <span class="built_in">thrd_create</span>(&amp;thr1, f, <span class="literal">NULL</span>); <span class="comment">// C11 ； POSIX 中用 pthread_create</span></span><br><span class="line">    <span class="built_in">thrd_create</span>(&amp;thr2, f, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">thrd_join</span>(thr1, <span class="literal">NULL</span>); <span class="comment">// C11 ； POSIX 中用 pthread_join</span></span><br><span class="line">    <span class="built_in">thrd_join</span>(thr2, <span class="literal">NULL</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">clock_t</span> t2 = <span class="built_in">clock</span>();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">double</span> dur = <span class="number">1000.0</span>*(t2-t1)/CLOCKS_PER_SEC;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;CPU time used (per clock(): %.2f ms\n&quot;</span>, dur);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可能的输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CPU time used (per clock(): 1580.00 ms</span><br></pre></td></tr></table></figure>

<p>我们应当注意，clock时间或许会快于或慢于挂钟时间，这取决于操作系统给予程序的执行资源。在单处理器的情况下，若CPU为其他进程所共享，clock可能慢于挂钟，若当前进程为多线程，而有更多资源可用，clock时间可能会快于挂钟。在多处理器情况下，若进程使用了多线程，那么clock时间可能要慢于挂钟。</p>
<h3 id="获取纪元时间"><a href="#获取纪元时间" class="headerlink" title="获取纪元时间"></a>获取纪元时间</h3><p>使用time函数可以获取储存于time_t类型返回值里的纪元时间。</p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">time_t</span> epoch_time = <span class="built_in">time</span>(<span class="literal">nullptr</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Epoch time: &quot;</span> &lt;&lt; epoch_time &lt;&lt;endl; </span><br></pre></td></tr></table></figure>

<p>在北京时间2021年5月18日晚上9点07分32秒输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Epoch time: 1621372052</span><br></pre></td></tr></table></figure>



<h3 id="计算时间差"><a href="#计算时间差" class="headerlink" title="计算时间差"></a>计算时间差</h3><p>在一些情况下我们需要计算操作所花费的<strong>时间长度</strong>。可以看出，time_t结构中储存的是<strong>时间点</strong>，而通过常识我们得知：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">时间差（时间长度） = 时间点 - 时间点</span><br></pre></td></tr></table></figure>

<p>在C-Style日期时间库中，我们可以通过difftime函数来计算两个时间点的差。</p>
<p>下面给出cppreference的示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::<span class="keyword">time_t</span> start = std::<span class="built_in">time</span>(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">double</span> d;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 一些耗时操作</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n=<span class="number">0</span>; n&lt;<span class="number">10000</span>; ++n) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> m=<span class="number">0</span>; m&lt;<span class="number">100000</span>; ++m) &#123;</span><br><span class="line">           d += d*n*m;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Wall time passed: &quot;</span></span><br><span class="line">              &lt;&lt; std::<span class="built_in">difftime</span>(std::<span class="built_in">time</span>(<span class="literal">NULL</span>), start) &lt;&lt; <span class="string">&quot; s.\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可能的输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Wall time passed: 7 s.</span><br></pre></td></tr></table></figure>



<h3 id="UTC时间与本地时间"><a href="#UTC时间与本地时间" class="headerlink" title="UTC时间与本地时间"></a>UTC时间与本地时间</h3><p>在C-Style日期时间库中，我们可以使用gmtime将std::time_t的纪元时间转换为UTC时间，使用localtime将纪元时间转换为本地时区所代表的日历时间。</p>
<p>gmtime与localtime返回值的类型为tm结构，即日历时间的结构描述，其结构如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tm</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> tm_sec;</span><br><span class="line">  <span class="keyword">int</span> tm_min</span><br><span class="line">  <span class="keyword">int</span> tm_hour;</span><br><span class="line">  <span class="keyword">int</span> tm_mday;</span><br><span class="line">  <span class="keyword">int</span> tm_mon;</span><br><span class="line">  <span class="keyword">int</span> tm_year;</span><br><span class="line">  <span class="keyword">int</span> tm_wday;</span><br><span class="line">  <span class="keyword">int</span> tm_yday;</span><br><span class="line">  <span class="keyword">int</span> tm_isdst;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>有两点我们需要注意：</p>
<ul>
<li>tm_mon表示的范围为[0, 11]。转换成日常使用的月份表示需要+1。</li>
<li>tm_year表示的是自1900年之后所过的年份数。转换成日常使用的年份表示需要+1900。</li>
</ul>
<p>下面给出示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">time_t</span> now = <span class="built_in">time</span>(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">tm* gm_time = <span class="built_in">gmtime</span>(&amp;now);</span><br><span class="line">tm* local_time = <span class="built_in">localtime</span>(&amp;now);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;gmtime: &quot;</span> &lt;&lt; <span class="built_in">asctime</span>(gm_time);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;local_time: &quot;</span> &lt;&lt; <span class="built_in">asctime</span>(local_time);</span><br></pre></td></tr></table></figure>

<p>输出如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">gmtime: Tue May <span class="number">18</span> <span class="number">21</span>:<span class="number">36</span>:<span class="number">48</span> <span class="number">2021</span></span><br><span class="line">local_time: Tue May <span class="number">18</span> <span class="number">21</span>:<span class="number">36</span>:<span class="number">48</span> <span class="number">2021</span></span><br></pre></td></tr></table></figure>



<h3 id="输出时间和日期"><a href="#输出时间和日期" class="headerlink" title="输出时间和日期"></a>输出时间和日期</h3><p>获取了时间，我们自然想要将时间以字符串的形式打印出来。此时可以使用ctime函数。</p>
<p>应注意的是，ctime函数打印的格式是固定的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Www Mmm dd hh:mm:ss yyyy\n</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">time_t</span> now = <span class="built_in">time</span>(<span class="literal">nullptr</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Now is: &quot;</span> &lt;&lt; <span class="built_in">ctime</span>(&amp;now);</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Now is: Tue May 18 21:39:46 2021</span><br></pre></td></tr></table></figure>

<p>而tm储存的日期时间结构，我们也可以使用asctime函数将其转换为字符串格式。</p>
<p>然而，ctime和asctime函数其输出的格式都是固定的，在有格式要求的情况下，我们通常有两种做法：</p>
<ol>
<li><p>拆分tm结构体的字段：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">time_t now = time(nullptr);</span><br><span class="line">tm* t = localtime(&amp;now);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &quot;Now is: &quot; &lt;&lt; t-&gt;tm_year + 1900 &lt;&lt; &quot;/&quot; &lt;&lt; t-&gt;tm_mon + 1&lt;&lt; &quot;/&quot; &lt;&lt; t-&gt;tm_mday &lt;&lt; &quot; &quot;;</span><br><span class="line">cout &lt;&lt; t-&gt;tm_hour &lt;&lt; &quot;:&quot; &lt;&lt; t-&gt;tm_min &lt;&lt; &quot;:&quot; &lt;&lt; t-&gt;tm_sec &lt;&lt; endl;</span><br></pre></td></tr></table></figure></li>
<li><p>使用strftime或者wcsftime函数来指定格式输出。函数格式可以参考以下文档：</p>
<p><a href="https://zh.cppreference.com/w/cpp/chrono/c/strftime">https://zh.cppreference.com/w/cpp/chrono/c/strftime</a></p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;locale&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::locale::<span class="built_in">global</span>(std::<span class="built_in">locale</span>(<span class="string">&quot;ja_JP.utf8&quot;</span>));</span><br><span class="line">    std::<span class="keyword">time_t</span> t = std::<span class="built_in">time</span>(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">char</span> mbstr[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">if</span> (std::<span class="built_in">strftime</span>(mbstr, <span class="built_in"><span class="keyword">sizeof</span></span>(mbstr), <span class="string">&quot;%A %c&quot;</span>, std::<span class="built_in">localtime</span>(&amp;t))) &#123;</span><br><span class="line">        std::cout &lt;&lt; mbstr &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">火曜日 2011年12月27日 17時39分03秒</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="C-17新内容timespec，迈向纳秒精度"><a href="#C-17新内容timespec，迈向纳秒精度" class="headerlink" title="C++17新内容timespec，迈向纳秒精度"></a>C++17新内容timespec，迈向纳秒精度</h3><p>纪元时间的精度只有秒，这在很多时候是不够用的。为了解决这个问题，C++17增加timespec类型，提供了纳秒级别的精度。</p>
<p>一些熟悉C语言的朋友可能会立即满头问号：timespec不是在C11（注意看，是C11，不是CPP11）就已经引入了么？</p>
<p>但事实的确如此，严格的C++的C-Style日期时间库，在C++17标准才正式引入timespec类型。</p>
<p>timespec类型结构如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> &#123;</span></span><br><span class="line">  std::<span class="keyword">time_t</span> tv_sec;</span><br><span class="line">  <span class="keyword">long</span> tv_nsec;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中tv_nsec成员保存了纳秒数。</p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">timespec ts;</span><br><span class="line"><span class="built_in">timespec_get</span>(&amp;ts, TIME_UTC);</span><br><span class="line"><span class="keyword">char</span> buff[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">strftime</span>(buff, <span class="keyword">sizeof</span> buff, <span class="string">&quot;%D %T&quot;</span>, std::<span class="built_in">gmtime</span>(&amp;ts.tv_sec));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Current time: %s.%09ld UTC\n&quot;</span>, buff, ts.tv_nsec);</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Current time: <span class="number">05</span>/<span class="number">18</span>/<span class="number">21</span> <span class="number">13</span>:<span class="number">50</span>:<span class="number">58.667861100</span> UTC</span><br></pre></td></tr></table></figure>



<p>C-Style日期时间库至此已基本结束，接下来讲解C++11起新增的chrono库。</p>
<hr>
<h2 id="0x04-chrono库"><a href="#0x04-chrono库" class="headerlink" title="0x04 chrono库"></a>0x04 chrono库</h2><p>chrono是以各种精度跟踪时间的类型的灵活汇集。chrono库定义三种主要类型以及工具函数和常用的typedef：</p>
<ul>
<li>时钟</li>
<li>时长</li>
<li>时间点</li>
</ul>
<h3 id="时钟"><a href="#时钟" class="headerlink" title="时钟"></a>时钟</h3><p>C++11的chrono库主要包含了三种类型的时钟：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>system_clock</td>
<td>来自系统范畴实时时钟的挂钟时间</td>
</tr>
<tr>
<td>steady_clock</td>
<td>决不会调整的单调时钟</td>
</tr>
<tr>
<td>high_resolution_clock</td>
<td>拥有可用的最短嘀嗒周期的时钟</td>
</tr>
</tbody></table>
<p>system_clock来源是系统时钟。然而在大多数系统上，系统时间是可以在任何时候被调节的。所以如果用来计算两个时间点的时间差，这并不是一个好的选择。</p>
<p>steady_clock是一个单调时钟。此时钟的时间点无法减少，因为物理十几件向前移动。因而steady_clock是度量间隔的最适宜的选择。</p>
<p>high_resolution_clock表示实现提供的拥有最小计次周期的时钟。它可以是system_clock或steady_clock的别名，或者第三个独立时钟。</p>
<p>对于high_resolution_clock，cppreference给出了以下需要我们注意的地方：</p>
<p><a href="https://zh.cppreference.com/w/cpp/chrono/high_resolution_clock">https://zh.cppreference.com/w/cpp/chrono/high_resolution_clock</a></p>
<blockquote>
<p><code>high_resolution_clock</code> 在不同标准库实现之间实现不一致，而应该避免使用它。通常它只是 <a href="https://zh.cppreference.com/w/cpp/chrono/steady_clock">std::chrono::steady_clock</a> 或 <a href="https://zh.cppreference.com/w/cpp/chrono/system_clock">std::chrono::system_clock</a> 的别名，但实际是哪个取决于库或配置。它是 <code>system_clock</code> 时不是单调的（即时间能后退）。例如对于 gcc 的 libstdc++ 它是 <code>system_clock</code> ，对于 MSVC 它是 <code>steady_clock</code> ，而对于 clang 的 libc++ 它取决于配置。</p>
<p>通常用户应该直接使用 <a href="https://zh.cppreference.com/w/cpp/chrono/steady_clock">std::chrono::steady_clock</a> 或 <a href="https://zh.cppreference.com/w/cpp/chrono/system_clock">std::chrono::system_clock</a> 代替 <code>std::chrono::high_resolution_clock</code> ：对时长度量使用 <code>steady_clock</code> ，对壁钟时间使用 <code>system_clock</code> 。</p>
</blockquote>
<p>对于这三个时钟类，有着以下共同的成员：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>now()</td>
<td>静态成员函数，返回当前时间，类型为clock::time_point</td>
</tr>
<tr>
<td>time_point</td>
<td>成员类型，当前时钟的时间点类型。</td>
</tr>
<tr>
<td>duration</td>
<td>成员类型，时钟的时长类型。</td>
</tr>
<tr>
<td>rep</td>
<td>成员类型，时钟的tick类型，等同于clock::duration::rep</td>
</tr>
<tr>
<td>period</td>
<td>成员类型，时钟的单位，等同于clock::duration::period</td>
</tr>
<tr>
<td>is_steady</td>
<td>静态成员类型：是否是稳定时钟，对于steady_clock来说该值一定是true</td>
</tr>
</tbody></table>
<p>每个时钟类都有着一个静态成员函数<code>new()</code>来获取当前时间。该函数的返回类型则是由该时钟类的time_point描述，例如<code>std::chrono::time_point&lt;std::chrono::system_clock&gt;</code>或者<code>std::chrono::time_point&lt;std::chrono::steady_clock&gt;</code>。我们可以使用auto关键字来简写（auto是个好文明）。</p>
<p>阅读文档，我们不难发现system_clock有着与另外两个clock所不具有的特性：它是唯一有能力映射其时间点到C-Style时间的C++时钟。system_clock提供了两个静态成员函数来与std::time_t进行互相转换：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>to_time_t</td>
<td>转换系统时钟时间点为 std::time_t</td>
</tr>
<tr>
<td>from_time_t</td>
<td>转换 std::time_t 到系统时钟时间点</td>
</tr>
</tbody></table>
<p>为了方便理解和记忆，我们也用一副图来描述几种时间类型的转换：</p>
<p><img src="C:\Users\Skykey\Desktop\conversion.png"></p>
<h3 id="时长"><a href="#时长" class="headerlink" title="时长"></a>时长</h3><p>人类对精度的要求永无止境。C-Style日期时间库为了提供对纳秒的精度，增加了timespec类型及相关的函数。那如果以后对更高精度的需求越来越高，C++标准库还要不断增加更多的类型和配套函数吗？这明显是一个不合理的设计。因而C++标准提出了一个新的解决思路，而这个思路涉及到了C++11引入的一个新的头文件和类型：ratio。</p>
<h4 id="ratio"><a href="#ratio" class="headerlink" title="ratio"></a>ratio</h4><p><code>std::ratio</code>定义在<code>&lt;ratio&gt;</code>文件中，提供了编译期的比例计算功能。</p>
<p><code>std::ratio</code>的定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;</span><br><span class="line">    std::<span class="keyword">intmax_t</span> Num,</span><br><span class="line">    std::<span class="keyword">intmax_t</span> Denom = <span class="number">1</span></span><br><span class="line">&gt; class ratio;</span><br></pre></td></tr></table></figure>

<p>类成员Num即为分子，类成员Denom即为分母。我们可以直接通过调用类成员来获取相关值。</p>
<p><code>&lt;ratio&gt;</code>头文件还包含了：ratio_add，ratio_subtract，ratio_multiply，ratio_divide来完成分数的加减乘除四则运算。</p>
<p>例如，想要计算5/7 + 59/1023，我们可以这样写：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ratio_add&lt;ratio&lt;<span class="number">5</span>, <span class="number">7</span>&gt;, ratio&lt;<span class="number">59</span>, <span class="number">1023</span>&gt;&gt; result;</span><br><span class="line"><span class="keyword">double</span> value = ((<span class="keyword">double</span>) result.num) / result.den;</span><br><span class="line">cout &lt;&lt; result.num &lt;&lt; <span class="string">&quot;/&quot;</span> &lt;&lt; result.den &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; value &lt;&lt; endl;</span><br></pre></td></tr></table></figure>



<p>对于编译期有理数算数的相关内容，可以在这篇文档中找到更多信息：</p>
<p><a href="https://zh.cppreference.com/w/cpp/numeric/ratio">https://zh.cppreference.com/w/cpp/numeric/ratio</a></p>
<p>有了ratio之后，结合<code>std::chrono::duration</code>，我们便可以表示任意精度的值了。</p>
<p>例如，相对于秒来说，毫秒是1/1,000，微秒是1/1,000,000，纳秒是1/1,000,000,000。通过ratio就可以这样表达：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::ratio&lt;<span class="number">1</span>, <span class="number">1000</span>&gt;       milliseconds;</span><br><span class="line">std::ratio&lt;<span class="number">1</span>, <span class="number">1000000</span>&gt;    microseconds;</span><br><span class="line">std::ratio&lt;<span class="number">1</span>, <span class="number">1000000000</span>&gt; nanoseconds;</span><br></pre></td></tr></table></figure>



<h4 id="时长类型"><a href="#时长类型" class="headerlink" title="时长类型"></a>时长类型</h4><p>类模板 std::chrono::duration 表示时间间隔。有了ratio之后，表达时长就很方便了，下面是chrono库中提供的很常用的几个时长单位：</p>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">定义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">std::chrono::nanoseconds</td>
<td align="left">duration&lt;/*至少 64 位的有符号整数类型*/, std::nano&gt;</td>
</tr>
<tr>
<td align="left">std::chrono::microseconds</td>
<td align="left">duration&lt;/*至少 55 位的有符号整数类型*/, std::micro&gt;</td>
</tr>
<tr>
<td align="left">std::chrono::milliseconds</td>
<td align="left">duration&lt;/*至少 45 位的有符号整数类型*/, std::milli&gt;</td>
</tr>
<tr>
<td align="left">std::chrono::seconds</td>
<td align="left">duration&lt;/*至少 35 位的有符号整数类型*/&gt;</td>
</tr>
<tr>
<td align="left">std::chrono::minutes</td>
<td align="left">duration&lt;/*至少 29 位的有符号整数类型*/, std::ratio&lt;60»</td>
</tr>
<tr>
<td align="left">std::chrono::hours</td>
<td align="left">duration&lt;/*至少 23 位的有符号整数类型*/, std::ratio&lt;3600»</td>
</tr>
</tbody></table>
<p>我们可以调用duration类的<code>count()</code>成员函数来获取具体数值。</p>
<h4 id="时长运算"><a href="#时长运算" class="headerlink" title="时长运算"></a>时长运算</h4><p>时长运算可以直接使用“+”或“-”相加相减。chrono库也提供了几个常用的函数：</p>
<table>
<thead>
<tr>
<th align="left">函数</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">duration_cast</td>
<td align="left">进行时长的转换</td>
</tr>
<tr>
<td align="left">floor(C++17)</td>
<td align="left">以向下取整的方式，将一个时长转换为另一个时长</td>
</tr>
<tr>
<td align="left">ceil(C++17)</td>
<td align="left">以向上取整的方式，将一个时长转换为另一个时长</td>
</tr>
<tr>
<td align="left">round(C++17)</td>
<td align="left">转换时长到另一个时长，就近取整，偶数优先</td>
</tr>
<tr>
<td align="left">abs(C++17)</td>
<td align="left">获取时长的绝对值</td>
</tr>
</tbody></table>
<p>例如：想要知道2个小时零5分钟一共是多少秒，可以这样写：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">chrono::hours <span class="title">two_hours</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="function">chrono::minutes <span class="title">five_minutes</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> duration = two_hours + five_minutes;</span><br><span class="line"><span class="keyword">auto</span> seconds = chrono::duration_cast&lt;chrono::seconds&gt;(duration);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;02:05 is &quot;</span> &lt;&lt; seconds.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot; seconds&quot;</span> &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>我们可以得到：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">02:05 is 7500 seconds</span><br></pre></td></tr></table></figure>

<p>从C++14开始，你甚至可以用字面值来描述常见的时长。这包括：</p>
<ul>
<li><code>h</code>表示小时</li>
<li><code>min</code>表示分钟</li>
<li><code>s</code>表示秒</li>
<li><code>ms</code>表示毫秒</li>
<li><code>us</code>表示微妙</li>
<li><code>ns</code>表示纳秒</li>
</ul>
<p>这些字面值位于<code>std::chrono_literals</code>命名空间下。于是，可以这样表达2个小时以及5分钟：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono_literals;</span><br><span class="line"><span class="keyword">auto</span> two_hours = <span class="number">2</span>h;</span><br><span class="line"><span class="keyword">auto</span> five_minutes = <span class="number">5</span>min;</span><br></pre></td></tr></table></figure>



<h3 id="时间点"><a href="#时间点" class="headerlink" title="时间点"></a>时间点</h3><p>时钟的now函数返回的值就是一个时间点，时间点包含了时钟和时长两个信息。</p>
<p>类模板<code>std::chrono::time_point</code>表示时间中的一个点，定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Clock</span>,</span></span><br><span class="line"><span class="class">    <span class="keyword">class</span> <span class="title">Duration</span> =</span> <span class="keyword">typename</span> Clock::duration</span><br><span class="line">&gt; <span class="class"><span class="keyword">class</span> <span class="title">time_point</span>;</span></span><br></pre></td></tr></table></figure>

<p>与我们的常识一致，时间点具有加法和减法操作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">时间点 + 时长 = 时间点</span><br><span class="line">时间点 - 时间点 = 时长</span><br></pre></td></tr></table></figure>

<p>因而我们可以通过两个时间点相减来计算一个时间间隔，示例如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> start = chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line"><span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000000</span>; i++) &#123;</span><br><span class="line">    sum += <span class="built_in">sqrt</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">auto</span> end = chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> time_diff = end - start;</span><br><span class="line"><span class="keyword">auto</span> duration = chrono::duration_cast&lt;chrono::milliseconds&gt;(time_diff);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Operation cost : &quot;</span> &lt;&lt; duration.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot;ms&quot;</span> &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>两个时间点也存在着比较操作，用于判断一个时间点在另外一个时间点之前还是之后，<code>std::chrono::time_point</code>重载了<code>==</code>，<code>!=</code>，<code>&lt;</code>，<code>&lt;=</code>，<code>&gt;</code>，<code>&gt;=</code>操作符来实现比较操作。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>C++11</tag>
        <tag>C++17</tag>
        <tag>学习心得</tag>
        <tag>日期与时间编程</tag>
      </tags>
  </entry>
  <entry>
    <title>基于C++11实现线程池</title>
    <url>/2021/04/23/cpp11-thread-pool/</url>
    <content><![CDATA[<h1 id="基于C-11实现线程池"><a href="#基于C-11实现线程池" class="headerlink" title="基于C++11实现线程池"></a>基于C++11实现线程池</h1><h2 id="0x00-导入"><a href="#0x00-导入" class="headerlink" title="0x00 导入"></a>0x00 导入</h2><p>前些日子通过阅读几篇博客，大体学习了一下C++的并发编程（主要是多线程、异步部分）。手撸了一个多生产者-多消费者模型之后，最终觉得这也只是小打小闹而已，需要整个硬货。经过一番思考之后，手撸一个线程池貌似是一个非常合适的练习。线程池前前后后一共折腾了四五个小时左右，最令我意外的是——原本以为最难理解的并发部分反而是最简单的部分，线程池实现中大量的CPP11语法糖才是真正影响我理解的部分。经过三四个小时的阅读博文、查阅资料以及向大佬求教之后，我才真正对线程池实现有了比较深入地理解。“纸上得来终觉浅，绝知此事要躬行。”经历这一番折腾后才清楚地认识到了自己对CPP11理解的薄弱，遂写下这篇博客来总结自己对线程池实现以及所涉及到的CPP11语法糖的理解，方便自己以后再次阅读源码时有所考据。</p>
<p>文章大量借鉴、节选了众多参考资料，并结合自己的理解进行讲解。参考资料会在最后列出。</p>
<p>这篇总结会将重心放在C++11的语法糖上，对于C++11的并发编程部分（<code>std::thread</code>, <code>std::future</code>等）将仅进行最简洁最必要的阐述。有关并发编程部分可以移步至几篇大佬总结的比较好的博文中进行补充学习：</p>
<ol>
<li>《C++并发编程（从C++11到C++17）》：<a href="https://paul.pub/cpp-concurrency">https://paul.pub/cpp-concurrency</a></li>
<li>《从pthread转换到std::thread》：<a href="https://segmentfault.com/a/1190000002655852">https://segmentfault.com/a/1190000002655852</a></li>
<li>《货比三家：C++中的task based并发》：<a href="https://segmentfault.com/a/1190000002706259">https://segmentfault.com/a/1190000002706259</a></li>
</ol>
<span id="more"></span>

<h2 id="0x01-逐步实现线程池"><a href="#0x01-逐步实现线程池" class="headerlink" title="0x01 逐步实现线程池"></a>0x01 逐步实现线程池</h2><h3 id="线程池原理"><a href="#线程池原理" class="headerlink" title="线程池原理"></a>线程池原理</h3><p><strong>C++11</strong>加入了线程库，从此告别了标准库不支持并发的历史。然而C++对于多线程的支持还是比较低级，稍微高级一点的用法都需要自己去实现，比如线程池、信号量等。线程池（thread pool）这个东西，一般在面试时的回答都是：“管理一个任务队列，一个线程队列，然后每次去一个任务分配给一个线程去做，循环往复。”这回答貌似没有问题，但是写起程序来的时候就出问题了。</p>
<p>有什么问题？线程池一般是要复用线程，所以如果是取一个task分配给某一个thread，执行完之后再重新分配，在语言层面这是基本不能实现的：C++的thread都是执行一个固定的task函数，执行完之后线程也就结束了。所以该如何实现task和thread的分配呢？</p>
<p><strong>让每一个thread创建后，就去执行调度函数：循环获取task，然后执行。</strong></p>
<p>这个循环该什么时候停止呢？</p>
<p>很简单，<strong>当线程池停止使用时</strong>，循环停止。</p>
<p>这样一来，就保证了thread函数的唯一性，而且复用线程执行task。</p>
<p>总结一下，我们的线程池的主要组成部分有二：</p>
<ul>
<li>任务队列（Task Queue）</li>
<li>线程池（Thread Pool）</li>
</ul>
<p>线程池与任务队列之间的匹配操作，是典型的<em>生产者-消费者</em>模型，本模型使用了两个工具：一个==mutex== + 一个==条件变量==。mutex就是锁，保证任务的添加和移除（获取）的互斥性；一个条件变量保证多个线程获取task的同步性：当任务队列为空时，线程应该等待（阻塞）。</p>
<p>接下来我们就可以逐渐将一块块积木拼成一个完整的简易线程池。</p>
<h3 id="积木1：任务队列（Task-Queue）"><a href="#积木1：任务队列（Task-Queue）" class="headerlink" title="积木1：任务队列（Task Queue）"></a>积木1：任务队列（Task Queue）</h3><p>我们会理所当然地希望任务以发送它相同的顺序来逐个执行，因此队列是最适合的数据结构。</p>
<p>这里我们把任务队列单拿出来，独自为类，方便以后进行各种骚操作。</p>
<p>将任务队列单拿出来之后，我们应考虑一个问题：正如上一节提到的线程池task与thread的分配方法所示，线程池中的线程会持续查询任务队列是否有可用工作。当两个甚至多个线程试图同时执行查询工作时，这会引起难以估计的灾难。因而我们需要对C++的<code>std::queue</code>进行包装，实现一个<strong>线程安全</strong>的<em>SafeQueue</em>。</p>
<p>实现一个线程安全的<em>SafeQueue</em>原理很简单，利用<strong>mutex</strong>来限制并发访问即可。我们可以在<em>SafeQueue</em>类中定义一个<code>std::mutex</code>类型的成员变量，并在相应的操作接口（如入队接口<code>enqueue()</code>）中利用互斥体包装器来管理这个mutex，确保没有其他人正在访问该资源。</p>
<p>下面给出完整的<em>SafeQueue</em>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SafeQueue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::queue&lt;T&gt; m_queue; <span class="comment">//利用模板函数构造队列</span></span><br><span class="line"></span><br><span class="line">    std::mutex m_mutex; <span class="comment">// 访问互斥信号量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SafeQueue</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">SafeQueue</span>(SafeQueue &amp;&amp;other) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">SafeQueue</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="comment">// 返回队列是否为空</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_mutex)</span></span>; <span class="comment">// 互斥信号变量加锁，防止m_queue被改变</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> m_queue.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_mutex)</span></span>; <span class="comment">// 互斥信号变量加锁，防止m_queue被改变</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> m_queue.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 队列添加元素</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(T &amp;t)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">        m_queue.<span class="built_in">emplace</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 队列取出元素</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dequeue</span><span class="params">(T &amp;t)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_mutex)</span></span>; <span class="comment">// 队列加锁</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (m_queue.<span class="built_in">empty</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        t = std::<span class="built_in">move</span>(m_queue.<span class="built_in">front</span>()); <span class="comment">// 取出队首元素，返回队首元素值，并进行右值引用</span></span><br><span class="line"></span><br><span class="line">        m_queue.<span class="built_in">pop</span>(); <span class="comment">// 弹出入队的第一个元素</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="积木2：线程池（Thread-Pool）"><a href="#积木2：线程池（Thread-Pool）" class="headerlink" title="积木2：线程池（Thread Pool）"></a>积木2：线程池（Thread Pool）</h3><p>线程池是线程池模型的主体，我们将它拆成更小的部分来逐步分析，方便理解。</p>
<h4 id="2-1-提交函数"><a href="#2-1-提交函数" class="headerlink" title="2-1 提交函数"></a>2-1 提交函数</h4><p>线程池最重要的方法就是负责向任务队列添加任务。我们的提交函数应该做到以下两点：</p>
<ul>
<li>接收任何参数的任何函数。（普通函数，==Lambda==，==成员函数==……）</li>
<li>立即返回“东西”，避免阻塞主线程。这里返回的“东西”或者说“对象”应该包含任务结束的结果。</li>
</ul>
<p>完整的提交函数如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Submit a function to be executed asynchronously by the pool</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">submit</span><span class="params">(F &amp;&amp;f, Args &amp;&amp;...args)</span> -&gt; std::future&lt;<span class="title">decltype</span><span class="params">(f(args...))</span>&gt; ①</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// Create a function with bounded parameter ready to execute</span></span><br><span class="line">        std::function&lt;<span class="keyword">decltype</span>(<span class="built_in">f</span>(args...))()&gt; func = std::<span class="built_in">bind</span>(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...); ②<span class="comment">// 连接函数和参数定义，特殊函数类型，避免左右值错误</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Encapsulate it into a shared pointer in order to be able to copy construct</span></span><br><span class="line">        <span class="keyword">auto</span> task_ptr = std::make_shared&lt;std::packaged_task&lt;<span class="keyword">decltype</span>(<span class="built_in">f</span>(args...))()&gt;&gt;(func);  ③</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Warp packaged task into void function</span></span><br><span class="line">        std::function&lt;<span class="built_in"><span class="keyword">void</span></span>()&gt; warpper_func = [task_ptr]()</span><br><span class="line">        &#123;</span><br><span class="line">            (*task_ptr)();</span><br><span class="line">        &#125;;  ④</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 队列通用安全封包函数，并压入安全队列</span></span><br><span class="line">        m_queue.<span class="built_in">enqueue</span>(warpper_func);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 唤醒一个等待中的线程</span></span><br><span class="line">        m_conditional_lock.<span class="built_in">notify_one</span>();  ⑤</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回先前注册的任务指针</span></span><br><span class="line">        <span class="keyword">return</span> task_ptr-&gt;<span class="built_in">get_future</span>();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>C++11众多的语法糖正式来袭。下面讲一下需要注意的地方：</p>
<ol>
<li><p><code>submit()</code>是一个模板函数，这很明显。<code>template&lt;typename F, typename... Args&gt;</code>中的<code>typename... Args</code>是C++11引入的<strong>可变模版参数</strong>（variadic templates），很容易理解。</p>
<p>首先来看长得奇奇怪怪的函数头部分，<code>auto submit(F &amp;&amp;f, Args &amp;&amp;...args) -&gt; std::future&lt;decltype(f(args...))&gt;</code>，这里函数类型的定义用到了叫做<strong>“尾返回类型推导”</strong>的技巧。</p>
<p>按照标准，<code>auto</code>关键字不能用于函数形参的类型推导，==在C++14以前==，也不能直接用<code>auto func()</code>的形式来推导函数的返回类型。</p>
<p>因此传统C++中我们必须这么写：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function">R <span class="title">add</span><span class="params">(T x, U y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样存在很明显的缺陷：事实上很多时候我们并不知道<code>add()</code>这个函数会进行什么操作，获取什么样的返回类型。</p>
<p>最终在C++11中这个问题得到了解决。C++11关键字<code>decltype</code>解决了<code>auto</code>关键字只能对变量类型进行类型推导的缺陷。它的用法也很简单，应该也是看过C++11标准就能记住的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(表达式)</span><br></pre></td></tr></table></figure>

<p>但是为了利用<code>decltype</code>来推导函数的返回类型，我们并不能直接写出这种形式的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(x+y) <span class="built_in">add</span>(T x, U y)</span><br></pre></td></tr></table></figure>

<p>因为编译器在读到<code>decltype(x+y)</code>时，<code>x</code>和<code>y</code>尚未定义。而这个问题的解决方案，正是<strong>尾返回类型推导</strong>。C++11引入了一个<strong>尾返回类型</strong>（trailing return type），利用<code>auto</code>关键字将返回类型后置：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add2</span><span class="params">(T x, U y)</span> -&gt; <span class="title">decltype</span><span class="params">(x+y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，看起来奇奇怪怪的函数头中关于函数的返回类型的定义已经清楚明了：该函数的返回值将从<code>std::future&lt;decltype(f(args...))&gt;</code>中自动推导得出。</p>
<p>接着谈函数头。这里我们谈一下<code>std::future</code>，它提供了一个==访问异步操作结果==的途径。我们可以使用<code>std::future</code>的<code>wait()</code>方法来设置屏障，阻塞线程，实现线程同步。并最终使用<code>std::future</code>的<code>get()</code>方法来获得执行结果。</p>
<p>对于<code>std::future</code>，可以在这篇文献中找到更详细的讲解：</p>
<p><a href="https://changkun.de/modern-cpp/zh-cn/07-thread/index.html#7-3-%E6%9C%9F%E7%89%A9">https://changkun.de/modern-cpp/zh-cn/07-thread/index.html#7-3-%E6%9C%9F%E7%89%A9</a></p>
<p>总的来说，在我们的程序中，最后将会获得返回类型为 实例化为<code>f(args...)</code>的<code>std::future&lt;&gt;</code> 的<code>submit</code>函数。</p>
<p>如果我们阅读其他一些博文或者Github上著名的99行C++11实现线程池，我们可能会看到以下形式的添加任务方法的定义：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">ThreadPool::enqueue</span><span class="params">(F&amp;&amp; f, Args&amp;&amp;... args)</span> -&gt; std::future&lt;<span class="keyword">typename</span> std::result_of&lt;<span class="title">F</span><span class="params">(Args...)</span>&gt;::type&gt;</span></span><br></pre></td></tr></table></figure>

<p>为什么我们这里不采用<code>std::result_of&lt;&gt;::type</code>的方法而是使用<code>decltype(f(args...))</code>方法，这个要结合下一点来理解。</p>
</li>
<li><p>这里我们使用了<code>std::function</code>进行包装从而产生了一个特殊函数，这个特殊函数使用<code>std::bind</code>将函数<code>f</code>和参数<code>args</code>绑定起来。</p>
<p>简单来说，<code>std::function</code>可以对多个相似的函数进行包装（即通用的描述方法）。<code>std::function</code>可以hold住任何可以通过“()”来调用的对象，包括：</p>
<ul>
<li>普通函数</li>
<li>成员函数</li>
<li>lambda</li>
<li><code>std::bind</code></li>
</ul>
<p>而<code>std::bind</code>可以<strong>将调用函数时的部分参数先制定好，留下一部分在真正调用时确定</strong>。（当然，你也可以直接指定全部参数，在调用时不再指定。）</p>
<p>对于<code>std::function</code>和<code>std::bind</code>，我们可以移步这篇博客获得更详细的讲解：</p>
<p><a href="https://paul.pub/cpp-lambda-function-bind/">https://paul.pub/cpp-lambda-function-bind/</a></p>
<p>这里我们会注意到，<code>std::bind</code>中，出现了一个<code>std::forward()</code>的特殊方法。<code>std::forward()</code>又被称作<strong>完美转发</strong>。简单来说，<code>std::forward()</code>将会完整保留参数的引用类型进行转发。如果参数是左值引用（<em>lvalue</em>），该方法会将参数保留左值引用的形式进行转发，如果参数是右值引用（<em>rvalue</em>），该方法会将参数保留右值引用的形式进行转发。而我们这里为什么要使用这个方法呢？</p>
<p>我们会对为什么使用<code>std::forward()</code>方法产生疑惑，可能是因为我们看到了函数头中的<code>F&amp;&amp; f</code>和<code>Args&amp;&amp;... args</code>，这难道不已经指明这个函数接收的参数类型应为右值引用吗？<strong>其实不然。</strong>这里的<code>F&amp;&amp; f</code>和<code>Args&amp;&amp;... args</code>中的<code>&amp;&amp;</code>并非是右值引用意思，而是一种特殊现象，这个现象被称作<strong>万能引用</strong>（universal reference）。</p>
<p><strong>万能引用</strong>可以简单理解为，当<code>T</code>是模板参数时，<code>T&amp;&amp;</code>的作用主要是保持值类别进行转发。然而，<strong>一个绑定到universial reference上的对象可能具有lvaluesness或者rvalueness，正是因为有这种二义性</strong>，所以产生了<code>std::forward</code>。</p>
<p>有关于万能引用、完美转发以及背后所隐藏的引用折叠，可以在这篇知乎回答中找到更详细的介绍：</p>
<p><a href="https://zhuanlan.zhihu.com/p/99524127">https://zhuanlan.zhihu.com/p/99524127</a></p>
<p>总的来说，②会产生一个以 函数<code>f(arg...)</code>返回类型 为返回类型、不含参数的特殊函数包装<code>func</code>。</p>
<p>这里我们也不难注意到，在网上其他的示例中，这里使用了如下方法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> return_type = <span class="keyword">typename</span> std::result_of&lt;<span class="built_in">F</span>(Args...)&gt;::type;</span><br></pre></td></tr></table></figure>

<p>可以看到，这里再次像这些示例在函数头中一样，使用了<code>std::result_of</code>方法，而结合上文，我们也不难理解为什么本文会使用<code>std::function</code>方法，即更方便地增加对将成员函数和lambda表达式作为参数的支持。</p>
</li>
<li><p>这里我们使用<code>std::make_shared&lt;&gt;()</code>方法，声明了一个<code>std::packaged_task&lt;decltype(f(args...))()&gt;</code>类型的智能指针，并将前面<code>std::function</code>方法声明的特殊函数包装<code>func</code>传入作为<code>std::packaged_task</code>的实例化参数。智能指针将更方便我们对该<code>std::packaged_task</code>对象进行管理。</p>
<p><code>std::packaged_task</code>可以用来封装任何可以调用的目标，从而用于实现异步的调用。</p>
</li>
<li><p>这里我们再次利用<code>std::function</code>，将<em>task_ptr</em>指向的<strong>std::packaged_task</strong>对象取出并包装为void函数。这样我们的代码将更加美观优雅。</p>
<p>当然，我们也可以像其他示例一样，将这一步和下一步任务进入队列操作简化为一步：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">m_queue.<span class="built_in">enqueue</span>([task_ptr]()&#123;</span><br><span class="line">    (*task_ptr)();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li><p>这里条件变量会通知一个处于<em>wait</em>状态的线程，该线程将会从任务队列中取得任务并执行。</p>
<p>这里简要介绍一下条件变量（<code>std::condition_variable</code>）：</p>
<p>条件变量 <code>std::condition_variable</code> 是为了解决死锁而生，当互斥操作不够用而引入的。比如，线程可能需要等待某个条件为真才能继续执行，而一个忙等待循环中可能会导致所有其他线程都无法进入临界区使得条件为真时，就会发生死锁。所以，<code>condition_variable</code>实例被创建出现主要就是用于唤醒等待线程从而避免死锁。<code>std::condition_variable</code>的<code>notify_one()</code>用于唤醒一个线程；<code>notify_all()</code>则是通知所有线程。</p>
</li>
</ol>
<p>提交函数到此结束。</p>
<hr>
<h4 id="2-2-内置工作线程类"><a href="#2-2-内置工作线程类" class="headerlink" title="2-2 内置工作线程类"></a>2-2 内置工作线程类</h4><p>本文在线程池中设立私有成员类<em>ThreadWoker</em>作为内置线程工作类，执行真正的工作。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadWorker</span> // 内置线程工作类</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_id; <span class="comment">// 工作id</span></span><br><span class="line"></span><br><span class="line">    ThreadPool *m_pool; <span class="comment">// 所属线程池</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">ThreadWorker</span>(ThreadPool *pool, <span class="keyword">const</span> <span class="keyword">int</span> id) : <span class="built_in">m_pool</span>(pool), <span class="built_in">m_id</span>(id)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载()操作</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::function&lt;<span class="built_in"><span class="keyword">void</span></span>()&gt; func; <span class="comment">// 定义基础函数类func</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> dequeued; <span class="comment">// 是否正在取出队列中元素</span></span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 判断线程池是否关闭，没有关闭则从任务队列中循环提取任务</span></span><br><span class="line">        <span class="keyword">while</span> (!m_pool-&gt;m_shutdown)</span><br><span class="line">        &#123;</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 为线程环境加锁，互访问工作线程的休眠和唤醒</span></span><br><span class="line">                <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_pool-&gt;m_conditional_mutex)</span></span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果任务队列为空，阻塞当前线程</span></span><br><span class="line">                <span class="keyword">if</span> (m_pool-&gt;m_queue.<span class="built_in">empty</span>())</span><br><span class="line">                &#123;</span><br><span class="line">                    m_pool-&gt;m_conditional_lock.<span class="built_in">wait</span>(lock); <span class="comment">// 等待条件变量通知，开启线程</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 取出任务队列中的元素</span></span><br><span class="line">                dequeued = m_pool-&gt;m_queue.<span class="built_in">dequeue</span>(func);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果成功取出，执行工作函数</span></span><br><span class="line">            <span class="keyword">if</span> (dequeued)</span><br><span class="line">                <span class="built_in">func</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里应该重点关注重载()操作的<code>void operator()()</code>，这里面进行了任务的取出与执行。</p>
<p>参照注释和上文，我们使用了一个while循环，在线程池处于工作时循环从任务队列中提取任务。并利用条件变量，在任务队列为空时阻塞当前线程，等待上文中的提交函数添加任务后发出的通知。在任务队列不为空时，我们将任务队列中的任务取出，并放在事先声明的基础函数类<em>func</em>中。成功取出后便立即执行该任务。</p>
<h4 id="线程池完整代码"><a href="#线程池完整代码" class="headerlink" title="线程池完整代码"></a>线程池完整代码</h4><p>下面给出线程池的完整代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadPool</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ThreadWorker</span> // 内置线程工作类</span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> m_id; <span class="comment">// 工作id</span></span><br><span class="line"></span><br><span class="line">        ThreadPool *m_pool; <span class="comment">// 所属线程池</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// 构造函数</span></span><br><span class="line">        <span class="built_in">ThreadWorker</span>(ThreadPool *pool, <span class="keyword">const</span> <span class="keyword">int</span> id) : <span class="built_in">m_pool</span>(pool), <span class="built_in">m_id</span>(id)</span><br><span class="line">        &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重载()操作</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            std::function&lt;<span class="built_in"><span class="keyword">void</span></span>()&gt; func; <span class="comment">// 定义基础函数类func</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">bool</span> dequeued; <span class="comment">// 是否正在取出队列中元素</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (!m_pool-&gt;m_shutdown)</span><br><span class="line">            &#123;</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 为线程环境加锁，互访问工作线程的休眠和唤醒</span></span><br><span class="line">                    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_pool-&gt;m_conditional_mutex)</span></span>;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 如果任务队列为空，阻塞当前线程</span></span><br><span class="line">                    <span class="keyword">if</span> (m_pool-&gt;m_queue.<span class="built_in">empty</span>())</span><br><span class="line">                    &#123;</span><br><span class="line">                        m_pool-&gt;m_conditional_lock.<span class="built_in">wait</span>(lock); <span class="comment">// 等待条件变量通知，开启线程</span></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 取出任务队列中的元素</span></span><br><span class="line">                    dequeued = m_pool-&gt;m_queue.<span class="built_in">dequeue</span>(func);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果成功取出，执行工作函数</span></span><br><span class="line">                <span class="keyword">if</span> (dequeued)</span><br><span class="line">                    <span class="built_in">func</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> m_shutdown; <span class="comment">// 线程池是否关闭</span></span><br><span class="line"></span><br><span class="line">    SafeQueue&lt;std::function&lt;<span class="built_in"><span class="keyword">void</span></span>()&gt;&gt; m_queue; <span class="comment">// 执行函数安全队列，即任务队列</span></span><br><span class="line"></span><br><span class="line">    std::vector&lt;std::thread&gt; m_threads; <span class="comment">// 工作线程队列</span></span><br><span class="line"></span><br><span class="line">    std::mutex m_conditional_mutex; <span class="comment">// 线程休眠锁互斥变量</span></span><br><span class="line"></span><br><span class="line">    std::condition_variable m_conditional_lock; <span class="comment">// 线程环境锁，可以让线程处于休眠或者唤醒状态</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 线程池构造函数</span></span><br><span class="line">    <span class="built_in">ThreadPool</span>(<span class="keyword">const</span> <span class="keyword">int</span> n_threads = <span class="number">4</span>)</span><br><span class="line">        : <span class="built_in">m_threads</span>(std::vector&lt;std::thread&gt;(n_threads)), <span class="built_in">m_shutdown</span>(<span class="literal">false</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ThreadPool</span>(<span class="keyword">const</span> ThreadPool &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ThreadPool</span>(ThreadPool &amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    ThreadPool &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> ThreadPool &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    ThreadPool &amp;<span class="keyword">operator</span>=(ThreadPool &amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Inits thread pool</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m_threads.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            m_threads.<span class="built_in">at</span>(i) = std::<span class="built_in">thread</span>(<span class="built_in">ThreadWorker</span>(<span class="keyword">this</span>, i)); <span class="comment">// 分配工作线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Waits until threads finish their current task and shutdowns the pool</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_shutdown = <span class="literal">true</span>;</span><br><span class="line">        m_conditional_lock.<span class="built_in">notify_all</span>(); <span class="comment">// 通知，唤醒所有工作线程</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m_threads.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (m_threads.<span class="built_in">at</span>(i).<span class="built_in">joinable</span>()) <span class="comment">// 判断线程是否在等待</span></span><br><span class="line">            &#123;</span><br><span class="line">                m_threads.<span class="built_in">at</span>(i).<span class="built_in">join</span>(); <span class="comment">// 将线程加入到等待队列</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Submit a function to be executed asynchronously by the pool</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">submit</span><span class="params">(F &amp;&amp;f, Args &amp;&amp;...args)</span> -&gt; std::future&lt;<span class="title">decltype</span><span class="params">(f(args...))</span>&gt;</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// Create a function with bounded parameter ready to execute</span></span><br><span class="line">        std::function&lt;<span class="keyword">decltype</span>(<span class="built_in">f</span>(args...))()&gt; func = std::<span class="built_in">bind</span>(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...); <span class="comment">// 连接函数和参数定义，特殊函数类型，避免左右值错误</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Encapsulate it into a shared pointer in order to be able to copy construct</span></span><br><span class="line">        <span class="keyword">auto</span> task_ptr = std::make_shared&lt;std::packaged_task&lt;<span class="keyword">decltype</span>(<span class="built_in">f</span>(args...))()&gt;&gt;(func);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Warp packaged task into void function</span></span><br><span class="line">        std::function&lt;<span class="built_in"><span class="keyword">void</span></span>()&gt; warpper_func = [task_ptr]()</span><br><span class="line">        &#123;</span><br><span class="line">            (*task_ptr)();</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 队列通用安全封包函数，并压入安全队列</span></span><br><span class="line">        m_queue.<span class="built_in">enqueue</span>(warpper_func);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 唤醒一个等待中的线程</span></span><br><span class="line">        m_conditional_lock.<span class="built_in">notify_one</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回先前注册的任务指针</span></span><br><span class="line">        <span class="keyword">return</span> task_ptr-&gt;<span class="built_in">get_future</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>结合注释应该能很轻松的理解线程池剩余的代码。</p>
<p>注意一下<code>init()</code>函数和<code>shutdown()</code>函数：</p>
<ul>
<li>在线程池初始化函数<code>init()</code>中，我们声明并分配工作线程，将工作线程放入工作线程队列<em>m_threads</em>中。</li>
<li>在线程池关闭函数<code>shutdown()</code>中，我们唤醒所有工作线程，并等待期完成所有工作后关闭线程池。</li>
</ul>
<p>这里我们也可以改进一下代码，将<code>shutdown()</code>函数中的工作转移到<em>ThreadPool</em>的析构函数中，从而更便利日后的使用。</p>
<p>至此，线程池全文讲解结束，后附完整项目代码及参考资料。</p>
<h2 id="0x02-项目完整代码"><a href="#0x02-项目完整代码" class="headerlink" title="0x02 项目完整代码"></a>0x02 项目完整代码</h2><h3 id="线程池代码"><a href="#线程池代码" class="headerlink" title="线程池代码"></a>线程池代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//thread_pool.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> THREAD_POOL_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THREAD_POOL_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Thread safe implementation of a Queue using a std::queue</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SafeQueue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::queue&lt;T&gt; m_queue; <span class="comment">//利用模板函数构造队列</span></span><br><span class="line"></span><br><span class="line">    std::mutex m_mutex; <span class="comment">// 访问互斥信号量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SafeQueue</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">SafeQueue</span>(SafeQueue &amp;&amp;other) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">SafeQueue</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="comment">// 返回队列是否为空</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_mutex)</span></span>; <span class="comment">// 互斥信号变量加锁，防止m_queue被改变</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> m_queue.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_mutex)</span></span>; <span class="comment">// 互斥信号变量加锁，防止m_queue被改变</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> m_queue.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 队列添加元素</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(T &amp;t)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">        m_queue.<span class="built_in">emplace</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 队列取出元素</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dequeue</span><span class="params">(T &amp;t)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_mutex)</span></span>; <span class="comment">// 队列加锁</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (m_queue.<span class="built_in">empty</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        t = std::<span class="built_in">move</span>(m_queue.<span class="built_in">front</span>()); <span class="comment">// 取出队首元素，返回队首元素值，并进行右值引用</span></span><br><span class="line"></span><br><span class="line">        m_queue.<span class="built_in">pop</span>(); <span class="comment">// 弹出入队的第一个元素</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadPool</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ThreadWorker</span> // 内置线程工作类</span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> m_id; <span class="comment">// 工作id</span></span><br><span class="line"></span><br><span class="line">        ThreadPool *m_pool; <span class="comment">// 所属线程池</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// 构造函数</span></span><br><span class="line">        <span class="built_in">ThreadWorker</span>(ThreadPool *pool, <span class="keyword">const</span> <span class="keyword">int</span> id) : <span class="built_in">m_pool</span>(pool), <span class="built_in">m_id</span>(id)</span><br><span class="line">        &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重载()操作</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            std::function&lt;<span class="built_in"><span class="keyword">void</span></span>()&gt; func; <span class="comment">// 定义基础函数类func</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">bool</span> dequeued; <span class="comment">// 是否正在取出队列中元素</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (!m_pool-&gt;m_shutdown)</span><br><span class="line">            &#123;</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 为线程环境加锁，互访问工作线程的休眠和唤醒</span></span><br><span class="line">                    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_pool-&gt;m_conditional_mutex)</span></span>;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 如果任务队列为空，阻塞当前线程</span></span><br><span class="line">                    <span class="keyword">if</span> (m_pool-&gt;m_queue.<span class="built_in">empty</span>())</span><br><span class="line">                    &#123;</span><br><span class="line">                        m_pool-&gt;m_conditional_lock.<span class="built_in">wait</span>(lock); <span class="comment">// 等待条件变量通知，开启线程</span></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 取出任务队列中的元素</span></span><br><span class="line">                    dequeued = m_pool-&gt;m_queue.<span class="built_in">dequeue</span>(func);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果成功取出，执行工作函数</span></span><br><span class="line">                <span class="keyword">if</span> (dequeued)</span><br><span class="line">                    <span class="built_in">func</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> m_shutdown; <span class="comment">// 线程池是否关闭</span></span><br><span class="line"></span><br><span class="line">    SafeQueue&lt;std::function&lt;<span class="built_in"><span class="keyword">void</span></span>()&gt;&gt; m_queue; <span class="comment">// 执行函数安全队列，即任务队列</span></span><br><span class="line"></span><br><span class="line">    std::vector&lt;std::thread&gt; m_threads; <span class="comment">// 工作线程队列</span></span><br><span class="line"></span><br><span class="line">    std::mutex m_conditional_mutex; <span class="comment">// 线程休眠锁互斥变量</span></span><br><span class="line"></span><br><span class="line">    std::condition_variable m_conditional_lock; <span class="comment">// 线程环境锁，可以让线程处于休眠或者唤醒状态</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 线程池构造函数</span></span><br><span class="line">    <span class="built_in">ThreadPool</span>(<span class="keyword">const</span> <span class="keyword">int</span> n_threads = <span class="number">4</span>)</span><br><span class="line">        : <span class="built_in">m_threads</span>(std::vector&lt;std::thread&gt;(n_threads)), <span class="built_in">m_shutdown</span>(<span class="literal">false</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ThreadPool</span>(<span class="keyword">const</span> ThreadPool &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ThreadPool</span>(ThreadPool &amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    ThreadPool &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> ThreadPool &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    ThreadPool &amp;<span class="keyword">operator</span>=(ThreadPool &amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Inits thread pool</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m_threads.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            m_threads.<span class="built_in">at</span>(i) = std::<span class="built_in">thread</span>(<span class="built_in">ThreadWorker</span>(<span class="keyword">this</span>, i)); <span class="comment">// 分配工作线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Waits until threads finish their current task and shutdowns the pool</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_shutdown = <span class="literal">true</span>;</span><br><span class="line">        m_conditional_lock.<span class="built_in">notify_all</span>(); <span class="comment">// 通知，唤醒所有工作线程</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m_threads.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (m_threads.<span class="built_in">at</span>(i).<span class="built_in">joinable</span>()) <span class="comment">// 判断线程是否在等待</span></span><br><span class="line">            &#123;</span><br><span class="line">                m_threads.<span class="built_in">at</span>(i).<span class="built_in">join</span>(); <span class="comment">// 将线程加入到等待队列</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Submit a function to be executed asynchronously by the pool</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">submit</span><span class="params">(F &amp;&amp;f, Args &amp;&amp;...args)</span> -&gt; std::future&lt;<span class="title">decltype</span><span class="params">(f(args...))</span>&gt;</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// Create a function with bounded parameter ready to execute</span></span><br><span class="line">        std::function&lt;<span class="keyword">decltype</span>(<span class="built_in">f</span>(args...))()&gt; func = std::<span class="built_in">bind</span>(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...); <span class="comment">// 连接函数和参数定义，特殊函数类型，避免左右值错误</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Encapsulate it into a shared pointer in order to be able to copy construct</span></span><br><span class="line">        <span class="keyword">auto</span> task_ptr = std::make_shared&lt;std::packaged_task&lt;<span class="keyword">decltype</span>(<span class="built_in">f</span>(args...))()&gt;&gt;(func);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Warp packaged task into void function</span></span><br><span class="line">        std::function&lt;<span class="built_in"><span class="keyword">void</span></span>()&gt; warpper_func = [task_ptr]()</span><br><span class="line">        &#123;</span><br><span class="line">            (*task_ptr)();</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 队列通用安全封包函数，并压入安全队列</span></span><br><span class="line">        m_queue.<span class="built_in">enqueue</span>(warpper_func);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 唤醒一个等待中的线程</span></span><br><span class="line">        m_conditional_lock.<span class="built_in">notify_one</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回先前注册的任务指针</span></span><br><span class="line">        <span class="keyword">return</span> task_ptr-&gt;<span class="built_in">get_future</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>



<h3 id="测试样例代码"><a href="#测试样例代码" class="headerlink" title="测试样例代码"></a>测试样例代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;random&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;thread_pool.h&quot;</span></span></span><br><span class="line">std::random_device rd; <span class="comment">// 真实随机数产生器</span></span><br><span class="line"></span><br><span class="line"><span class="function">std::mt19937 <span class="title">mt</span><span class="params">(rd())</span></span>; <span class="comment">//生成计算随机数mt</span></span><br><span class="line"></span><br><span class="line"><span class="function">std::uniform_int_distribution&lt;<span class="keyword">int</span>&gt; <span class="title">dist</span><span class="params">(<span class="number">-1000</span>, <span class="number">1000</span>)</span></span>; <span class="comment">//生成-1000到1000之间的离散均匀分布数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> rnd = std::<span class="built_in">bind</span>(dist, mt);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置线程睡眠时间</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">simulate_hard_computation</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">2000</span> + <span class="built_in">rnd</span>()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加两个数字的简单函数并打印结果</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">multiply</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> a, <span class="keyword">const</span> <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">simulate_hard_computation</span>();</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> res = a * b;</span><br><span class="line">    std::cout &lt;&lt; a &lt;&lt; <span class="string">&quot; * &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; res &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加并输出结果</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">multiply_output</span><span class="params">(<span class="keyword">int</span> &amp;out, <span class="keyword">const</span> <span class="keyword">int</span> a, <span class="keyword">const</span> <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">simulate_hard_computation</span>();</span><br><span class="line">    out = a * b;</span><br><span class="line">    std::cout &lt;&lt; a &lt;&lt; <span class="string">&quot; * &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; out &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果返回</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">multiply_return</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> a, <span class="keyword">const</span> <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">simulate_hard_computation</span>();</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> res = a * b;</span><br><span class="line">    std::cout &lt;&lt; a &lt;&lt; <span class="string">&quot; * &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; res &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">example</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建3个线程的线程池</span></span><br><span class="line">    <span class="function">ThreadPool <span class="title">pool</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化线程池</span></span><br><span class="line">    pool.<span class="built_in">init</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提交乘法操作，总共30个</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">10</span>; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            pool.<span class="built_in">submit</span>(multiply, i, j);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用ref传递的输出参数提交函数</span></span><br><span class="line">    <span class="keyword">int</span> output_ref;</span><br><span class="line">    <span class="keyword">auto</span> future1 = pool.<span class="built_in">submit</span>(multiply_output, std::<span class="built_in">ref</span>(output_ref), <span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待乘法输出完成</span></span><br><span class="line">    future1.<span class="built_in">get</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Last operation result is equals to &quot;</span> &lt;&lt; output_ref &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用return参数提交函数</span></span><br><span class="line">    <span class="keyword">auto</span> future2 = pool.<span class="built_in">submit</span>(multiply_return, <span class="number">5</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待乘法输出完成</span></span><br><span class="line">    <span class="keyword">int</span> res = future2.<span class="built_in">get</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Last operation result is equals to &quot;</span> &lt;&lt; res &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭线程池</span></span><br><span class="line">    pool.<span class="built_in">shutdown</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">example</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="0x03-参考资料"><a href="#0x03-参考资料" class="headerlink" title="0x03 参考资料"></a>0x03 参考资料</h2><ol>
<li>《C++后端线程池》：<a href="https://wangpengcheng.github.io/2019/05/17/cplusplus_theadpool/">https://wangpengcheng.github.io/2019/05/17/cplusplus_theadpool/</a></li>
<li>《基于C++11的线程池（threadpool），简介且可以带任意多的参数》：<a href="https://www.cnblogs.com/lzpong/p/6397997.html">https://www.cnblogs.com/lzpong/p/6397997.html</a></li>
<li>《C++并发编程（从C++11到C++17）》：<a href="https://paul.pub/cpp-concurrency">https://paul.pub/cpp-concurrency</a></li>
<li>《从pthread转换到std::thread》：<a href="https://segmentfault.com/a/1190000002655852">https://segmentfault.com/a/1190000002655852</a></li>
<li>《货比三家：C++中的task based并发》：<a href="https://segmentfault.com/a/1190000002706259">https://segmentfault.com/a/1190000002706259</a></li>
<li>Github-99行线程池实现：<a href="https://github.com/progschj/ThreadPool">https://github.com/progschj/ThreadPool</a></li>
<li>《现代C++之万能引用、完美转发、引用折叠》：<a href="https://zhuanlan.zhihu.com/p/99524127">https://zhuanlan.zhihu.com/p/99524127</a></li>
<li>《C++11中的lambda，std::function以及std:bind》：<a href="https://paul.pub/cpp-lambda-function-bind/">https://paul.pub/cpp-lambda-function-bind/</a></li>
<li>《现代C++教程——告诉上手C++11/14/17/20》：<a href="https://changkun.de/modern-cpp/">https://changkun.de/modern-cpp/</a></li>
</ol>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++11</tag>
        <tag>C++高并发</tag>
        <tag>C++线程池</tag>
      </tags>
  </entry>
  <entry>
    <title>C++并发编程</title>
    <url>/2021/04/22/C++%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="C-Concurrency"><a href="#C-Concurrency" class="headerlink" title="C++ Concurrency"></a>C++ Concurrency</h1><h2 id="0x00-概念"><a href="#0x00-概念" class="headerlink" title="0x00 概念"></a>0x00 概念</h2><p>CPP11标准以来，C++语言开始支持多线程模型。借助多线程模型，可以开发出更好的并发系统。</p>
<span id="more"></span>

<h3 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h3><ul>
<li>并发(Concurrent)：如果多个队列可以交替使用某台咖啡机，则这一行为就是并发的。</li>
<li>并行(Parallel)：如果存在多台咖啡机可以被多个队列交替使用，则就是并行。</li>
</ul>
<img src="https://paul-pub.oss-cn-beijing.aliyuncs.com/2019/2019-11-26-cpp-concurrency/con_and_par.jpg" alt="img" style="zoom:80%;" />

<p>并发和并行都是在多任务的环境下的讨论。并行其实是并发的子集，他们的区别在于是否具有多个处理器。</p>
<p>进程与线程是操作系统的基本概念。</p>
<blockquote>
<ul>
<li><strong>进程</strong>(process)：计算机已运行的程序。进程是程序的基本执行实体；</li>
<li><strong>线程</strong>(thread)：操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。</li>
</ul>
</blockquote>
<p>绝大多数情况下，所写的程序在一个进程中运行。一个进程至少会包含一个线程。这个线程我们通常称之为==主线程==。</p>
<p>在默认情况下，代码都是在进程的主线程中运行，除非开发者在程序中创建了新的线程。</p>
<p>任务在何时占有处理器，通常是由操作系统的调度策略决定的。当开发跨平台软件时，不应对调度策略做任何假设，而应该抱有“系统可能以任意顺序来调度我的任务”这样的想法。</p>
<h3 id="并发系统的性能"><a href="#并发系统的性能" class="headerlink" title="并发系统的性能"></a>并发系统的性能</h3><p>开发并发系统最主要的动机就是提升系统性能（<em>事实上，这是以增加复杂度为代价的</em>）。</p>
<p><strong>阿姆达尔定律</strong>告诉我们将系统并行之后性能收益的上限。</p>
<h2 id="0x01-C-与并发编程"><a href="#0x01-C-与并发编程" class="headerlink" title="0x01 C++与并发编程"></a>0x01 C++与并发编程</h2><h3 id="C-标准特性的路线图"><a href="#C-标准特性的路线图" class="headerlink" title="C++标准特性的路线图"></a>C++标准特性的路线图</h3><p><img src="https://paul-pub.oss-cn-beijing.aliyuncs.com/2019/2019-11-26-cpp-concurrency/cpp_timeline.png" alt="img"></p>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><h4 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 01_hello_thread.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span> <span class="comment">// ①</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; <span class="comment">// ②</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123; <span class="comment">// ③</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Hello World from new thread.&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">thread <span class="title">t</span><span class="params">(hello)</span></span>; <span class="comment">// ④</span></span><br><span class="line">  t.<span class="built_in">join</span>(); <span class="comment">// ⑤</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li>为了使用多线程的接口，我们需要<code>#include &lt;thread&gt;</code>头文件。</li>
<li>为了简化声明，本文中的代码都将<code>using namespace std;</code>。</li>
<li>新建线程的入口是一个普通的函数，它并没有什么特别的地方。</li>
<li>创建线程的方式就是构造一个<code>thread</code>对象，并指定入口函数。与普通对象不一样的是，此时编译器便会为我们创建一个新的操作系统线程，并在新的线程中执行我们的入口函数。</li>
<li>关于<code>join</code>函数在下文中讲解。</li>
</ol>
</blockquote>
<p>==thread==可以和==callable==类型一起工作，因此也可以直接用<em>lambda</em>来写线程逻辑。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 02_lambda_thread.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">thread <span class="title">t</span><span class="params">([] &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    cout &lt;&lt; <span class="string">&quot;Hello World from lambda thread.&quot;</span> &lt;&lt; endl;</span></span></span><br><span class="line"><span class="params"><span class="function">  &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">  t.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以==传递参数==给入口函数，像下面这样：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 03_thread_argument.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">(string name)</span> </span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Welcome to &quot;</span> &lt;&lt; name &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">thread <span class="title">t</span><span class="params">(hello, <span class="string">&quot;https://paul.pub&quot;</span>)</span></span>;</span><br><span class="line">  t.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>甚至可以传递一个类成员函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 假设buy是一个可调用的函数对象，它即可能是函数指针，也可能是函数对象</span></span><br><span class="line"><span class="function">std::thread <span class="title">Annie</span><span class="params">(buy)</span></span>;</span><br><span class="line"><span class="comment">// Annie会去执行buy()</span></span><br><span class="line"><span class="function">std::thread <span class="title">Bob</span><span class="params">(buy, book, food)</span></span>;</span><br><span class="line"><span class="comment">// Bob会去执行buy(book, food)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设buy是Consumer的一个可调用的成员函数</span></span><br><span class="line">Consumer Clara;</span><br><span class="line"><span class="function">std::thread <span class="title">action</span><span class="params">(buy, std::ref(Clara), phone)</span></span>;</span><br><span class="line"><span class="comment">// Clara会去执行Consumer.buy(phone)</span></span><br></pre></td></tr></table></figure>



<p>应注意，<strong>参数以拷贝的形式传递</strong>。对于拷贝耗时的对象可能需要传递指针或者引用类型作为参数。但是传递指针和引用，还应考虑参数对象的生命周期。</p>
<p><strong>注意：</strong>当创建了一个（非空的）线程对象时，对应线程就会执行。</p>
<h4 id="join与detach"><a href="#join与detach" class="headerlink" title="join与detach"></a>join与detach</h4><ul>
<li>主要API</li>
</ul>
<table>
<thead>
<tr>
<th>API</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>join</td>
<td>等待线程完成其执行</td>
</tr>
<tr>
<td>detach</td>
<td>允许线程独立执行</td>
</tr>
</tbody></table>
<p>线程启动之后，必须决定等待直接它结束（==join==），还是让他独立运行（==detach==），必须二者选其一。若在==thread==对象<strong>销毁的时候</strong>还没有做决定，则==thread==对象在析构函数将调用==std::terminate()==从而导致进程异常退出。</p>
<ul>
<li><code>join</code>：调用此接口时，当前线程会一直阻塞，直到目标线程执行完成（当然，很可能目标线程在此处调用之前就已经执行完成了，不过这不要紧）。因此，如果目标线程的任务非常耗时，你就要考虑好是否需要在主线程上等待它了，因此这很可能会导致主线程卡住。</li>
<li><code>detach</code>：<code>detach</code>是让目标线程成为守护线程（daemon threads）。一旦<code>detach</code>之后，目标线程将独立执行，即便其对应的<code>thread</code>对象销毁也不影响线程的执行。并且，你无法再与之通信。</li>
</ul>
<h4 id="管理当前线程"><a href="#管理当前线程" class="headerlink" title="管理当前线程"></a>管理当前线程</h4><ul>
<li>主要API</li>
</ul>
<table>
<thead>
<tr>
<th align="left">API</th>
<th align="left">C++标准</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">yield</td>
<td align="left">C++11</td>
<td align="left">让出处理器，重新调度各执行线程</td>
</tr>
<tr>
<td align="left">get_id</td>
<td align="left">C++11</td>
<td align="left">返回当前线程的线程 id</td>
</tr>
<tr>
<td align="left">sleep_for</td>
<td align="left">C++11</td>
<td align="left">使当前线程的执行停止指定的时间段</td>
</tr>
<tr>
<td align="left">sleep_until</td>
<td align="left">C++11</td>
<td align="left">使当前线程的执行停止直到指定的时间点</td>
</tr>
</tbody></table>
<p>上面是一些在线程内部使用的API，它们用来对当前线程做一些控制。</p>
<ul>
<li><code>yield</code> 通常用在自己的主要任务已经完成的时候，此时希望让出处理器给其他任务使用。</li>
<li><code>get_id</code> 返回当前线程的id，可以以此来标识不同的线程。</li>
<li><code>sleep_for</code> 是让当前线程停止一段时间。</li>
<li><code>sleep_until</code> 和<code>sleep_for</code>类似，但是是以具体的时间点为参数。这两个API都以<a href="https://en.cppreference.com/w/cpp/header/chrono">chrono</a> API（由于篇幅所限，这里不展开这方面内容）为基础。</li>
</ul>
<p>代码示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 04_thread_self_manage.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_time</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> now = chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line">  <span class="keyword">auto</span> <span class="keyword">in_time_t</span> = chrono::system_clock::<span class="built_in">to_time_t</span>(now);</span><br><span class="line"></span><br><span class="line">  std::stringstream ss;</span><br><span class="line">  ss &lt;&lt; <span class="built_in">put_time</span>(<span class="built_in">localtime</span>(&amp;<span class="keyword">in_time_t</span>), <span class="string">&quot;%Y-%m-%d %X&quot;</span>);</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;now is: &quot;</span> &lt;&lt; ss.<span class="built_in">str</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sleep_thread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">seconds</span>(<span class="number">3</span>));</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;[thread-&quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot;] is waking up&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">loop_thread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;[thread-&quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot;] print: &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">print_time</span>();</span><br><span class="line"></span><br><span class="line">  <span class="function">thread <span class="title">t1</span><span class="params">(sleep_thread)</span></span>;</span><br><span class="line">  <span class="function">thread <span class="title">t2</span><span class="params">(loop_thread)</span></span>;</span><br><span class="line"></span><br><span class="line">  t1.<span class="built_in">join</span>();</span><br><span class="line">  t2.<span class="built_in">detach</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">print_time</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">now is: 2019-10-13 10:17:48</span><br><span class="line">[thread-0x70000cdda000] print: 0</span><br><span class="line">[thread-0x70000cdda000] print: 1</span><br><span class="line">[thread-0x70000cdda000] print: 2</span><br><span class="line">[thread-0x70000cdda000] print: 3</span><br><span class="line">[thread-0x70000cdda000] print: 4</span><br><span class="line">[thread-0x70000cdda000] print: 5</span><br><span class="line">[thread-0x70000cdda000] print: 6</span><br><span class="line">[thread-0x70000cdda000] print: 7</span><br><span class="line">[thread-0x70000cdda000] print: 8</span><br><span class="line">[thread-0x70000cdda000] print: 9</span><br><span class="line">[thread-0x70000cd57000] is waking up</span><br><span class="line">now is: 2019-10-13 10:17:51</span><br></pre></td></tr></table></figure>



<h4 id="一次调用"><a href="#一次调用" class="headerlink" title="一次调用"></a>一次调用</h4><ul>
<li>主要API</li>
</ul>
<table>
<thead>
<tr>
<th align="left">API</th>
<th align="left">C++标准</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">call_once</td>
<td align="left">C++11</td>
<td align="left">即便在多线程环境下，也能保证只调用某个函数一次</td>
</tr>
<tr>
<td align="left">once_flag</td>
<td align="left">C++11</td>
<td align="left">与<code>call_once</code>配合使用</td>
</tr>
</tbody></table>
<p>在一些情况下，我们有些任务需要执行一次，并且我们只希望它执行一次，例如资源的初始化任务。这个时候就可以用到上面的接口。这个接口会保证，即便在多线程的环境下，相应的函数也只会调用一次。</p>
<p>下面就是一个示例：有三个线程都会使用<code>init</code>函数，但是只会有一个线程真正执行它。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 05_call_once.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Initialing...&quot;</span> &lt;&lt; endl;</span><br><span class="line">  <span class="comment">// Do something...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">worker</span><span class="params">(once_flag* flag)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">call_once</span>(*flag, init);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  once_flag flag;</span><br><span class="line"></span><br><span class="line">  <span class="function">thread <span class="title">t1</span><span class="params">(worker, &amp;flag)</span></span>;</span><br><span class="line">  <span class="function">thread <span class="title">t2</span><span class="params">(worker, &amp;flag)</span></span>;</span><br><span class="line">  <span class="function">thread <span class="title">t3</span><span class="params">(worker, &amp;flag)</span></span>;</span><br><span class="line"></span><br><span class="line">  t1.<span class="built_in">join</span>();</span><br><span class="line">  t2.<span class="built_in">join</span>();</span><br><span class="line">  t3.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="并发任务"><a href="#并发任务" class="headerlink" title="并发任务"></a>并发任务</h4><p>下面以一个并发任务为示例讲解如何引入多线程。</p>
<p>任务示例：现在假设我们需要计算某个范围内所有自然数的平方根之和，例如<code>[1, 10e8]</code>。</p>
<p>在单线程模型下，我们的代码可能是这样的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 06_naive_multithread.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">10e8</span>; <span class="comment">// ①</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">double</span> sum = <span class="number">0</span>; <span class="comment">// ②</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">worker</span><span class="params">(<span class="keyword">int</span> min, <span class="keyword">int</span> max)</span> </span>&#123; <span class="comment">// ③</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = min; i &lt;= max; i++) &#123;</span><br><span class="line">    sum += <span class="built_in">sqrt</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">serial_task</span><span class="params">(<span class="keyword">int</span> min, <span class="keyword">int</span> max)</span> </span>&#123; <span class="comment">// ④</span></span><br><span class="line">  <span class="keyword">auto</span> start_time = chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line">  sum = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">worker</span>(<span class="number">0</span>, MAX);</span><br><span class="line">  <span class="keyword">auto</span> end_time = chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line">  <span class="keyword">auto</span> ms = chrono::duration_cast&lt;chrono::milliseconds&gt;(end_time - start_time).<span class="built_in">count</span>();</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Serail task finish, &quot;</span> &lt;&lt; ms &lt;&lt; <span class="string">&quot; ms consumed, Result: &quot;</span> &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码说明如下：</p>
<ol>
<li>通过一个常量指定数据范围，这个是为了方便调整。</li>
<li>通过一个全局变量来存储结果。</li>
<li>通过一个任务函数来计算值。</li>
<li>统计任务的执行时间。</li>
</ol>
<p>这段程序输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Serail task finish, 6406 ms consumed, Result: 2.10819e+13</span><br></pre></td></tr></table></figure>

<p>很显然，上面单线程的做法性能太差了。我们的任务完全是可以并发执行的。并且任务很容易划分。</p>
<p>下面我们就尝试以多线程的方式来改造原先的程序。</p>
<p>改造后的程序如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 06_naive_multithread.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">concurrent_task</span><span class="params">(<span class="keyword">int</span> min, <span class="keyword">int</span> max)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> start_time = chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">unsigned</span> concurrent_count = thread::<span class="built_in">hardware_concurrency</span>(); <span class="comment">// ①</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;hardware_concurrency: &quot;</span> &lt;&lt; concurrent_count &lt;&lt; endl;</span><br><span class="line">  vector&lt;thread&gt; threads;</span><br><span class="line">  min = <span class="number">0</span>;</span><br><span class="line">  sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t &lt; concurrent_count; t++) &#123; <span class="comment">// ②</span></span><br><span class="line">    <span class="keyword">int</span> range = max / concurrent_count * (t + <span class="number">1</span>);</span><br><span class="line">    threads.<span class="built_in">push_back</span>(<span class="built_in">thread</span>(worker, min, range)); <span class="comment">// ③</span></span><br><span class="line">    min = range + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; t : threads) &#123;</span><br><span class="line">    t.<span class="built_in">join</span>(); <span class="comment">// ④</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> end_time = chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line">  <span class="keyword">auto</span> ms = chrono::duration_cast&lt;chrono::milliseconds&gt;(end_time - start_time).<span class="built_in">count</span>();</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Concurrent task finish, &quot;</span> &lt;&lt; ms &lt;&lt; <span class="string">&quot; ms consumed, Result: &quot;</span> &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码说明如下：</p>
<ol>
<li><code>thread::hardware_concurrency()</code>可以获取到当前硬件支持多少个线程并行执行。</li>
<li>根据处理器的情况决定线程的数量。</li>
<li>对于每一个线程都通过<code>worker</code>函数来完成任务，并划分一部分数据给它处理。</li>
<li>等待每一个线程执行结束。</li>
</ol>
<p>很好，似乎很简单就完成了并发的改造。然后我们运行一下这个程序：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hardware_concurrency: 16</span><br><span class="line">Concurrent task finish, 6246 ms consumed, Result: 1.78162e+12</span><br></pre></td></tr></table></figure>

<p>很抱歉，我们会发现这里的性能并没有明显的提升。更严重的是，这里的结果是错误的。</p>
<p>要搞清楚为什么结果不正确我们需要更多的背景知识。</p>
<p>我们知道，对于现代的处理器来说，为了加速处理的速度，每个处理器都会有自己的高速缓存（Cache），这个高速缓存是与每个处理器相对应的，如下图所示：</p>
<blockquote>
<p>事实上，目前大部分CPU的缓存已经不只一层。</p>
</blockquote>
<img src="https://paul-pub.oss-cn-beijing.aliyuncs.com/2019/2019-11-26-cpp-concurrency/cpu.png" alt="img" style="zoom:80%;" />

<p>处理器在进行计算的时候，高速缓存会参与其中，例如数据的读和写。而高速缓存和系统主存（Memory）是有可能存在不一致的。即：某个结果计算后保存在处理器的高速缓存中了，但是没有同步到主存中，此时这个值对于其他处理器就是不可见的。</p>
<p>事情还远不止这么简单。我们对于全局变量值的修改：<code>sum += sqrt(i);</code>这条语句，它并非是原子的。它其实是很多条指令的组合才能完成。假设在某个设备上，这条语句通过下面这几个步骤来完成。它们的时序可能如下所示：</p>
<img src="https://paul-pub.oss-cn-beijing.aliyuncs.com/2019/2019-11-26-cpp-concurrency/multithread.png" alt="img" style="zoom:80%;" />

<p>在时间点a的时候，所有线程对于<code>sum</code>变量的值是一致的。</p>
<p>但是在时间点b之后，thread3上已经对<code>sum</code>进行了赋值。而这个时候其他几个线程也同时在其他处理器上使用了这个值，那么这个时候它们所使用的值就是旧的（错误的）。最后得到的结果也自然是错的。</p>
<h3 id="竞争条件与临界区"><a href="#竞争条件与临界区" class="headerlink" title="竞争条件与临界区"></a>竞争条件与临界区</h3><p>当多个进程或者线程同时访问共享数据时，只要有一个任务会修改数据，那么就可能会发生问题。此时结果依赖于这些任务执行的相对时间，这种场景称为<a href="https://en.wikipedia.org/wiki/Race_condition"><strong>竞争条件</strong>（race condition）</a>。</p>
<p>访问共享数据的代码片段称之为<strong>临界区</strong>（critical section）。具体到上面这个示例，临界区就是读写<code>sum</code>变量的地方。</p>
<p>要避免竞争条件，就需要对临界区进行数据保护。</p>
<p>很自然的，现在我们能够理解发生竞争条件是因为这些线程在同时访问共享数据，其中有些线程的改动没有让其他线程知道，导致其他线程在错误的基础上进行处理，结果自然也就是错误的。</p>
<p>那么，如果一次只让一个线程访问共享数据，访问完了再让其他线程接着访问，这样就可以避免问题的发生了。</p>
<p>接下来介绍的API提供的就是这样的功能。</p>
<h3 id="互斥体与锁"><a href="#互斥体与锁" class="headerlink" title="互斥体与锁"></a>互斥体与锁</h3><h4 id="mutex"><a href="#mutex" class="headerlink" title="mutex"></a>mutex</h4><p>开发并发系统的目的主要是为了提升性能：将任务分散到多个线程，然后在不同的处理器上同时执行。这些分散开来的线程通常会包含两类任务：</p>
<ol>
<li>独立的对于划分给自己的数据的处理</li>
<li>对于处理结果的汇总</li>
</ol>
<p>其中第1项任务因为每个线程是独立的，不存在竞争条件的问题。而第2项任务，由于所有线程都可能往总结果（例如上面的<code>sum</code>变量）汇总，这就需要做保护了。在某一个具体的时刻，只应当有一个线程更新总结果，即：保证每个线程对于共享数据的访问是“互斥”的。<code>mutex</code> 就提供了这样的功能。</p>
<p><code>mutex</code>是<strong>mut</strong>ual <strong>ex</strong>clusion（互斥）的简写。</p>
<ul>
<li>主要API</li>
</ul>
<table>
<thead>
<tr>
<th align="left">API</th>
<th align="left">C++标准</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">mutex</td>
<td align="left">C++11</td>
<td align="left">提供基本互斥设施</td>
</tr>
<tr>
<td align="left">timed_mutex</td>
<td align="left">C++11</td>
<td align="left">提供互斥设施，带有超时功能</td>
</tr>
<tr>
<td align="left">recursive_mutex</td>
<td align="left">C++11</td>
<td align="left">提供能被同一线程递归锁定的互斥设施</td>
</tr>
<tr>
<td align="left">recursive_timed_mutex</td>
<td align="left">C++11</td>
<td align="left">提供能被同一线程递归锁定的互斥设施，带有超时功能</td>
</tr>
<tr>
<td align="left">shared_timed_mutex</td>
<td align="left">C++14</td>
<td align="left">提供共享互斥设施并带有超时功能</td>
</tr>
<tr>
<td align="left">shared_mutex</td>
<td align="left">C++17</td>
<td align="left">提供共享互斥设施</td>
</tr>
</tbody></table>
<p>很明显，在这些类中，<code>mutex</code>是最基础的API。其他类都是在它的基础上的改进。所以这些类都提供了下面三个方法，并且它们的功能是一样的：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>lock</td>
<td>锁定互斥体，如果不可用，则阻塞</td>
</tr>
<tr>
<td>try_lock</td>
<td>尝试锁定互斥体，如果不可用，直接返回</td>
</tr>
<tr>
<td>unlock</td>
<td>解锁互斥体</td>
</tr>
</tbody></table>
<p>这三个方法提供了基础的锁定和解除锁定的功能。使用<code>lock</code>意味着你有很强的意愿一定要获取到互斥体，而使用<code>try_lock</code>则是进行一次尝试。这意味着如果失败了，你通常还有其他的路径可以走。</p>
<p>在这些基础功能之上，其他的类分别在下面三个方面进行了扩展：</p>
<ul>
<li><strong>超时</strong>：<code>timed_mutex</code>，<code>recursive_timed_mutex</code>，<code>shared_timed_mutex</code>的名称都带有<code>timed</code>，这意味着它们都支持超时功能。它们都提供了<code>try_lock_for</code>和<code>try_lock_until</code>方法，这两个方法分别可以指定超时的时间长度和时间点。如果在超时的时间范围内没有能获取到锁，则直接返回，不再继续等待。</li>
<li><strong>可重入</strong>：<code>recursive_mutex</code>和<code>recursive_timed_mutex</code>的名称都带有<code>recursive</code>。可重入或者叫做可递归，是指在同一个线程中，同一把锁可以锁定多次。这就避免了一些不必要的死锁。</li>
<li><strong>共享</strong>：<code>shared_timed_mutex</code>和<code>shared_mutex</code>提供了共享功能。对于这类互斥体，实际上是提供了两把锁：一把是共享锁，一把是互斥锁。一旦某个线程获取了互斥锁，任何其他线程都无法再获取互斥锁和共享锁；但是如果有某个线程获取到了共享锁，其他线程无法再获取到互斥锁，但是还有获取到共享锁。这里互斥锁的使用和其他的互斥体接口和功能一样。而共享锁可以同时被多个线程同时获取到（使用共享锁的接口见下面的表格）。共享锁通常用在<a href="https://en.wikipedia.org/wiki/Readers%E2%80%93writers_problem">读者写者模型</a>上。</li>
</ul>
<p>使用共享锁的接口如下：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>lock_shared</td>
<td>获取互斥体的共享锁，如果无法获取则阻塞</td>
</tr>
<tr>
<td>try_lock_shared</td>
<td>尝试获取共享锁，如果不可用，直接返回</td>
</tr>
<tr>
<td>unlock_shared</td>
<td>解锁共享锁</td>
</tr>
</tbody></table>
<p>接下来，我们就借助刚学到的<code>mutex</code>来改造我们的并发系统，改造后的程序如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 07_mutex_lock.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">10e8</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> mutex exclusive;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">concurrent_worker</span><span class="params">(<span class="keyword">int</span> min, <span class="keyword">int</span> max)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = min; i &lt;= max; i++) &#123;</span><br><span class="line">    exclusive.<span class="built_in">lock</span>(); <span class="comment">// ①</span></span><br><span class="line">    sum += <span class="built_in">sqrt</span>(i);</span><br><span class="line">    exclusive.<span class="built_in">unlock</span>(); <span class="comment">// ②</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">concurrent_task</span><span class="params">(<span class="keyword">int</span> min, <span class="keyword">int</span> max)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> start_time = chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">unsigned</span> concurrent_count = thread::<span class="built_in">hardware_concurrency</span>();</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;hardware_concurrency: &quot;</span> &lt;&lt; concurrent_count &lt;&lt; endl;</span><br><span class="line">  vector&lt;thread&gt; threads;</span><br><span class="line">  min = <span class="number">0</span>;</span><br><span class="line">  sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t &lt; concurrent_count; t++) &#123;</span><br><span class="line">    <span class="keyword">int</span> range = max / concurrent_count * (t + <span class="number">1</span>);</span><br><span class="line">    threads.<span class="built_in">push_back</span>(<span class="built_in">thread</span>(concurrent_worker, min, range)); <span class="comment">// ③</span></span><br><span class="line">    min = range + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threads.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    threads[i].<span class="built_in">join</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> end_time = chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line">  <span class="keyword">auto</span> ms = chrono::duration_cast&lt;chrono::milliseconds&gt;(end_time - start_time).<span class="built_in">count</span>();</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Concurrent task finish, &quot;</span> &lt;&lt; ms &lt;&lt; <span class="string">&quot; ms consumed, Result: &quot;</span> &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里只有三个地方需要关注：</p>
<ol>
<li>在访问共享数据之前加锁</li>
<li>访问完成之后解锁</li>
<li>在多线程中使用带锁的版本</li>
</ol>
<p>执行之后结果输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hardware_concurrency: 16</span><br><span class="line">Concurrent task finish, 74232 ms consumed, Result: 2.10819e+13</span><br></pre></td></tr></table></figure>

<p>这下结果是对了，但是我们却发现这个版本比原先单线程的版本性能还要差很多。这是为什么？</p>
<p>这是因为加锁和解锁是有代价的，这里计算最耗时的地方在锁里面，每次只能有一个线程串行执行，相比于单线程模型，它不但是串行的，还增加了锁的负担，因此就更慢了。</p>
<p>这就是为什么前面说多线程系统会增加系统的复杂度，而且并非多线程系统一定就有更好的性能。</p>
<p>不过，对于这里的问题是可以改进的。我们仔细思考一下：我们划分给每个线程的数据其实是独立的，对于数据的处理是耗时的，但其实这部分逻辑每个线程可以单独处理，没必要加锁。只有在最后汇总数据的时候进行一次锁保护就可以了。</p>
<p>于是我们改造<code>concurrent_worker</code>，像下面这样：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 08_improved_mutex_lock.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">concurrent_worker</span><span class="params">(<span class="keyword">int</span> min, <span class="keyword">int</span> max)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">double</span> tmp_sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = min; i &lt;= max; i++) &#123;</span><br><span class="line">    tmp_sum += <span class="built_in">sqrt</span>(i); <span class="comment">// ①</span></span><br><span class="line">  &#125;</span><br><span class="line">  exclusive.<span class="built_in">lock</span>(); <span class="comment">// ②</span></span><br><span class="line">  sum += tmp_sum;</span><br><span class="line">  exclusive.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码的改变在于两处：</p>
<ol>
<li>通过一个局部变量保存当前线程的处理结果</li>
<li>在汇总总结过的时候进行锁保护</li>
</ol>
<p>运行一下改进后的程序，其结果输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hardware_concurrency: 16</span><br><span class="line">Concurrent task finish, 451 ms consumed, Result: 2.10819e+13</span><br></pre></td></tr></table></figure>

<p>可以看到，性能一下就提升了好多倍。我们终于体验到多线程带来的好处了。</p>
<p>我们用锁的<strong>粒度</strong>（granularity）来描述锁的范围。<strong>细粒度</strong>（fine-grained）是指锁保护较小的范围，<strong>粗粒度</strong>（coarse-grained）是指锁保护较大的范围。出于性能的考虑，我们应该保证锁的粒度尽可能的细。并且，不应该在获取锁的范围内执行耗时的操作，例如执行IO。如果是耗时的运算，也应该尽可能的移到锁的外面。</p>
<blockquote>
<p>In general, a lock should be held for only the minimum possible time needed to perform the required operations.</p>
<p>–《C++ Concurrency in Action》</p>
</blockquote>
<h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>死锁是并发系统很常见的一类问题。</p>
<p>死锁是指：两个或以上的运算单元，每一方都在等待其他方释放资源，但是所有方都不愿意释放资源。结果是没有任何一方能继续推进下去，于是整个系统无法再继续运转。</p>
<p>死锁在现实中也很常见，例如：两个孩子分别拿着玩具的一半然后哭着要从对方手里得到另外一半玩具，但是谁都不肯让步。</p>
<p>下面我们来看一个编程示例。</p>
<p>现在假设我们在开发一个银行的系统，这个系统包含了转账的功能。</p>
<p>首先我们创建一个<code>Account</code>类来描述银行账号。由于这仅仅是一个演示使用的代码，所以我们希望代码足够的简单。<code>Account</code>类仅仅包含名称和金额两个字段。</p>
<p>另外，为了支持并发，这个类包含了一个<code>mutex</code>对象，用来保护账号金额，在读写账号金额时需要先加锁保护。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 09_deadlock_bank_transfer.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Account</span>(string name, <span class="keyword">double</span> money): <span class="built_in">mName</span>(name), <span class="built_in">mMoney</span>(money) &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">changeMoney</span><span class="params">(<span class="keyword">double</span> amount)</span> </span>&#123;</span><br><span class="line">    mMoney += amount;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">string <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mName;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">double</span> <span class="title">getMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mMoney;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">mutex* <span class="title">getLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;mMoneyLock;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  string mName;</span><br><span class="line">  <span class="keyword">double</span> mMoney;</span><br><span class="line">  mutex mMoneyLock;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>Account</code>类很简单，我想就不用多做说明了。</p>
<p>接下来，我们再创建一个描述银行的<code>Bank</code>类。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 09_deadlock_bank_transfer.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bank</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">addAccount</span><span class="params">(Account* account)</span> </span>&#123;</span><br><span class="line">    mAccounts.<span class="built_in">insert</span>(account);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">transferMoney</span><span class="params">(Account* accountA, Account* accountB, <span class="keyword">double</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="function">lock_guard <span class="title">guardA</span><span class="params">(*accountA-&gt;getLock())</span></span>; <span class="comment">// ①</span></span><br><span class="line">    <span class="function">lock_guard <span class="title">guardB</span><span class="params">(*accountB-&gt;getLock())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (amount &gt; accountA-&gt;<span class="built_in">getMoney</span>()) &#123; <span class="comment">// ②</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    accountA-&gt;<span class="built_in">changeMoney</span>(-amount); <span class="comment">// ③</span></span><br><span class="line">    accountB-&gt;<span class="built_in">changeMoney</span>(amount);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">double</span> <span class="title">totalMoney</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> a : mAccounts) &#123;</span><br><span class="line">      sum += a-&gt;<span class="built_in">getMoney</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  set&lt;Account*&gt; mAccounts;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>银行类中记录了所有的账号，并且提供了一个方法用来查询整个银行的总金额。</p>
<p>这其中，我们最主要要关注转账的实现：<code>transferMoney</code>。该方法的几个关键点如下：</p>
<ol>
<li>为了保证线程安全，在修改每个账号之前，需要获取相应的锁。</li>
<li>判断转出账户金额是否足够，如果不够此次转账失败。</li>
<li>进行转账。</li>
</ol>
<p>有了银行和账户结构之后就可以开发转账系统了，同样的，由于是为了演示所用，我们的转账系统也会尽可能的简单：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 09_deadlock_bank_transfer.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">randomTransfer</span><span class="params">(Bank* bank, Account* accountA, Account* accountB)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">double</span> randomMoney = ((<span class="keyword">double</span>)<span class="built_in">rand</span>() / RAND_MAX) * <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">if</span> (bank-&gt;<span class="built_in">transferMoney</span>(accountA, accountB, randomMoney)) &#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;Transfer &quot;</span> &lt;&lt; randomMoney &lt;&lt; <span class="string">&quot; from &quot;</span> &lt;&lt; accountA-&gt;<span class="built_in">getName</span>()</span><br><span class="line">           &lt;&lt; <span class="string">&quot; to &quot;</span> &lt;&lt; accountB-&gt;<span class="built_in">getName</span>()</span><br><span class="line">           &lt;&lt; <span class="string">&quot;, Bank totalMoney: &quot;</span> &lt;&lt; bank-&gt;<span class="built_in">totalMoney</span>() &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;Transfer failed, &quot;</span></span><br><span class="line">           &lt;&lt; accountA-&gt;<span class="built_in">getName</span>() &lt;&lt; <span class="string">&quot; has only $&quot;</span> &lt;&lt; accountA-&gt;<span class="built_in">getMoney</span>() &lt;&lt; <span class="string">&quot;, but &quot;</span></span><br><span class="line">           &lt;&lt; randomMoney &lt;&lt; <span class="string">&quot; required&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里每次生成一个随机数，然后通过银行进行转账。</p>
<p>最后我们在<code>main</code>函数中创建两个线程，互相在两个账号之间来回转账：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 09_deadlock_bank_transfer.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">Account <span class="title">a</span><span class="params">(<span class="string">&quot;Paul&quot;</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line">  <span class="function">Account <span class="title">b</span><span class="params">(<span class="string">&quot;Moira&quot;</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  Bank aBank;</span><br><span class="line">  aBank.<span class="built_in">addAccount</span>(&amp;a);</span><br><span class="line">  aBank.<span class="built_in">addAccount</span>(&amp;b);</span><br><span class="line"></span><br><span class="line">  <span class="function">thread <span class="title">t1</span><span class="params">(randomTransfer, &amp;aBank, &amp;a, &amp;b)</span></span>;</span><br><span class="line">  <span class="function">thread <span class="title">t2</span><span class="params">(randomTransfer, &amp;aBank, &amp;b, &amp;a)</span></span>;</span><br><span class="line"></span><br><span class="line">  t1.<span class="built_in">join</span>();</span><br><span class="line">  t2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，我们的银行转账系统就开发完成了。然后编译并运行，其结果可能像下面这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">Transfer 13.2901 from Paul to Moira, Bank totalMoney: 20042.6259 from Moira to Paul, Bank totalMoney: 200</span><br><span class="line">Transfer failed, Moira has only $34.7581, but 66.3208 required</span><br><span class="line">Transfer failed, Moira has only $34.7581, but </span><br><span class="line">Transfer 93.191 from 53.9176 required</span><br><span class="line">Transfer 60.6146 from Moira to Paul, Bank totalMoney: 200</span><br><span class="line">Transfer 49.7304 from Moira to Paul, Bank totalMoney: 200Paul to Moira, Bank totalMoney: </span><br><span class="line">Transfer failed, Moira has only $17.6041, but 18.1186 required</span><br><span class="line">Transfer failed, Moira has only $17.6041, but 18.893 required</span><br><span class="line">Transfer failed, Moira has only $17.6041, but 34.7078 required</span><br><span class="line">Transfer failed, Moira has only $17.6041, but 33.9569 required</span><br><span class="line">Transfer 12.7899 from 200</span><br><span class="line">Moira to Paul, Bank totalMoney: 200</span><br><span class="line">Transfer failed, Moira has only $63.9373, but 80.9038 required</span><br><span class="line">Transfer 50.933 from Moira to Paul, Bank totalMoney: 200</span><br><span class="line">Transfer failed, Moira has only $13.0043, but 30.2056 required</span><br><span class="line">Transfer failed, Moira has only $Transfer 59.123 from Paul to Moira, Bank totalMoney: 200</span><br><span class="line">Transfer 29.0486 from Paul to Moira, Bank totalMoney: 20013.0043, but 64.7307 required</span><br></pre></td></tr></table></figure>

<p>如果你运行了这个程序，你会发现很快它就卡住不动了。为什么？</p>
<p>因为发生了死锁。</p>
<p>我们仔细思考一下这两个线程的逻辑：这两个线程可能会同时获取其中一个账号的锁，然后又想获取另外一个账号的锁，此时就发生了死锁。如下图所示：</p>
<p><img src="https://paul-pub.oss-cn-beijing.aliyuncs.com/2019/2019-11-26-cpp-concurrency/deadlock.png" alt="img"></p>
<p>当然，发生死锁的原因远不止上面这一种情况。如果两个线程互相<code>join</code>就可能发生死锁。还有在一个线程中对一个不可重入的互斥体（例如<code>mutex</code>而非<code>recursive_mutex</code>）多次加锁也会死锁。</p>
<p>你可能会觉得，我可不会这么傻，写出这样的代码。但实际上，很多时候是由于代码的深层次嵌套导致了死锁的发生，由于调用关系的复杂导致发现这类问题并不容易。</p>
<p>如果仔细看一下上面的输出，我们会发现还有另外一个问题：这里的输出是乱的。两个线程的输出混杂在一起了。究其原因也很容易理解：两个线程可能会同时输出，没有做好隔离。</p>
<p>下面我们就来逐步解决上面的问题。</p>
<p>对于输出混乱的问题很好解决，专门用一把锁来保护输出逻辑即可：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 10_improved_bank_transfer.cpp</span></span><br><span class="line"></span><br><span class="line">mutex sCoutLock;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">randomTransfer</span><span class="params">(Bank* bank, Account* accountA, Account* accountB)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">double</span> randomMoney = ((<span class="keyword">double</span>)<span class="built_in">rand</span>() / RAND_MAX) * <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">if</span> (bank-&gt;<span class="built_in">transferMoney</span>(accountA, accountB, randomMoney)) &#123;</span><br><span class="line">      sCoutLock.<span class="built_in">lock</span>();</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;Transfer &quot;</span> &lt;&lt; randomMoney &lt;&lt; <span class="string">&quot; from &quot;</span> &lt;&lt; accountA-&gt;<span class="built_in">getName</span>()</span><br><span class="line">          &lt;&lt; <span class="string">&quot; to &quot;</span> &lt;&lt; accountB-&gt;<span class="built_in">getName</span>()</span><br><span class="line">          &lt;&lt; <span class="string">&quot;, Bank totalMoney: &quot;</span> &lt;&lt; bank-&gt;<span class="built_in">totalMoney</span>() &lt;&lt; endl;</span><br><span class="line">      sCoutLock.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      sCoutLock.<span class="built_in">lock</span>();</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;Transfer failed, &quot;</span></span><br><span class="line">           &lt;&lt; accountA-&gt;<span class="built_in">getName</span>() &lt;&lt; <span class="string">&quot; has only &quot;</span> &lt;&lt; accountA-&gt;<span class="built_in">getMoney</span>() &lt;&lt; <span class="string">&quot;, but &quot;</span></span><br><span class="line">           &lt;&lt; randomMoney &lt;&lt; <span class="string">&quot; required&quot;</span> &lt;&lt; endl;</span><br><span class="line">      sCoutLock.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="通用锁定算法"><a href="#通用锁定算法" class="headerlink" title="通用锁定算法"></a>通用锁定算法</h4><ul>
<li>主要API</li>
</ul>
<table>
<thead>
<tr>
<th align="left">API</th>
<th align="left">C++标准</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">lock</td>
<td align="left">C++11</td>
<td align="left">锁定指定的互斥体，若任何一个不可用则阻塞</td>
</tr>
<tr>
<td align="left">try_lock</td>
<td align="left">C++11</td>
<td align="left">试图通过重复调用 try_lock 获得互斥体的所有权</td>
</tr>
</tbody></table>
<p>要避免死锁，需要仔细的思考和设计业务逻辑。</p>
<p>有一个比较简单的原则可以避免死锁，即：对所有的锁进行排序，每次一定要按照顺序来获取锁，不允许乱序。例如：要获取某个玩具，一定要先拿到锁A，再拿到锁B，才能玩玩具。这样就不会死锁了。</p>
<p>这个原则虽然简单，但却不容易遵守。因为数据常常是分散在很多地方的。</p>
<p>不过好消息是，C++ 11标准中为我们提供了一些工具来避免因为多把锁而导致的死锁。我们只要直接调用这些接口就可以了。这个就是上面提到的两个函数。它们都支持传入多个<a href="https://en.cppreference.com/w/cpp/named_req/Lockable">Lockable</a>对象。</p>
<p>接下来我们用它来改造之前死锁的转账系统：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 10_improved_bank_transfer.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">transferMoney</span><span class="params">(Account* accountA, Account* accountB, <span class="keyword">double</span> amount)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">lock</span>(*accountA-&gt;<span class="built_in">getLock</span>(), *accountB-&gt;<span class="built_in">getLock</span>());    <span class="comment">// ①</span></span><br><span class="line">  <span class="function">lock_guard <span class="title">lockA</span><span class="params">(*accountA-&gt;getLock(), adopt_lock)</span></span>;  <span class="comment">// ②</span></span><br><span class="line">  <span class="function">lock_guard <span class="title">lockB</span><span class="params">(*accountB-&gt;getLock(), adopt_lock)</span></span>;  <span class="comment">// ③</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (amount &gt; accountA-&gt;<span class="built_in">getMoney</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  accountA-&gt;<span class="built_in">changeMoney</span>(-amount);</span><br><span class="line">  accountB-&gt;<span class="built_in">changeMoney</span>(amount);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里只改动了3行代码。</p>
<ol>
<li>这里通过<code>lock</code>函数来获取两把锁，标准库的实现会保证不会发生死锁。</li>
<li><code>lock_guard</code>在下面我们还会详细介绍。这里只要知道它会在自身对象生命周期的范围内锁定互斥体即可。创建<code>lock_guard</code>的目的是为了在<code>transferMoney</code>结束的时候释放锁，<code>lockB</code>也是一样。但需要注意的是，这里传递了 <code>adopt_lock</code>表示：现在是已经获取到互斥体了的状态了，不用再次加锁（如果不加<code>adopt_lock</code>就是二次锁定了）。</li>
</ol>
<p>运行一下这个改造后的程序，其输出如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">Transfer failed, Paul has only $1.76243, but 17.5974 required</span><br><span class="line">Transfer failed, Paul has only $1.76243, but 59.2104 required</span><br><span class="line">Transfer failed, Paul has only $1.76243, but 49.6379 required</span><br><span class="line">Transfer failed, Paul has only $1.76243, but 63.6373 required</span><br><span class="line">Transfer failed, Paul has only $1.76243, but 51.8742 required</span><br><span class="line">Transfer failed, Paul has only $1.76243, but 50.0081 required</span><br><span class="line">Transfer failed, Paul has only $1.76243, but 86.1041 required</span><br><span class="line">Transfer failed, Paul has only $1.76243, but 51.3278 required</span><br><span class="line">Transfer failed, Paul has only $1.76243, but 66.5754 required</span><br><span class="line">Transfer failed, Paul has only $1.76243, but 32.1867 required</span><br><span class="line">Transfer failed, Paul has only $1.76243, but 62.0039 required</span><br><span class="line">Transfer failed, Paul has only $1.76243, but 98.7819 required</span><br><span class="line">Transfer failed, Paul has only $1.76243, but 27.046 required</span><br><span class="line">Transfer failed, Paul has only $1.76243, but 62.9155 required</span><br><span class="line">Transfer 98.8478 from Moira to Paul, Bank totalMoney: 200</span><br><span class="line">Transfer 80.0722 from Moira to Paul, Bank totalMoney: 200</span><br><span class="line">Transfer 73.7035 from Moira to Paul, Bank totalMoney: 200</span><br><span class="line">Transfer 34.4476 from Moira to Paul, Bank totalMoney: 200</span><br><span class="line">Transfer failed, Moira has only $10.0142, but 61.3033 required</span><br><span class="line">Transfer failed, Moira has only $10.0142, but 24.5595 required</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>现在这个转账程序会一直运行下去，不会再死锁了。输出也是正常的了。</p>
<h4 id="通用互斥管理"><a href="#通用互斥管理" class="headerlink" title="通用互斥管理"></a>通用互斥管理</h4><ul>
<li>主要API</li>
</ul>
<table>
<thead>
<tr>
<th align="left">API</th>
<th align="left">C++标准</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">lock_guard</td>
<td align="left">C++11</td>
<td align="left">实现严格基于作用域的互斥体所有权包装器</td>
</tr>
<tr>
<td align="left">unique_lock</td>
<td align="left">C++11</td>
<td align="left">实现可移动的互斥体所有权包装器</td>
</tr>
<tr>
<td align="left">shared_lock</td>
<td align="left">C++14</td>
<td align="left">实现可移动的共享互斥体所有权封装器</td>
</tr>
<tr>
<td align="left">scoped_lock</td>
<td align="left">C++17</td>
<td align="left">用于多个互斥体的免死锁 RAII 封装器</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">锁定策略</th>
<th align="left">C++标准</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">defer_lock</td>
<td align="left">C++11</td>
<td align="left">类型为 <code>defer_lock_t</code>，不获得互斥的所有权</td>
</tr>
<tr>
<td align="left">try_to_lock</td>
<td align="left">C++11</td>
<td align="left">类型为<code>try_to_lock_t</code>，尝试获得互斥的所有权而不阻塞</td>
</tr>
<tr>
<td align="left">adopt_lock</td>
<td align="left">C++11</td>
<td align="left">类型为<code>adopt_lock_t</code>，假设调用方已拥有互斥的所有权</td>
</tr>
</tbody></table>
<p>互斥体（<code>mutex</code>相关类）提供了对于资源的保护功能，但是手动的锁定（调用<code>lock</code>或者<code>try_lock</code>）和解锁（调用<code>unlock</code>）互斥体是要耗费比较大的精力的，我们需要精心考虑和设计代码才行。因为我们需要保证，在任何情况下，解锁要和加锁配对，因为假设出现一条路径导致获取锁之后没有正常释放，就会影响整个系统。如果考虑方法还可以会抛出异常，这样的代码写起来会很费劲。</p>
<p>鉴于这个原因，标准库就提供了上面的这些API。它们都使用了叫做RAII的编程技巧，来简化我们手动加锁和解锁的“体力活”。</p>
<p>请看下面的例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// https://en.cppreference.com/w/cpp/thread/lock_guard</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> g_i = <span class="number">0</span>;</span><br><span class="line">std::mutex g_i_mutex;  <span class="comment">// ①</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">safe_increment</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(g_i_mutex)</span></span>;  <span class="comment">// ②</span></span><br><span class="line">  ++g_i;</span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; g_i &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  <span class="comment">// ③</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;main: &quot;</span> &lt;&lt; g_i &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="function">std::thread <span class="title">t1</span><span class="params">(safe_increment)</span></span>; <span class="comment">// ④</span></span><br><span class="line">  <span class="function">std::thread <span class="title">t2</span><span class="params">(safe_increment)</span></span>;</span><br><span class="line"> </span><br><span class="line">  t1.<span class="built_in">join</span>();</span><br><span class="line">  t2.<span class="built_in">join</span>();</span><br><span class="line"> </span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;main: &quot;</span> &lt;&lt; g_i &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码中：</p>
<ol>
<li>全局的互斥体<code>g_i_mutex</code>用来保护全局变量<code>g_i</code></li>
<li>这是一个设计为可以被多线程环境使用的方法。因此需要通过互斥体来进行保护。这里没有调用<code>lock</code>方法，而是直接使用<code>lock_guard</code>来锁定互斥体。</li>
<li>在方法结束的时候，局部变量<code>std::lock_guard&lt;std::mutex&gt; lock</code>会被销毁，它对互斥体的锁定也就解除了。</li>
<li>在多个线程中使用这个方法。</li>
</ol>
<h4 id="RAII"><a href="#RAII" class="headerlink" title="RAII"></a>RAII</h4><p>上面的几个类（<code>lock_guard</code>，<code>unique_lock</code>，<code>shared_lock</code>，<code>scoped_lock</code>）都使用了一个叫做RAII的编程技巧。</p>
<p>RAII全称是Resource Acquisition Is Initialization，直译过来就是：资源获取即初始化。</p>
<p>RAII是一种<a href="http://www.stroustrup.com/bs_faq2.html#finally">C++编程技术</a>，它将必须在使用前请求的资源（例如：分配的堆内存、执行线程、打开的套接字、打开的文件、锁定的互斥体、磁盘空间、数据库连接等——任何存在受限供给中的事物）的生命周期与一个对象的生存周期相绑定。 RAII保证资源可用于任何会访问该对象的函数。它亦保证所有资源在其控制对象的生存期结束时，以获取顺序的逆序释放。类似地，若资源获取失败（构造函数以异常退出），则为已构造完成的对象和基类子对象所获取的所有资源，会以初始化顺序的逆序释放。这有效地利用了语言特性以消除内存泄漏并保证异常安全。</p>
<p>RAII 可总结如下:</p>
<ul>
<li>将每个资源封装入一个类，其中：<ul>
<li>构造函数请求资源，并建立所有类不变式，或在它无法完成时抛出异常，</li>
<li>析构函数释放资源并决不抛出异常；</li>
</ul>
</li>
<li>始终经由 RAII 类的实例使用满足要求的资源，该资源<ul>
<li>自身拥有自动存储期或临时生存期，或</li>
<li>具有与自动或临时对象的生存期绑定的生存期</li>
</ul>
</li>
</ul>
<p>回想一下上文中的<code>transferMoney</code>方法中的三行代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">lock</span>(*accountA-&gt;<span class="built_in">getLock</span>(), *accountB-&gt;<span class="built_in">getLock</span>());</span><br><span class="line"><span class="function">lock_guard <span class="title">lockA</span><span class="params">(*accountA-&gt;getLock(), adopt_lock)</span></span>;</span><br><span class="line"><span class="function">lock_guard <span class="title">lockB</span><span class="params">(*accountB-&gt;getLock(), adopt_lock)</span></span>;</span><br></pre></td></tr></table></figure>

<p>如果使用<code>unique_lock</code>这三行代码还有一种等价的写法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">unique_lock <span class="title">lockA</span><span class="params">(*accountA-&gt;getLock(), defer_lock)</span></span>;</span><br><span class="line"><span class="function">unique_lock <span class="title">lockB</span><span class="params">(*accountB-&gt;getLock(), defer_lock)</span></span>;</span><br><span class="line"><span class="built_in">lock</span>(*accountA-&gt;<span class="built_in">getLock</span>(), *accountB-&gt;<span class="built_in">getLock</span>());</span><br></pre></td></tr></table></figure>

<p>请注意这里<code>lock</code>方法的调用位置。这里先定义<code>unique_lock</code>指定了<code>defer_lock</code>，因此实际没有锁定互斥体，而是到第三行才进行锁定。</p>
<p>最后，借助<code>scoped_lock</code>，我们可以将三行代码合成一行，这种写法也是等价的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">scoped_lock <span class="title">lockAll</span><span class="params">(*accountA-&gt;getLock(), *accountB-&gt;getLock())</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>scoped_lock</code>会在其生命周期范围内锁定互斥体，销毁的时候解锁。同时，它可以锁定多个互斥体，并且避免死锁。</p>
<p>目前，只还有<code>shared_lock</code>我们没有提到。它与其他几个类的区别在于：它是以共享的方式锁定互斥体。</p>
<h4 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h4><table>
<thead>
<tr>
<th align="left">API</th>
<th align="left">C++标准</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">condition_variable</td>
<td align="left">C++ 11</td>
<td align="left">提供与 std::unique_lock 关联的条件变量</td>
</tr>
<tr>
<td align="left">condition_variable_any</td>
<td align="left">C++ 11</td>
<td align="left">提供与任何锁类型关联的条件变量</td>
</tr>
<tr>
<td align="left">notify_all_at_thread_exit</td>
<td align="left">C++ 11</td>
<td align="left">安排到在此线程完全结束时对 notify_all 的调用</td>
</tr>
<tr>
<td align="left">cv_status</td>
<td align="left">C++ 11</td>
<td align="left">列出条件变量上定时等待的可能结果</td>
</tr>
</tbody></table>
<p>至此，我们还有一个地方可以改进。那就是：转账金额不足的时候，程序直接返回了<code>false</code>。这很难说是一个好的策略。因为，即便虽然当前账号金额不足以转账，但只要别的账号又转账进来之后，当前这个转账操作也许就可以继续执行了。</p>
<p>这在很多业务中是很常见的一个需求：每一次操作都要正确执行，如果条件不满足就停下来等待，直到条件满足之后再继续。而不是直接返回。</p>
<p>条件变量提供了一个可以让多个线程间同步协作的功能。这对于<a href="https://en.wikipedia.org/wiki/Producer%E2%80%93consumer_problem">生产者-消费者模型</a>很有意义。在这个模型下：</p>
<ul>
<li>生产者和消费者共享一个工作区。这个区间的大小是有限的。</li>
<li>生产者总是产生数据放入工作区中，当工作区满了。它就停下来等消费者消费一部分数据，然后继续工作。</li>
<li>消费者总是从工作区中拿出数据使用。当工作区中的数据全部被消费空了之后，它也会停下来等待生产者往工作区中放入新的数据。</li>
</ul>
<p>从上面可以看到，无论是生产者还是消费者，当它们工作的条件不满足时，它们并不是直接报错返回，而是停下来等待，直到条件满足。</p>
<p>下面我们就借助于条件变量，再次改造之前的银行转账系统。</p>
<p>这个改造主要在于账号类。我们重点是要调整<code>changeMoney</code>方法。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 11_bank_transfer_wait_notify.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Account</span>(string name, <span class="keyword">double</span> money): <span class="built_in">mName</span>(name), <span class="built_in">mMoney</span>(money) &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">changeMoney</span><span class="params">(<span class="keyword">double</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="function">unique_lock <span class="title">lock</span><span class="params">(mMoneyLock)</span></span>; <span class="comment">// ②</span></span><br><span class="line">    mConditionVar.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>, amount] &#123; <span class="comment">// ③</span></span><br><span class="line">      <span class="keyword">return</span> mMoney + amount &gt; <span class="number">0</span>; <span class="comment">// ④</span></span><br><span class="line">    &#125;);</span><br><span class="line">    mMoney += amount;</span><br><span class="line">    mConditionVar.<span class="built_in">notify_all</span>(); <span class="comment">// ⑤</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">string <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mName;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">double</span> <span class="title">getMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mMoney;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  string mName;</span><br><span class="line">  <span class="keyword">double</span> mMoney;</span><br><span class="line">  mutex mMoneyLock;</span><br><span class="line">  condition_variable mConditionVar; <span class="comment">// ①</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这几处改动说明如下：</p>
<ol>
<li>这里声明了一个条件变量，用来在多个线程之间协作。</li>
<li>这里使用的是<code>unique_lock</code>，这是为了与条件变量相配合。因为条件变量会解锁和重新锁定互斥体。</li>
<li>这里是比较重要的一个地方：通过条件变量进行等待。此时：会通过后面的lambda表达式判断条件是否满足。如果满足则继续；如果不满足，则<strong>此处会解锁互斥体，并让当前线程等待</strong>。<strong>解锁</strong>这一点非常重要，因为只有这样，才能让其他线程获取互斥体。</li>
<li>这里是条件变量等待的条件。如果你不熟悉lambda表达式，请自行网上学习，或者阅读<a href="https://paul.pub/cpp-lambda-function-bind/">我之前写的文章</a>。</li>
<li>此处也很重要。当金额发生变动之后，我们需要通知所有在条件变量上等待的其他线程。此时所有调用<code>wait</code>线程都会再次唤醒，然后尝试获取锁（当然，只有一个能获取到）并再次判断条件是否满足。除了<code>notify_all</code>还有<code>notify_one</code>，它只通知一个等待的线程。<code>wait</code>和<code>notify</code>就构成了线程间互相协作的工具。</li>
</ol>
<p>请注意：<code>wait</code>和<code>notify_all</code>虽然是写在一个函数中的，但是在运行时它们是在多线程环境中执行的，因此对于这段代码，需要能够从不同线程的角度去思考代码的逻辑。这也是开发并发系统比较难的地方。</p>
<p>有了上面的改动之后，银行的转账方法实现起来就很简单了，不用再考虑数据保护的问题了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 11_bank_transfer_wait_notify.cpp</span><br><span class="line"></span><br><span class="line">void Bank::transferMoney(Account* accountA, Account* accountB, double amount) &#123;</span><br><span class="line">    accountA-&gt;changeMoney(-amount);</span><br><span class="line">    accountB-&gt;changeMoney(amount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，转账逻辑也会变得简单，不用再管转账失败的情况发生。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 11_bank_transfer_wait_notify.cpp</span></span><br><span class="line"></span><br><span class="line">mutex sCoutLock;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">randomTransfer</span><span class="params">(Bank* bank, Account* accountA, Account* accountB)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">double</span> randomMoney = ((<span class="keyword">double</span>)<span class="built_in">rand</span>() / RAND_MAX) * <span class="number">100</span>;</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="function">lock_guard <span class="title">guard</span><span class="params">(sCoutLock)</span></span>;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;Try to Transfer &quot;</span> &lt;&lt; randomMoney</span><br><span class="line">           &lt;&lt; <span class="string">&quot; from &quot;</span> &lt;&lt; accountA-&gt;<span class="built_in">getName</span>() &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; accountA-&gt;<span class="built_in">getMoney</span>()</span><br><span class="line">           &lt;&lt; <span class="string">&quot;) to &quot;</span> &lt;&lt; accountB-&gt;<span class="built_in">getName</span>() &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; accountB-&gt;<span class="built_in">getMoney</span>()</span><br><span class="line">           &lt;&lt; <span class="string">&quot;), Bank totalMoney: &quot;</span> &lt;&lt; bank-&gt;<span class="built_in">totalMoney</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    bank-&gt;<span class="built_in">transferMoney</span>(accountA, accountB, randomMoney);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改完之后的程序运行输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">Try to Transfer 13.72 from Moira(10.9287) to Paul(189.071), Bank totalMoney: 200</span><br><span class="line">Try to Transfer 28.6579 from Paul(189.071) to Moira(10.9287), Bank totalMoney: 200</span><br><span class="line">Try to Transfer 91.8049 from Paul(160.413) to Moira(39.5866), Bank totalMoney: 200</span><br><span class="line">Try to Transfer 5.56383 from Paul(82.3285) to Moira(117.672), Bank totalMoney: 200</span><br><span class="line">Try to Transfer 11.3594 from Paul(76.7646) to Moira(123.235), Bank totalMoney: 200</span><br><span class="line">Try to Transfer 16.9557 from Paul(65.4053) to Moira(134.595), Bank totalMoney: 200</span><br><span class="line">Try to Transfer 74.998 from Paul(48.4495) to Moira(151.55), Bank totalMoney: 200</span><br><span class="line">Try to Transfer 65.3005 from Moira(151.55) to Paul(48.4495), Bank totalMoney: 200</span><br><span class="line">Try to Transfer 90.6084 from Moira(86.25) to Paul(113.75), Bank totalMoney: 125.002</span><br><span class="line">Try to Transfer 99.6425 from Moira(70.6395) to Paul(129.36), Bank totalMoney: 200</span><br><span class="line">Try to Transfer 55.2091 from Paul(129.36) to Moira(70.6395), Bank totalMoney: 200</span><br><span class="line">Try to Transfer 92.259 from Paul(74.1513) to Moira(125.849), Bank totalMoney: 200</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>这下比之前都要好了。</p>
<h3 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h3><table>
<thead>
<tr>
<th align="left">API</th>
<th align="left">C++标准</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">async</td>
<td align="left">C++11</td>
<td align="left">异步运行一个函数，并返回保有其结果的<code>std::future</code></td>
</tr>
<tr>
<td align="left">future</td>
<td align="left">C++11</td>
<td align="left">等待被异步设置的值</td>
</tr>
<tr>
<td align="left">packaged_task</td>
<td align="left">C++11</td>
<td align="left">打包一个函数，存储其返回值以进行异步获取</td>
</tr>
<tr>
<td align="left">promise</td>
<td align="left">C++11</td>
<td align="left">存储一个值以进行异步获取</td>
</tr>
<tr>
<td align="left">shared_future</td>
<td align="left">C++11</td>
<td align="left">等待被异步设置的值（可能为其他 future 所引用）</td>
</tr>
</tbody></table>
<p>这一小节中，我们来熟悉更多的可以在并发环境中使用的工具，它们都位于<code>&lt;future&gt;</code>头文件中。</p>
<h4 id="async"><a href="#async" class="headerlink" title="async"></a>async</h4><p>很多语言都提供了异步的机制。异步使得耗时的操作不影响当前主线程的执行流。</p>
<p>在C++11中，<code>async</code>便是完成这样的功能的。下面是一个代码示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 12_async_task.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">10e8</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">worker</span><span class="params">(<span class="keyword">int</span> min, <span class="keyword">int</span> max)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = min; i &lt;= max; i++) &#123;</span><br><span class="line">    sum += <span class="built_in">sqrt</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">auto</span> f1 = <span class="built_in">async</span>(worker, <span class="number">0</span>, MAX);</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Async task triggered&quot;</span> &lt;&lt; endl;</span><br><span class="line">  f1.<span class="built_in">wait</span>();</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Async task finish, result: &quot;</span> &lt;&lt; sum &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这仍然是我们之前熟悉的例子。这里有两个地方需要说明：</p>
<ol>
<li>这里以异步的方式启动了任务。它会返回一个<code>future</code>对象。<code>future</code>用来存储异步任务的执行结果，关于<code>future</code>我们在后面<code>packaged_task</code>的例子中再详细说明。在这个例子中我们仅仅用它来等待任务执行完成。</li>
<li>此处是等待异步任务执行完成。</li>
</ol>
<p>需要注意的是，默认情况下，<code>async</code>是启动一个新的线程，还是以同步的方式（不启动新的线程）运行任务，这一点标准是没有指定的，由具体的编译器决定。如果希望一定要以新的线程来异步执行任务，可以通过<code>launch::async</code>来明确说明。<code>launch</code>中有两个常量：</p>
<ul>
<li><code>async</code>：运行新线程，以异步执行任务。</li>
<li><code>deferred</code>：调用方线程上第一次请求其结果时才执行任务，即惰性求值。</li>
</ul>
<p>除了通过函数来指定异步任务，还可以lambda表达式的方式来指定。如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 12_async_task.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">double</span> result = <span class="number">0</span>;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Async task with lambda triggered, thread: &quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">auto</span> f2 = <span class="built_in">async</span>(launch::async, [&amp;result]() &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Lambda task in thread: &quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= MAX; i++) &#123;</span><br><span class="line">      result += <span class="built_in">sqrt</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  f2.<span class="built_in">wait</span>();</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Async task with lambda finish, result: &quot;</span> &lt;&lt; result &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面这段代码中，我们使用一个lambda表达式来编写异步任务的逻辑，并通过<code>launch::async</code>明确指定要通过独立的线程来执行任务，同时我们打印出了线程的id。</p>
<p>这段代码输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Async task with lambda triggered, thread: 0x11290d5c0</span><br><span class="line">Lambda task in thread: 0x700007aa1000</span><br><span class="line">Async task with lambda finish, result: 2.10819e+13</span><br></pre></td></tr></table></figure>

<p>对于面向对象编程来说，很多时候肯定希望以对象的方法来指定异步任务。下面是一个示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 12_async_task.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Worker</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Worker</span>(<span class="keyword">int</span> min, <span class="keyword">int</span> max): <span class="built_in">mMin</span>(min), <span class="built_in">mMax</span>(max) &#123;&#125; <span class="comment">// ①</span></span><br><span class="line">  <span class="function"><span class="keyword">double</span> <span class="title">work</span><span class="params">()</span> </span>&#123; <span class="comment">// ②</span></span><br><span class="line">    mResult = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = mMin; i &lt;= mMax; i++) &#123;</span><br><span class="line">      mResult += <span class="built_in">sqrt</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mResult;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">double</span> <span class="title">getResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mResult;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> mMin;</span><br><span class="line">  <span class="keyword">int</span> mMax;</span><br><span class="line">  <span class="keyword">double</span> mResult;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">Worker <span class="title">w</span><span class="params">(<span class="number">0</span>, MAX)</span></span>;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Task in class triggered&quot;</span> &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">auto</span> f3 = <span class="built_in">async</span>(&amp;Worker::work, &amp;w); <span class="comment">// ③</span></span><br><span class="line">  f3.<span class="built_in">wait</span>();</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Task in class finish, result: &quot;</span> &lt;&lt; w.<span class="built_in">getResult</span>() &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码有三处需要说明：</p>
<ol>
<li>这里通过一个类来描述任务。这个类是对前面提到的任务的封装。它包含了任务的输入参数，和输出结果。</li>
<li><code>work</code>函数是任务的主体逻辑。</li>
<li>通过<code>async</code>执行任务：这里指定了具体的任务函数以及相应的对象。请注意这里是<code>&amp;w</code>，因此传递的是对象的指针。如果不写<code>&amp;</code>将传入<code>w</code>对象的临时复制。</li>
</ol>
<h4 id="packaged-task"><a href="#packaged-task" class="headerlink" title="packaged_task"></a>packaged_task</h4><p>在一些业务中，我们可能会有很多的任务需要调度。这时我们常常会设计出任务队列和线程池的结构。此时，就可以使用<code>packaged_task</code>来包装任务。</p>
<p><code>packaged_task</code>绑定到一个函数或者可调用对象上。当它被调用时，它就会调用其绑定的函数或者可调用对象。并且，可以通过与之相关联的<code>future</code>来获取任务的结果。调度程序只需要处理<code>packaged_task</code>，而非各个函数。</p>
<p><code>packaged_task</code>对象是一个可调用对象，它可以被封装成一个<code>std::fucntion</code>，或者作为线程函数传递给<code>std::thread</code>，或者直接调用。</p>
<p>下面是一个代码示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 13_packaged_task.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">concurrent_worker</span><span class="params">(<span class="keyword">int</span> min, <span class="keyword">int</span> max)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = min; i &lt;= max; i++) &#123;</span><br><span class="line">    sum += <span class="built_in">sqrt</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">concurrent_task</span><span class="params">(<span class="keyword">int</span> min, <span class="keyword">int</span> max)</span> </span>&#123;</span><br><span class="line">  vector&lt;future&lt;<span class="keyword">double</span>&gt;&gt; results; <span class="comment">// ①</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">unsigned</span> concurrent_count = thread::<span class="built_in">hardware_concurrency</span>();</span><br><span class="line">  min = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; concurrent_count; i++) &#123; <span class="comment">// ②</span></span><br><span class="line">    <span class="function">packaged_task&lt;<span class="title">double</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span>&gt; <span class="title">task</span><span class="params">(concurrent_worker)</span></span>; <span class="comment">// ③</span></span><br><span class="line">    results.<span class="built_in">push_back</span>(task.<span class="built_in">get_future</span>()); <span class="comment">// ④</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> range = max / concurrent_count * (i + <span class="number">1</span>);</span><br><span class="line">    <span class="function">thread <span class="title">t</span><span class="params">(std::move(task), min, range)</span></span>; <span class="comment">// ⑤</span></span><br><span class="line">    t.<span class="built_in">detach</span>();</span><br><span class="line"></span><br><span class="line">    min = range + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;threads create finish&quot;</span> &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; r : results) &#123;</span><br><span class="line">    sum += r.<span class="built_in">get</span>(); <span class="comment">// ⑥</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> start_time = chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">double</span> r = <span class="built_in">concurrent_task</span>(<span class="number">0</span>, MAX);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> end_time = chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line">  <span class="keyword">auto</span> ms = chrono::duration_cast&lt;chrono::milliseconds&gt;(end_time - start_time).<span class="built_in">count</span>();</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Concurrent task finish, &quot;</span> &lt;&lt; ms &lt;&lt; <span class="string">&quot; ms consumed, Result: &quot;</span> &lt;&lt; r &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这段代码中：</p>
<ol>
<li>首先创建一个集合来存储<code>future</code>对象。我们将用它来获取任务的结果。</li>
<li>同样的，根据CPU的情况来创建线程的数量。</li>
<li>将任务包装成<code>packaged_task</code>。请注意，由于<code>concurrent_worker</code>被包装成了任务，我们无法直接获取它的<code>return</code>值。而是要通过<code>future</code>对象来获取。</li>
<li>获取任务关联的<code>future</code>对象，并将其存入集合中。</li>
<li>通过一个新的线程来执行任务，并传入需要的参数。</li>
<li>通过<code>future</code>集合，逐个获取每个任务的计算结果，将其累加。这里<code>r.get()</code>获取到的就是每个任务中<code>concurrent_worker</code>的返回值。</li>
</ol>
<p>为了简单起见，这里的示例只使用了我们熟悉的例子和结构。但在实际上的工程中，调用关系通常更复杂，你可以借助于<code>packaged_task</code>将任务组装成队列，然后通过<a href="https://en.wikipedia.org/wiki/Thread_pool">线程池</a>的方式进行调度：</p>
<p><img src="https://paul-pub.oss-cn-beijing.aliyuncs.com/2019/2019-11-26-cpp-concurrency/Thread_pool.svg" alt="img"></p>
<h4 id="promise与future"><a href="#promise与future" class="headerlink" title="promise与future"></a>promise与future</h4><p>在上面的例子中，<code>concurrent_task</code>的结果是通过<code>return</code>返回的。但在一些时候，我们可能不能这么做：在得到任务结果之后，可能还有一些事情需要继续处理，例如清理工作。</p>
<p>这个时候，就可以将<code>promise</code>与<code>future</code>配对使用。这样就可以将返回结果和任务结束两个事情分开。</p>
<p>下面是对上面代码示例的改写：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 14_promise_future.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">concurrent_worker</span><span class="params">(<span class="keyword">int</span> min, <span class="keyword">int</span> max)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = min; i &lt;= max; i++) &#123;</span><br><span class="line">    sum += <span class="built_in">sqrt</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">concurrent_task</span><span class="params">(<span class="keyword">int</span> min, <span class="keyword">int</span> max, promise&lt;<span class="keyword">double</span>&gt;* result)</span> </span>&#123; <span class="comment">// ①</span></span><br><span class="line">  vector&lt;future&lt;<span class="keyword">double</span>&gt;&gt; results;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">unsigned</span> concurrent_count = thread::<span class="built_in">hardware_concurrency</span>();</span><br><span class="line">  min = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; concurrent_count; i++) &#123;</span><br><span class="line">    <span class="function">packaged_task&lt;<span class="title">double</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span>&gt; <span class="title">task</span><span class="params">(concurrent_worker)</span></span>;</span><br><span class="line">    results.<span class="built_in">push_back</span>(task.<span class="built_in">get_future</span>()); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> range = max / concurrent_count * (i + <span class="number">1</span>);</span><br><span class="line">    <span class="function">thread <span class="title">t</span><span class="params">(std::move(task), min, range)</span></span>;</span><br><span class="line">    t.<span class="built_in">detach</span>();</span><br><span class="line"></span><br><span class="line">    min = range + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;threads create finish&quot;</span> &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; r : results) &#123;</span><br><span class="line">    sum += r.<span class="built_in">get</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  result-&gt;<span class="built_in">set_value</span>(sum); <span class="comment">// ②</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;concurrent_task finish&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> start_time = chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">  promise&lt;<span class="keyword">double</span>&gt; sum; <span class="comment">// ③</span></span><br><span class="line">  <span class="built_in">concurrent_task</span>(<span class="number">0</span>, MAX, &amp;sum);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> end_time = chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line">  <span class="keyword">auto</span> ms = chrono::duration_cast&lt;chrono::milliseconds&gt;(end_time - start_time).<span class="built_in">count</span>();</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Concurrent task finish, &quot;</span> &lt;&lt; ms &lt;&lt; <span class="string">&quot; ms consumed.&quot;</span> &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Result: &quot;</span> &lt;&lt; sum.<span class="built_in">get_future</span>().<span class="built_in">get</span>() &lt;&lt; endl; <span class="comment">// ④</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码和上面的示例在很大程度上是一样的。只有小部分内容做了改动：</p>
<ol>
<li><code>concurrent_task</code>不再直接返回计算结果，而是增加了一个<code>promise</code>对象来存放结果。</li>
<li>在任务计算完成之后，将总结过设置到<code>promise</code>对象上。一旦这里调用了<code>set_value</code>，其相关联的<code>future</code>对象就会就绪。</li>
<li>这里是在<code>main</code>中创建一个<code>promoise</code>来存放结果，并以指针的形式传递进<code>concurrent_task</code>中。</li>
<li>通过<code>sum.get_future().get()</code>来获取结果。第2点中已经说了：一旦调用了<code>set_value</code>，其相关联的<code>future</code>对象就会就绪。</li>
</ol>
<p>需要注意的是，<code>future</code>对象只有被一个线程获取值。并且在调用<code>get()</code>之后，就没有可以获取的值了。如果从多个线程调用<code>get()</code>会出现数据竞争，其结果是未定义的。</p>
<p>如果真的需要在多个线程中获取<code>future</code>的结果，可以使用<code>shared_future</code>。</p>
<h3 id="task-based并发：async-packaged-task-promise"><a href="#task-based并发：async-packaged-task-promise" class="headerlink" title="task based并发：async, packaged_task, promise"></a>task based并发：async, packaged_task, promise</h3><h4 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL; DR"></a>TL; DR</h4><ul>
<li><strong>async</strong>：提供最高层次的抽象。如果你不需要控制线程的运行时机，就选这个。</li>
<li><strong>packaged_task</strong>：抽象层次比<code>async</code>低。如果你需要控制线程的运行时机，且线程执行的结果即目标结果时，选这个。</li>
<li><strong>promise</strong>：抽象层次最低。当你想在线程中设置目标结果的值，选这个。</li>
</ul>
<h4 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h4><p><code>async</code>、<code>packaged_task</code>和<code>promise</code>三者有一个共同点：它们都可以返回一个<code>future</code>对象，用户可以通过这个<code>future</code>的<code>get</code>方法获取最终的结果。</p>
<p>在下面的代码中，分别用这三者实现同样的功能：延时2秒后返回0：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::packaged_task&lt;<span class="title">int</span><span class="params">()</span>&gt; <span class="title">task</span><span class="params">([]()&#123; </span></span></span><br><span class="line"><span class="params"><span class="function">            std::chrono::milliseconds dura( <span class="number">2000</span>  );</span></span></span><br><span class="line"><span class="params"><span class="function">            std::this_thread::sleep_for( dura  );</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">return</span> <span class="number">0</span>; </span></span></span><br><span class="line"><span class="params"><span class="function">            &#125;)</span></span>;</span><br><span class="line">    std::future&lt;<span class="keyword">int</span>&gt; f1 = task.<span class="built_in">get_future</span>();</span><br><span class="line">    std::<span class="built_in">thread</span>(std::<span class="built_in">move</span>(task)).<span class="built_in">detach</span>();</span><br><span class="line"></span><br><span class="line">    std::future&lt;<span class="keyword">int</span>&gt; f2 = std::<span class="built_in">async</span>(std::launch::async, []()&#123; </span><br><span class="line">            std::chrono::milliseconds <span class="built_in">dura</span>( <span class="number">2000</span>  );</span><br><span class="line">            std::this_thread::<span class="built_in">sleep_for</span>( dura  );</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">    std::promise&lt;<span class="keyword">int</span>&gt; p;</span><br><span class="line">    std::future&lt;<span class="keyword">int</span>&gt; f3 = p.<span class="built_in">get_future</span>();</span><br><span class="line">    std::<span class="built_in">thread</span>([](std::promise&lt;<span class="keyword">int</span>&gt; p)&#123; </span><br><span class="line">            std::chrono::milliseconds <span class="built_in">dura</span>( <span class="number">2000</span>  );</span><br><span class="line">            std::this_thread::<span class="built_in">sleep_for</span>( dura  );</span><br><span class="line">            p.<span class="built_in">set_value</span>(<span class="number">0</span>); </span><br><span class="line">            &#125;,</span><br><span class="line">            std::<span class="built_in">move</span>(p)).<span class="built_in">detach</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Waiting...&quot;</span> &lt;&lt; std::flush;</span><br><span class="line">    f1.<span class="built_in">wait</span>();</span><br><span class="line">    f2.<span class="built_in">wait</span>();</span><br><span class="line">    f3.<span class="built_in">wait</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Done!\nResults are: &quot;</span></span><br><span class="line">        &lt;&lt; f1.<span class="built_in">get</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; f2.<span class="built_in">get</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; f3.<span class="built_in">get</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面这段代码可以看到，这三者分别工作在不同的抽象层次上。</p>
<ol>
<li><code>async</code>层次最高，你只需要给它提供一个函数，它就会返回一个<code>future</code>对象。接下来就只需等待结果了。</li>
<li><code>packaged_task</code>次之，你在创建了<code>packaged_task</code>后，还要创建一个<code>thread</code>，并把<code>packaged_task</code>交给它执行。</li>
<li><code>promise</code>就最低了。在创建了<code>thread</code>之后，你还要把对应的<code>promise</code>作为参数传入。这还没完，别忘了在函数中<strong>手动</strong>设置<code>promise</code>的值。</li>
</ol>
<p>那么我们的第一个结论就很清晰了：<code>async</code>抽象层次最高，所以除非你需要对并发过程进行细粒度的控制（比如在一些场合下），优先使用<code>async</code>来执行异步任务。</p>
<p>那么什么属于是“一些场合”呢？</p>
<h4 id="async-VS-packaged-task-and-promise"><a href="#async-VS-packaged-task-and-promise" class="headerlink" title="async VS. packaged_task and promise"></a>async VS. packaged_task and promise</h4><p>前面已经看到，<code>async</code>会接收一个函数，并返回一个<code>future</code>。在默认情况下，该函数会被就地执行。这也许不是你想要的。通过传递<code>std::launch::defer</code>，可以修改为直到调用<code>future.get</code>才开始执行<code>async</code>中的函数。</p>
<p>即使这样，如果你想把执行函数的时机和获取future对象的时机分离，最好还是放弃用<code>async</code>，而是使用更为底层的<code>packaged_task</code>和<code>promise</code>。</p>
<p>BTW，<code>async</code>有一个古怪的特性，如果你把<code>async</code>返回的<code>future</code>赋值给一个临时变量（或者没管它的返回值），当该变量生命周期结束时，程序会一直阻塞直到<code>async</code>中的函数执行完毕。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    std::future&lt;<span class="keyword">int</span>&gt; tmp = std::<span class="built_in">async</span>(std::launch::async, []()&#123; </span><br><span class="line">            std::chrono::milliseconds <span class="built_in">dura</span>(VERY_LONG_TIME);</span><br><span class="line">            std::this_thread::<span class="built_in">sleep_for</span>(dura);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// block here for VERY_LONG_TIME</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种意料之外的行为会在C++14中被取消掉。所以你用的编译器可能不会遇到这问题。</p>
<h4 id="packaged-task-VS-promise"><a href="#packaged-task-VS-promise" class="headerlink" title="packaged_task VS. promise"></a>packaged_task VS. promise</h4><p>剩下的两个之中怎么选呢？</p>
<p><code>promise</code>的层次比<code>packaged_task</code>低，所以<code>promise</code>提供给用户的控制粒度也比<code>packaged_task</code>要细。因此，如果你想要更彻底的控制，就选择<code>promise</code>吧。</p>
<p><code>promise</code>几乎就是<code>future</code>的另一半。对<code>promise</code>调用<code>set_value</code>，就如同对<code>future</code>调用<code>set_value</code>。比起<code>packaged_task</code>，<code>promise</code>并不在意函数的返回值——毕竟它的值需要手动调用<code>set_value</code>进行设置。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>C++11</tag>
        <tag>C++14</tag>
        <tag>C++17</tag>
        <tag>C++并发</tag>
        <tag>学习心得</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL on Qt (3):SQL的MVC结构基础知识总结</title>
    <url>/2020/07/24/mysqlonqt3/</url>
    <content><![CDATA[<h1 id="MySQL-on-Qt-3-SQL的MVC结构基础知识总结"><a href="#MySQL-on-Qt-3-SQL的MVC结构基础知识总结" class="headerlink" title="MySQL on Qt (3): SQL的MVC结构基础知识总结"></a>MySQL on Qt (3): SQL的MVC结构基础知识总结</h1><blockquote>
<p> 写在前面： </p>
<p>大一下学期的 CPP 大作业“自主订餐系统”可真是颇费了一些力气，每天晚睡早起撸代码，课都没听，很多知识都是现学现用。</p>
<p>为了避免当时学到的东西给全部忘光光（`_&gt;`，我这脑子啊。。。），所以我把当时大作业的一些核心部分（一些零碎的小细节，能记就记）给记录一下，一方面是复习，一方面也方便以后用到的时候查阅。</p>
</blockquote>
<p>这篇文章是大作业 MySQL + SQLite 操作相关部分的第三章，主要讲一下 Qt 中 SQL 的 MVC 结构的基础知识，包括一部分的 MVC 原理介绍和基础使用。</p>
<span id="more"></span>

<h2 id="什么是-MVC-结构"><a href="#什么是-MVC-结构" class="headerlink" title="什么是 MVC 结构"></a>什么是 MVC 结构</h2><p>关于 MVC 结构的具体介绍，可以看一个名为《Qt中文文档》的 Github 项目中 Qt 关于 MVC 的官方文档的中文翻译版（这里打个广告=。=）：</p>
<blockquote>
<p>模型/视图 编程</p>
<p><a href="https://www.cryfeifei.cn/2020/08/08/qt-zhong-wen-wen-dang-mo-xing-shi-tu-jian-jie/">https://www.cryfeifei.cn/2020/08/08/qt-zhong-wen-wen-dang-mo-xing-shi-tu-jian-jie/</a></p>
</blockquote>
<p>也可以看上一篇我转载自网络的文章：</p>
<blockquote>
<p>Qt Model/View（模型/视图）结构（无师自通）</p>
<p><a href="http://www.skykeyjoker.com/2020/07/23/model-view/">http://www.skykeyjoker.com/2020/07/23/model-view/</a></p>
</blockquote>
<p>以上两篇网络文章我都转载到了我的博客中。</p>
<p>这里我就不再讲太多太细的知识和原理，只是简单概括一下。</p>
<p>GUI 应用程序的一个很重要的功能是由用户在界面上编辑和修改数据，典型的如数据库应用程序。数据库应用程序中，用户在界面上执行各种操作，实际上是修改了界面组件所关联的数据库内的数据。</p>
<p>Model/View（模型/视图）结构是 Qt 中用界面组件显示与编辑数据的一种结构，视图（View）是显示和编辑数据的界面组件，模型（Model）是视图与原始数据之间的接口。</p>
<p>将界面组件与所编辑的数据分离开来，又通过数据源的方式连接起来，是处理界面与数据的一种较好的方式。Qt 使用 Model/View 结构来处理这种关系，Model/View 的基本结构如图 1 所示。</p>
<p><a href="http://c.biancheng.net/uploads/allimg/190103/2-1Z10316062G22.gif"><img src="http://c.biancheng.net/uploads/allimg/190103/2-1Z10316062G22.gif" alt="Model/View基本结构"></a></p>
<p>其中各部分的功能如下：</p>
<ul>
<li>数据（Data）是实际的数据，如数据库的一个数据表或SQL查询结果，内存中的一个 StringList，或磁盘文件结构等。</li>
<li>视图或视图组件（View）是屏幕上的界面组件，视图从数据模型获得每个数据项的模型索引（model index），通过模型索引获取数据，然后为界面组件提供显示数据。Qt 提供一些现成的数据视图组件，如 QListView、QTreeView 和 QTableView 等。</li>
<li>模型或数据模型（Model）与实际数据通信，并为视图组件提供数据接口。它从原始数据提取需要的内容，用于视图组件进行显示和编辑。Qt 中有一些预定义的数据模型，如 QStringListModel 可作为 StringList 的数据模型，QSqlTableModel 可以作为数据库中一个数据表的数据模型。</li>
</ul>
<h2 id="开启-MVC-之旅"><a href="#开启-MVC-之旅" class="headerlink" title="开启 MVC 之旅"></a>开启 MVC 之旅</h2><p>讲完又臭又长的理论，我们就要进入令人激动的实践啦。</p>
<p>外甥打灯笼，这次我也是写了一个 Demo 来演示具体的应用。</p>
<p><img src="https://gitee.com/skykeyjoker/PicCloud/raw/master/img/QQ%E5%9B%BE%E7%89%8720200724132133.png" alt="demo"></p>
<p>与以往不同，这次会先把全部工程代码贴出来再分块讲。</p>
<p><code>sqlmvcdemo.h</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SQLMVCDEMO_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SQLMVCDEMO_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QHBoxLayout&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QVBoxLayout&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QPushButton&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QLineEdit&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QLabel&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QTableView&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QHeaderView&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QSqlTableModel&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QSqlDatabase&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QSqlError&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QSqlRecord&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">QT_BEGIN_NAMESPACE</span><br><span class="line"><span class="keyword">namespace</span> Ui &#123; <span class="class"><span class="keyword">class</span> <span class="title">SQLMVCDemo</span>;</span> &#125;</span><br><span class="line">QT_END_NAMESPACE</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SQLMVCDemo</span> :</span> <span class="keyword">public</span> QWidget</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SQLMVCDemo</span>(QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line">    ~<span class="built_in">SQLMVCDemo</span>();</span><br><span class="line"></span><br><span class="line">    QVBoxLayout *mainLay;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Sql model/view</span></span><br><span class="line">    QSqlTableModel *_tableModel;</span><br><span class="line">    QTableView *_tableView;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">connectToDb</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::SQLMVCDemo *ui;</span><br><span class="line"></span><br><span class="line">    QSqlDatabase _db = QSqlDatabase::<span class="built_in">addDatabase</span>(<span class="string">&quot;QMYSQL&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// SQLMVCDEMO_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<p><code>sqlmvcdemo.cpp</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;sqlmvcdemo.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ui_sqlmvcdemo.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">SQLMVCDemo::<span class="built_in">SQLMVCDemo</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QWidget</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::SQLMVCDemo)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Instance</span></span><br><span class="line">    mainLay = <span class="keyword">new</span> <span class="built_in">QVBoxLayout</span>(<span class="keyword">this</span>);</span><br><span class="line">    _tableView = <span class="keyword">new</span> QTableView;</span><br><span class="line">    _tableModel = <span class="keyword">new</span> <span class="built_in">QSqlTableModel</span>(<span class="literal">nullptr</span>,_db); <span class="comment">// Construct from allocated Database</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// UI</span></span><br><span class="line">    mainLay-&gt;<span class="built_in">addWidget</span>(_tableView);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Connect to Db</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">connectToDb</span>())</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;Connected sucessfully.&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        QSqlError error = _db.<span class="built_in">lastError</span>();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;Connected failed.&quot;</span>;</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;error.<span class="built_in">text</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Model</span></span><br><span class="line">    _tableModel-&gt;<span class="built_in">setTable</span>(<span class="string">&quot;user&quot;</span>); <span class="comment">// Set table</span></span><br><span class="line">    _tableModel-&gt;<span class="built_in">select</span>();  <span class="comment">// Must ** SELECT ** first!</span></span><br><span class="line">    <span class="comment">//_tableModel-&gt;setEditStrategy(QSqlTableModel::OnManualSubmit);  // Manual submit</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//View</span></span><br><span class="line">    _tableView-&gt;<span class="built_in">setModel</span>(_tableModel);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Init Hearders</span></span><br><span class="line"><span class="comment">    _tableView-&gt;setColumnCount(5);</span></span><br><span class="line"><span class="comment">    _tableView-&gt;setHorizontalHeader(QStringList()&lt;&lt;&quot;ID&quot;&lt;&lt;&quot;Name&quot;);</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set width of cols</span></span><br><span class="line">    _tableView-&gt;<span class="built_in">setColumnWidth</span>(<span class="number">0</span>,<span class="number">100</span>);</span><br><span class="line">    _tableView-&gt;<span class="built_in">setColumnWidth</span>(<span class="number">1</span>,<span class="number">180</span>);</span><br><span class="line">    _tableView-&gt;<span class="built_in">setColumnWidth</span>(<span class="number">2</span>,<span class="number">100</span>);</span><br><span class="line">    _tableView-&gt;<span class="built_in">setColumnWidth</span>(<span class="number">3</span>,<span class="number">220</span>);</span><br><span class="line">    _tableView-&gt;<span class="built_in">setColumnWidth</span>(<span class="number">4</span>,<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Resize with stretch</span></span><br><span class="line">    _tableView-&gt;<span class="built_in">horizontalHeader</span>()-&gt;<span class="built_in">setSectionResizeMode</span>(<span class="number">3</span>,QHeaderView::Stretch);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Color varies in rows</span></span><br><span class="line">    _tableView-&gt;<span class="built_in">setAlternatingRowColors</span>(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Some propertis of view</span></span><br><span class="line"><span class="comment">    _tableView-&gt;setSelectionBehavior(QAbstractItemView::SelectRows);  // SelectRows</span></span><br><span class="line"><span class="comment">    _tableView-&gt;setSelectionMode(QAbstractItemView::SingleSelection); // SingleSelection</span></span><br><span class="line"><span class="comment">    _tableView-&gt;setEditTriggers(QAbstractItemView::NoEditTriggers);  // NoEditTriggers</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SQLMVCDemo::~<span class="built_in">SQLMVCDemo</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SQLMVCDemo::connectToDb</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    _db.<span class="built_in">setHostName</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    _db.<span class="built_in">setPort</span>(<span class="number">3306</span>);</span><br><span class="line">    _db.<span class="built_in">setDatabaseName</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    _db.<span class="built_in">setUserName</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    _db.<span class="built_in">setPassword</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> ret = _db.<span class="built_in">open</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Model-View-相关的类"><a href="#Model-View-相关的类" class="headerlink" title="Model/View 相关的类"></a>Model/View 相关的类</h3><p>demo 头文件<code>sqlmvcdemo.h</code>比较重要的部分是头文件<code>include</code>部分，这涉及了 Qt 中 MVC 相关的类。</p>
<p>Qt 中 MVC 结构相关类列表如下：</p>
<p><img src="http://c.biancheng.net/uploads/allimg/190103/2-1Z103160KBJ.gif" alt="Qt中模型类的层次结构"></p>
<p><img src="http://c.biancheng.net/uploads/allimg/190103/2-1Z103160934132.gif" alt="视图相关类的层次结构图"></p>
<p>从图里列出的类名基本上就能推测出我们要用到哪些类：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QTableView&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QHeaderView&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QSqlTableModel&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>其中 <code>QHeaderView</code> 类比较特殊，看起来与我们要使用的 SQL 毫不相关对不对。但其实它作用很大，到后面用到的时候再来说一说。</p>
<hr>
<h3 id="SQL-Model-View-绑定"><a href="#SQL-Model-View-绑定" class="headerlink" title="SQL Model/View 绑定"></a>SQL Model/View 绑定</h3><p>正如前面所说，Model 作为数据模型为操作数据提供了相关接口，因而在使相关 Model 时我们要绑定到具体的数据上。在我们这次使用的 SQL MVC 模型中，就是要把 <code>QSqlTableModel</code> 与 <code>QSqlDatabase</code> 对象绑定。所以便有了如下实例化代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">_tableModel = <span class="keyword">new</span> <span class="built_in">QSqlTableModel</span>(<span class="literal">nullptr</span>,_db); <span class="comment">// Construct from allocated Database</span></span><br></pre></td></tr></table></figure>

<p>这样待绑定的数据库连接后，<code>QSqlTableModel</code>对象就可以对数据库进行相关操作了。</p>
<p>这里要注意一下<code>QSqlTableModel</code>模型指定一个表后，还要执行一下<code>QSqlTableModel::select()</code>函数才能选中表中的数据。 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Model</span></span><br><span class="line">_tableModel-&gt;<span class="built_in">setTable</span>(<span class="string">&quot;user&quot;</span>); <span class="comment">// Set table</span></span><br><span class="line">_tableModel-&gt;<span class="built_in">select</span>();  <span class="comment">// Must ** SELECT ** first!</span></span><br></pre></td></tr></table></figure>

<p>关于数据模型我们还要考虑一个小细节：<strong>用户提交策略</strong></p>
<p>一般情况下，用户完成数据编辑后，会有两种提交策略：</p>
<ul>
<li>自动提交（默认），即编辑完数据（ dataChanged() ）后，数据模型自动提交。</li>
<li>手动提交，即编辑完数据后，需手动调用提交函数方能提交用户数据修改。</li>
</ul>
<p>若要设置为手动模式，我们需要对 Model 进行如下设置：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">_tableModel-&gt;<span class="built_in">setEditStrategy</span>(QSqlTableModel::OnManualSubmit); <span class="comment">// Manual submit</span></span><br></pre></td></tr></table></figure>

<p>并在相应位置手动调用该函数提交：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">_tableModel-&gt;<span class="built_in">submitAll</span>()</span><br></pre></td></tr></table></figure>

<hr>
<p>前面也说过，View 是视图结构，与数据模型绑定，为用户操作提供相应的接口，并将用户操作具体应用到数据模型，数据模型再将操作实际应用到数据中。在我们这次使用的 SQL MVC 模型中，就是要把 <code>QTableView</code> 与 <code>QSqlTableModel</code>绑定。所以便有以下代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">_tableView-&gt;<span class="built_in">setModel</span>(_tableModel);</span><br></pre></td></tr></table></figure>

<p>对 View 控件的设置，主要包括以下方面：</p>
<ul>
<li>表头设置</li>
<li>编辑策略</li>
<li>代理</li>
</ul>
<h4 id="View-表头设置"><a href="#View-表头设置" class="headerlink" title="View 表头设置"></a>View 表头设置</h4><p>先来讲一下 View 控件表头的设置。</p>
<p>还记得前面提到的<code>QHeaderView</code>类嘛？这里对表头的各种设置，就必须引用该类。</p>
<p>首先是设置表头，这里以水平表头为例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Init Hearders</span></span><br><span class="line">_tableView-&gt;<span class="built_in">setColumnCount</span>(<span class="number">5</span>);</span><br><span class="line">_tableView-&gt;<span class="built_in">setHorizontalHeader</span>(<span class="built_in">QStringList</span>()&lt;&lt;<span class="string">&quot;ID&quot;</span>&lt;&lt;<span class="string">&quot;Name&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>然后我们肯定会遇到要设置某一列宽度的情况：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Set width of cols</span></span><br><span class="line">_tableView-&gt;<span class="built_in">setColumnWidth</span>(<span class="number">0</span>,<span class="number">100</span>);</span><br><span class="line">_tableView-&gt;<span class="built_in">setColumnWidth</span>(<span class="number">1</span>,<span class="number">180</span>);</span><br><span class="line">_tableView-&gt;<span class="built_in">setColumnWidth</span>(<span class="number">2</span>,<span class="number">100</span>);</span><br><span class="line">_tableView-&gt;<span class="built_in">setColumnWidth</span>(<span class="number">3</span>,<span class="number">220</span>);</span><br><span class="line">_tableView-&gt;<span class="built_in">setColumnWidth</span>(<span class="number">4</span>,<span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<p>当然，我们还能设置某一列的宽度随着界面缩放比例而改变（建议开启该选项，这样才能让表格占满 View 控件，美观度++）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Resize with stretch</span></span><br><span class="line">_tableView-&gt;<span class="built_in">horizontalHeader</span>()-&gt;<span class="built_in">setSectionResizeMode</span>(<span class="number">3</span>,QHeaderView::Stretch);</span><br></pre></td></tr></table></figure>

<p>再来设置一下让数据按行交替现实不同的颜色：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Color varies in rows</span></span><br><span class="line">_tableView-&gt;<span class="built_in">setAlternatingRowColors</span>(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="编辑策略"><a href="#编辑策略" class="headerlink" title="编辑策略"></a>编辑策略</h4><p>按行选中而不是按单元格选中：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">_tableView-&gt;<span class="built_in">setSelectionBehavior</span>(QAbstractItemView::SelectRows);  <span class="comment">// SelectRows</span></span><br></pre></td></tr></table></figure>

<p>单选：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">_tableView-&gt;<span class="built_in">setSelectionMode</span>(QAbstractItemView::SingleSelection); <span class="comment">// SingleSelection</span></span><br></pre></td></tr></table></figure>

<p>只读：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">_tableView-&gt;<span class="built_in">setEditTriggers</span>(QAbstractItemView::NoEditTriggers);  <span class="comment">// NoEditTriggers</span></span><br></pre></td></tr></table></figure>

<h4 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h4><p>例如本 Demo 中的 Gender 项，我想编辑的时候出现一个“男生|女生”的下拉框而不是仅仅出现一个0或1的编辑框，这个时候我们就需要使用代理。</p>
<p>代理这里先卖一个关子。</p>
<p>好吧其实不是卖关子，而是太长了实在是不想在这一章讲了。。。</p>
<p>代理是一个很庞大的部分，我打算在下一章讲一些皮毛的东西。</p>
<hr>
<p>到这里本章的内容基本上就结束了，下一章我会讲一下代理最为皮毛的一些原理和应用。</p>
<blockquote>
<p>Qt Model/View（模型/视图）结构（无师自通）</p>
<p><a href="http://www.skykeyjoker.com/2020/07/23/model-view/">http://www.skykeyjoker.com/2020/07/23/model-view/</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>Qt</tag>
        <tag>Sql</tag>
        <tag>Model/View</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt Model/View（模型/视图）结构（无师自通）</title>
    <url>/2020/07/23/model-view/</url>
    <content><![CDATA[<h1 id="Qt-Model-View（模型-视图）结构（无师自通）"><a href="#Qt-Model-View（模型-视图）结构（无师自通）" class="headerlink" title="Qt Model/View（模型/视图）结构（无师自通）"></a>Qt Model/View（模型/视图）结构（无师自通）</h1><blockquote>
<p>本文转载自：</p>
<p><a href="http://c.biancheng.net/view/1864.html">http://c.biancheng.net/view/1864.html</a></p>
</blockquote>
<p>Model/View（模型/视图）结构是 <a href="http://c.biancheng.net/qt/">Qt</a> 中用界面组件显示与编辑数据的一种结构，视图（View）是显示和编辑数据的界面组件，模型（Model）是视图与原始数据之间的接口。</p>
<p>GUI 应用程序的一个很重要的功能是由用户在界面上编辑和修改数据，典型的如数据库应用程序。数据库应用程序中，用户在界面上执行各种操作，实际上是修改了界面组件所关联的数据库内的数据。</p>
<p>将界面组件与所编辑的数据分离开来，又通过数据源的方式连接起来，是处理界面与数据的一种较好的方式。Qt 使用 Model/View 结构来处理这种关系，Model/View 的基本结构如图 1 所示。</p>
<p><img src="http://c.biancheng.net/uploads/allimg/190103/2-1Z10316062G22.gif" alt="Model/View基本结构"></p>
<span id="more"></span>

<p>其中各部分的功能如下：</p>
<ul>
<li>数据（Data）是实际的数据，如数据库的一个数据表或SQL查询结果，内存中的一个 StringList，或磁盘文件结构等。</li>
<li>视图或视图组件（View）是屏幕上的界面组件，视图从数据模型获得每个数据项的模型索引（model index），通过模型索引获取数据，然后为界面组件提供显示数据。Qt 提供一些现成的数据视图组件，如 QListView、QTreeView 和 QTableView 等。</li>
<li>模型或数据模型（Model）与实际数据通信，并为视图组件提供数据接口。它从原始数据提取需要的内容，用于视图组件进行显示和编辑。Qt 中有一些预定义的数据模型，如 QStringListModel 可作为 StringList 的数据模型，QSqlTableModel 可以作为数据库中一个数据表的数据模型。</li>
</ul>
<p>由于数据源与显示界面通过 Model/View 结构分离开来，因此可以将一个数据模型在不同的视图中显示，也可以在不修改数据模型的情况下，设计特殊的视图组件。</p>
<p>在 Model/View 结构中，还提供了代理（Delegate）功能，代理功能可以让用户定制数据的界面显示和编辑方式。在标准的视图组件中，代理功能显示一个数据，当数据被编辑时，代理通过模型索引与数据模型通信，并为编辑数据提供一个编辑器，一般是一个 QLineEdit 组件。</p>
<p>模型、视图和代理之间使用信号和槽通信。当源数据发生变化时，数据模型发射信号通知视图组件；当用户在界面上操作数据时，视图组件发射信号表示这些操作信息；当编辑数据时，代理发射信号告知数据模型和视图组件编辑器的状态。</p>
<h2 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h2><p>所有的基于项数据的数据模型（Model）都是基于 QAbstractltemModel 类的，这个类定义了视图组件和代理存取数据的接口。数据无需存储在数据模型里，数据可以是其他类、文件、数据库或任何数据源。</p>
<p>Qt 中与数据模型相关的几个主要的类的层次结构如图 2 所示：</p>
<p><img src="http://c.biancheng.net/uploads/allimg/190103/2-1Z103160KBJ.gif" alt="Qt中模型类的层次结构"></p>
<p>图 2 中的抽象类是不能直接使用的，需要由子类继承来实现一些纯虚函数。Qt 提供了一些模型类用于项数据处理，常见的几个见表 3。</p>
<table>
<thead>
<tr>
<th>Model 类</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>QStringListModel</td>
<td>用于处理字符串列表数据的数据模型类</td>
</tr>
<tr>
<td>QStandardltemModel</td>
<td>标准的基于项数据的数据模型类，每个项数据可以是任何数据类型</td>
</tr>
<tr>
<td>QFileSy stemModel</td>
<td>计算机上文件系统的数据模型类</td>
</tr>
<tr>
<td>QSortFilterProxyModel</td>
<td>与其他数据模型结合，提供排序和过滤功能的数据模型类</td>
</tr>
<tr>
<td>QSqlQueryModel</td>
<td>用于数据库SQL查询结果的数据模型类</td>
</tr>
<tr>
<td>QSqlTableModel</td>
<td>用于数据库的一个数据表的数据模型类</td>
</tr>
<tr>
<td>QSqlRelationalTableModel</td>
<td>用于关系型数据表的数据模型类</td>
</tr>
</tbody></table>
<p>数据库相关的 3 个模型类将在介绍数据库编程时专门说明。如果这些现有的模型类无法满足需求，用户可以从 QAbstractltemModel、QAbstractListModel 或 QAbstractTableModel 继承，生成自己定制的数据模型类。</p>
<h2 id="视图组件"><a href="#视图组件" class="headerlink" title="视图组件"></a>视图组件</h2><p>视图组件（View）就是显示数据模型的数据的界面组件，Qt 提供的视图组件如下：</p>
<ul>
<li>QListView：用于显示单列的列表数据，适用于一维数据的操作。</li>
<li>QTreeView：用于显示树状结构数据，适用于树状结构数据的操作。</li>
<li>QTableView：用于显示表格状数据，适用于二维表格型数据的操作。</li>
<li>QColumnView：用多个QListView显示树状层次结构，树状结构的一层用一个QListView显示。</li>
<li>QHeaderView：提供行表头或列表头的视图组件，如QTableView的行表头和列表头。</li>
</ul>
<p>视图组件在显示数据时，只需调用视图类的 setModel() 函数，为视图组件设置一个数据模型就可以实现视图组件与数据模型之间的关联，在视图组件上的修改将自动保存到关联的数据模型里，一个数据模型可以同时在多个视图组件里显示数据。</p>
<p>前面介绍了 QListWidget、QTreeWidget 和 QtableWidget 3个可用于数据编辑的组件。这 3 个类称为便利类（convenience classes），它们分别是 3 个视图类的子类，其层次关系如图 4 所示。</p>
<p><img src="http://c.biancheng.net/uploads/allimg/190103/2-1Z103160934132.gif" alt="视图相关类的层次结构图"></p>
<p>用于 Model/View 结构的几个视图类直接从 QAbstract ItemView 继承而来，而便利类则从相应的视图类继承而来。</p>
<p>视图组件类的数据采用单独的数据模型，视图组件不存储数据。便利类则为组件的每个节点或单元格创建一个项（item），用项存储数据、格式设置等。所以，便利类没有数据模型，它实际上是用项的方式集成了数据模型的功能，这样就将界面与数据绑定了。</p>
<p>所以，便利类缺乏对大型数据源进行灵活处理的能力，适用于小型数据的显示和编辑。</p>
<h2 id="代理（Delegate）"><a href="#代理（Delegate）" class="headerlink" title="代理（Delegate）"></a>代理（Delegate）</h2><p>代理就是在视图组件上为编辑数据提供编辑器，如在表格组件中编辑一个单元格的数据时，缺省是使用一个 QLineEdit 编辑框。代理负责从数据模型获取相应的数据，然后显示在编辑器里，修改数据后，又将其保存到数据模型中。</p>
<p>QAbstractltemDelegate 是所有代理类的基类，作为抽象类，它不能直接使用。它的一个子类 QStyledltemDelegate，是 Qt 的视图组件缺省使用的代理类。</p>
<p>对于一些特殊的数据编辑需求，例如只允许输入整型数，使用一个 QSpinBox 作为代理组件更恰当，从列表中选择数据时使用一个 QComboBox 作为代理组件更好。这时，就可以从 QStyledltemDelegate 继承创建自定义代理类。</p>
<h2 id="Model-View结构的一些概念"><a href="#Model-View结构的一些概念" class="headerlink" title="Model/View结构的一些概念"></a>Model/View结构的一些概念</h2><p>在 Model/View 结构中，数据模型为视图组件和代理提供存取数据的标准接口。在 Qt 中，所有的数据模型类都从 QAbstractltemModel 继承而来，不管底层的<a href="http://c.biancheng.net/data_structure/">数据结构</a>是如何组织数据的，QAbstractltemModel 的子类都以表格的层次结构表示数据，视图组件通过这种规则来存取模型中的数据，但是表现给用户的形式不一样。</p>
<p><img src="http://c.biancheng.net/uploads/allimg/190103/2-1Z1031610455L.gif" alt="数据模型的几种表现形式"></p>
<p>图 5 是数据模型的 3 种常见表现形式。不管数据模型的表现形式是怎么样的，数据模型中存储数据的基本单元都是项（item），每个项有一个行号、一个列号，还有一个父项。在列表和表格模式下，所有的项都有一个相同的顶层项；在树状结构中，行号、列号、父项稍微复杂一点，但是由这 3 个参数完全可以定义一个项的位置，从而存取项的数据。</p>
<h4 id="模型索引（model-index）"><a href="#模型索引（model-index）" class="headerlink" title="模型索引（model index）"></a>模型索引（model index）</h4><p>为了保证数据的表示与数据存取方式隔离，数据模型中引入了模型索引的概念。通过数据模型存取的每个数据都有一个模型索引，视图组件和代理都通过模型索引来获取数据。</p>
<p>QModelIndex 表示模型索引的类。模型索引提供数据存取的一个临时指针，用于通过数据模型提取或修改数据。因为模型内部组织数据的结构随时可能改变，所以模型索引是临时的。如果需要使用持久性的模型索引，则要使用 QPersistentModelIndex 类。</p>
<h4 id="行号和列号"><a href="#行号和列号" class="headerlink" title="行号和列号"></a>行号和列号</h4><p>数据模型的基本形式是用行和列定义的表格数据，但这并不意味着底层的数据是用二维数组存储的，使用行和列只是为了组件之间交互方便的一种规定。通过模型索引的行号和列号就可以存取数据。</p>
<p>要获得一个模型索引，必须提供 3 个参数：行号、列号、父项的模型索引。例如，对于如图 5 中的表格数据模型中的 3 个数据项 A、B、C，获取其模型索引的代码是：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QModelIndex indexA = model-&gt;<span class="built_in">index</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="built_in">QModelIndex</span>());</span><br><span class="line">QModelIndex indexB = model-&gt;<span class="built_in">index</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="built_in">QModelIndex</span>());</span><br><span class="line">QModelIndex indexC = model-&gt;<span class="built_in">index</span>(<span class="number">2</span>, <span class="number">1</span>, <span class="built_in">QModelIndex</span>());</span><br></pre></td></tr></table></figure>

<p>在创建模型索引的函数中需要传递行号、列号和父项的模型索引。对于列表和表格模式的数据模型，顶层节点总是用 QModelIndex() 表示。</p>
<h4 id="父项"><a href="#父项" class="headerlink" title="父项"></a>父项</h4><p>当数据模型是列表或表格时，使用行号、列号存储数据比较直观，所有数据项的父项就是顶层项；当数据模型是树状结构时，情况比较复杂（树状结构中，项一般习惯于称为节点），一个节点可以有父节点，也可以是其他节点的父节点，在构造数据项的模型索引时，必须指定正确的行号、列号和父节点。</p>
<p>对于图 5 中的树状数据模型，节点 A 和节点 C 的父节点是顶层节点，获取模型索引的代码是：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QModelIndex indexA = model-&gt;<span class="built_in">index</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="built_in">QModelIndex</span>());</span><br><span class="line">QModelIndex indexC = model-&gt;<span class="built_in">index</span>(<span class="number">2</span>, <span class="number">1</span>, <span class="built_in">QModelIndex</span>());</span><br></pre></td></tr></table></figure>

<p>但是，节点 B 的父节点是节点 A，节点 B 的模型索引由下面的代码生成：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QModelIndex indexB = model-&gt;<span class="built_in">index</span>(<span class="number">1</span>, <span class="number">0</span>, indexA);</span><br></pre></td></tr></table></figure>



<h4 id="项的角色"><a href="#项的角色" class="headerlink" title="项的角色"></a>项的角色</h4><p>在为数据模型的一个项设置数据时，可以赋予其不同项的角色的数据。例如，数据模型类 QStandardItemModel 的项数据类是 QStandardItem，其设置数据的函数是：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QStandardItem::setData</span><span class="params">(<span class="keyword">const</span> QVariant &amp;value, <span class="keyword">int</span> role= Qt::UserRole + <span class="number">1</span>)</span></span></span><br></pre></td></tr></table></figure>

<p>其中，value 是需要设置的数据，role 是设置数据的角色。一个项可以有不同角色的数据，用于不同的场合。</p>
<p>role 是 <code>Qt::ItemDataRole</code> 枚举类型，有多种取值，如 <code>Qt::DisplayRole</code> 角色是在视图组件中显示的字符串，<code>Qt::ToolTipRole</code> 是鼠标提示消息，<code>Qt::UserRole</code> 可以自定义数据。项的标准角色是 <code>Qt::DisplayRole</code>。</p>
<p>在获取一个项的数据时也需要指定角色，以获取不同角色的数据：</p>
<p><code>QVariant QStandardItem::data(int role = Qt::UserRole + 1) const</code></p>
<p>为一个项的不同角色定义数据，可以告知视图组件和代理组件如何显示数据。例如，在图 6 中，项的 DisplayRole 数据是显示的字符串，DecorationRole 是用于装饰显示的属性，ToolTipRole 定义了鼠标提示信息。不同的视图组件对各种角色数据的解释和显示可能不一样，也可能忽略某些角色的数据。</p>
<p><img src="http://c.biancheng.net/uploads/allimg/190103/2-1Z103161340927.gif" alt="不同角色数据的表现形式"></p>
]]></content>
      <categories>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>Qt</tag>
        <tag>转载</tag>
        <tag>Model/View</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL on Qt (2):SQL的连接、断开与增删查改基本操作</title>
    <url>/2020/07/23/mysqlonqt2/</url>
    <content><![CDATA[<h1 id="MySQL-on-Qt-2-SQL的连接、断开与增删查改基本操作"><a href="#MySQL-on-Qt-2-SQL的连接、断开与增删查改基本操作" class="headerlink" title="MySQL on Qt (2): SQL的连接、断开与增删查改基本操作"></a>MySQL on Qt (2): SQL的连接、断开与增删查改基本操作</h1><blockquote>
<p>写在前面： </p>
<p>大一下学期的 CPP 大作业“自主订餐系统”可真是颇费了一些力气，每天晚睡早起撸代码，课都没听，很多知识都是现学现用。</p>
<p>为了避免当时学到的东西给全部忘光光（`_&gt;`，我这脑子啊。。。），所以我把当时大作业的一些核心部分（一些零碎的小细节，能记就记）给记录一下，一方面是复习，一方面也方便以后用到的时候查阅。</p>
</blockquote>
<p>这篇文章是大作业 MySQL + SQLite 操作相关部分的第二章，主要讲一下 Qt 中 MySQL 和 SQLite 连接、断开与增删查改的基本操作。</p>
<span id="more"></span>

<h2 id="Qt-SQL-类"><a href="#Qt-SQL-类" class="headerlink" title="Qt SQL 类"></a>Qt SQL 类</h2><p><img src="https://gitee.com/skykeyjoker/PicCloud/raw/master/img/sqlmoudles.png" alt="Qt 中 SQl 相关类"></p>
<ul>
<li>用户接口层：实现将数据库中的数据链接到窗口部件上</li>
<li>SQL接口层：提供对数据库的访问</li>
<li>驱动层：为具体的数据库和SQL接口层之间提供了底层的桥梁</li>
</ul>
<p>要使用Qt SQL的类，需要在项目文件（.pro文件）中添加：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">QT += sql</span><br></pre></td></tr></table></figure>



<h2 id="Qt-SQL-的连接、断开与增删查改操作"><a href="#Qt-SQL-的连接、断开与增删查改操作" class="headerlink" title="Qt SQL 的连接、断开与增删查改操作"></a>Qt SQL 的连接、断开与增删查改操作</h2><p>下面用一个 demo 来演示 Qt 中 SQL 的连接、断开与增删查改操作。</p>
<img src="https://gitee.com/skykeyjoker/PicCloud/raw/master/img/demo.png" alt="demo" style="zoom:80%;" />



<hr>
<p>先来讲数据库的连接与断开。</p>
<h3 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h3><p>上一章已经讲过如何连接 SQL 数据库，这里就简简单单放一下代码。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Connect to db</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Widget::connectToDb</span><span class="params">(<span class="keyword">const</span> QString &amp; hostName, <span class="keyword">const</span> <span class="keyword">int</span> &amp; port, <span class="keyword">const</span> QString &amp; databaseName, <span class="keyword">const</span> QString &amp; username, <span class="keyword">const</span> QString &amp; password)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;hostName;</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;port;</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;databaseName;</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;username;</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;password;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set info</span></span><br><span class="line">    _db.<span class="built_in">setHostName</span>(hostName);</span><br><span class="line">    _db.<span class="built_in">setPort</span>(port);</span><br><span class="line">    _db.<span class="built_in">setDatabaseName</span>(databaseName);</span><br><span class="line">    _db.<span class="built_in">setUserName</span>(username);</span><br><span class="line">    _db.<span class="built_in">setPassword</span>(password);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Open Db</span></span><br><span class="line">    <span class="keyword">bool</span> ret = _db.<span class="built_in">open</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Error Info</span></span><br><span class="line">    QSqlError error = _db.<span class="built_in">lastError</span>();</span><br><span class="line">    <span class="keyword">if</span>(error.<span class="built_in">type</span>() != QSqlError::NoError)</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;error.<span class="built_in">text</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里要注意下打印出错信息的技巧，这样可以方便查错。</p>
<h3 id="断开数据库"><a href="#断开数据库" class="headerlink" title="断开数据库"></a>断开数据库</h3><p>啊这，更简单：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Close Db</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Widget::closeDb</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    _db.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<p>接下来讲数据库的增删查改操作。这些操作主要是对 Query 语句的简单利用。</p>
<p><strong>注意：</strong> MySQL 与 SQLite 的 SQL 语法存在一定区别，要注意区分使用。</p>
<h3 id="创建数据表"><a href="#创建数据表" class="headerlink" title="创建数据表"></a>创建数据表</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Create Table</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Widget::createTable</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Query</span></span><br><span class="line">    QSqlQuery query;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create table</span></span><br><span class="line">    query.<span class="built_in">exec</span>(<span class="string">&quot;CREATE TABLE `runoob_tbl` \</span></span><br><span class="line"><span class="string">                   (`runoob_id` INT UNSIGNED AUTO_INCREMENT, \</span></span><br><span class="line"><span class="string">                   `runoob_title` VARCHAR(100) NOT NULL,\</span></span><br><span class="line"><span class="string">                   `runoob_author` VARCHAR(40) NOT NULL,\</span></span><br><span class="line"><span class="string">                   `submission_date` DATE,\</span></span><br><span class="line"><span class="string">                   PRIMARY KEY ( `runoob_id`)) &quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Error Info</span></span><br><span class="line">    QSqlError error = _db.<span class="built_in">lastError</span>();</span><br><span class="line">    <span class="keyword">if</span>(error.<span class="built_in">type</span>() != QSqlError::NoError)</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;error.<span class="built_in">text</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="增加字段"><a href="#增加字段" class="headerlink" title="增加字段"></a>增加字段</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Add new column</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Widget::addNewcolumn</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Query</span></span><br><span class="line">    QSqlQuery query;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add column</span></span><br><span class="line">    query.<span class="built_in">exec</span>(<span class="string">&quot;ALTER TABLE runoob_tbl ADD COLUMN new1 VARCHAR(20) DEFAULT NULL;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Error Info</span></span><br><span class="line">    QSqlError error = _db.<span class="built_in">lastError</span>();</span><br><span class="line">    <span class="keyword">if</span>(error.<span class="built_in">type</span>() != QSqlError::NoError)</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;error.<span class="built_in">text</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="检验表是否存在"><a href="#检验表是否存在" class="headerlink" title="检验表是否存在"></a>检验表是否存在</h3><p>检验数据库中是否存在某表，可以利用 QSqlDatabase 提供的 <code>QSqlDatabase::tables()</code>函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Is Table Exists</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Widget::isTableExists</span><span class="params">(<span class="keyword">const</span> QString &amp;)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(_db.<span class="built_in">tables</span>().<span class="built_in">contains</span>(<span class="string">&quot;user&quot;</span>))</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;Table exists&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;Table not exists&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> _db.<span class="built_in">tables</span>().<span class="built_in">contains</span>(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>QSqlDatabase::tables()</code>函数返回一个 <em>QStringList</em> 类型的数据，里面储存着所有表名，所以我们可以很方便的调用 <code>QStringList::contains()</code> 函数了来检验表是否存在。</p>
<h3 id="查询、遍历数据表"><a href="#查询、遍历数据表" class="headerlink" title="查询、遍历数据表"></a>查询、遍历数据表</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Query Table</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Widget::queryTable</span><span class="params">(<span class="keyword">const</span> QString &amp;)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Query</span></span><br><span class="line">    QSqlQuery query;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Query the database</span></span><br><span class="line">    query.<span class="built_in">exec</span>(<span class="string">&quot;SELECT * FROM user WHERE 1&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get record</span></span><br><span class="line">    <span class="keyword">while</span>(query.<span class="built_in">next</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        QSqlRecord record = query.<span class="built_in">record</span>();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;record.<span class="built_in">value</span>(<span class="number">0</span>)&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;record.<span class="built_in">value</span>(<span class="number">1</span>)&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;record.<span class="built_in">value</span>(<span class="number">2</span>)&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;record.<span class="built_in">value</span>(<span class="number">3</span>)&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;record.<span class="built_in">value</span>(<span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Error Info</span></span><br><span class="line">    QSqlError error = _db.<span class="built_in">lastError</span>();</span><br><span class="line">    <span class="keyword">if</span>(error.<span class="built_in">type</span>() != QSqlError::NoError)</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;error.<span class="built_in">text</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>数据表的遍历技巧要记住。</p>
<h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Insert Data</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Widget::insertData</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//Query</span></span><br><span class="line">    QSqlQuery query;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Prepare</span></span><br><span class="line">    query.<span class="built_in">prepare</span>(<span class="string">&quot;INSERT INTO user VALUES (:ID, :Name, :Age, :Type, :Gender)&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Bind value</span></span><br><span class="line">    query.<span class="built_in">bindValue</span>(<span class="string">&quot;:ID&quot;</span>,<span class="number">0</span>);</span><br><span class="line">    query.<span class="built_in">bindValue</span>(<span class="string">&quot;:Name&quot;</span>,<span class="string">&quot;test&quot;</span>);</span><br><span class="line">    query.<span class="built_in">bindValue</span>(<span class="string">&quot;:Age&quot;</span>,<span class="number">22</span>);</span><br><span class="line">    query.<span class="built_in">bindValue</span>(<span class="string">&quot;:Type&quot;</span>,<span class="string">&quot;testType&quot;</span>);</span><br><span class="line">    query.<span class="built_in">bindValue</span>(<span class="string">&quot;:Gender&quot;</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Exec inserting</span></span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;query.<span class="built_in">exec</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Error Info</span></span><br><span class="line">    QSqlError error = _db.<span class="built_in">lastError</span>();</span><br><span class="line">    <span class="keyword">if</span>(error.<span class="built_in">type</span>() != QSqlError::NoError)</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;error.<span class="built_in">text</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>插入数据时使用了<code>QSqlDatabase::prepare()</code> 与 <code>QSqlDatabase::bindValue()</code>方法，当然我们也可以直接调用 <code>QSqlDatabase::exec()</code>，使用<code>tr(&quot;%1&quot;).arg(arg1)</code>方法来指定参数。</p>
<h3 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Update Data</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Widget::updateData</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Query</span></span><br><span class="line">    QSqlQuery query;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update</span></span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;query.<span class="built_in">exec</span>(<span class="string">&quot;UPDATE user SET Age=233 WHERE Name=&#x27;Joker&#x27;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Error Info</span></span><br><span class="line">    QSqlError error = _db.<span class="built_in">lastError</span>();</span><br><span class="line">    <span class="keyword">if</span>(error.<span class="built_in">type</span>() != QSqlError::NoError)</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;error.<span class="built_in">text</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Delete Data</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Widget::deleteData</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Query</span></span><br><span class="line">    QSqlQuery query;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Delete</span></span><br><span class="line">    query.<span class="built_in">exec</span>(<span class="string">&quot;DELETE FROM user WHERE Name=&#x27;test&#x27;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Error Info</span></span><br><span class="line">    QSqlError error = _db.<span class="built_in">lastError</span>();</span><br><span class="line">    <span class="keyword">if</span>(error.<span class="built_in">type</span>() != QSqlError::NoError)</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;error.<span class="built_in">text</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<p>至此本章的内容基本结束。下一章将讲解 Qt SQL 操作中最为精彩的部分：Model/View 模式。</p>
<blockquote>
<p>简单的 MySQL 和 SQLite 教程：</p>
<p>MySQL: <a href="https://www.runoob.com/mysql/mysql-tutorial.html">https://www.runoob.com/mysql/mysql-tutorial.html</a></p>
<p>SQLite: <a href="https://www.runoob.com/sqlite/sqlite-tutorial.html">https://www.runoob.com/sqlite/sqlite-tutorial.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>Qt</tag>
        <tag>Sql</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL on Qt (1):安装 MySQL 驱动以及连接 MySQL 与 SQLite</title>
    <url>/2020/07/22/mysqlonqt1/</url>
    <content><![CDATA[<h1 id="MySQL-on-Qt-1-安装-MySQL-驱动以及连接-MySQL-与-SQLite"><a href="#MySQL-on-Qt-1-安装-MySQL-驱动以及连接-MySQL-与-SQLite" class="headerlink" title="MySQL on Qt (1): 安装 MySQL 驱动以及连接 MySQL 与 SQLite"></a>MySQL on Qt (1): 安装 MySQL 驱动以及连接 MySQL 与 SQLite</h1><blockquote>
<p>写在前面： </p>
<p>大一下学期的 CPP 大作业“自主订餐系统”可真是颇费了一些力气，每天晚睡早起撸代码，课都没听，很多知识都是现学现用。</p>
<p>为了避免当时学到的东西给全部忘光光（`_&gt;`，我这脑子啊。。。），所以我把当时大作业的一些核心部分（一些零碎的小细节，能记就记）给记录一下，一方面是复习，一方面也方便以后用到的时候查阅。</p>
</blockquote>
<p>这篇文章是大作业 MySQL + SQLite 操作相关部分的第一章，主要讲一下如何安装 MySQL 驱动（Win 下）以及如何连接 MySQL 及 SQLite。</p>
<span id="more"></span>

<h2 id="准备部分——安装-MySQL-驱动"><a href="#准备部分——安装-MySQL-驱动" class="headerlink" title="准备部分——安装 MySQL 驱动"></a>准备部分——安装 MySQL 驱动</h2><p>还记得跟着教程学 Qt MySQL 操作的时候兴致冲冲地跟着打下了一行行代码，然后编译—运行，卧槽，报错。。。报错信息如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">QSqlDatabase: QMYSQL driver not loaded</span><br><span class="line"></span><br><span class="line">QSqlDatabase: available drivers: QSQLITE QPSQL QPSQL7</span><br><span class="line"></span><br><span class="line">&quot;Driver not loaded Driver not loaded&quot;</span><br></pre></td></tr></table></figure>

<p>看一下报错信息，大体的意思就是说 Qt 没有连接 MySQL 的驱动。</p>
<p>查看当前系统环境中的 Qt 支持哪些 Sql 驱动，可以输出一下 QSqlDatabase::drivers() 的值。</p>
<p>坑爹的 Qt 在 Win 下并没有附带 MySQL 的连接驱动，需要我们自行编译。</p>
<p>如果只需要连接远程数据库，那我们本地并不需要安装 MySQL，只要找到 MySQL 提供的 <code>libmysql.dll</code> 和 <code>libmysqld.dll</code> 拷贝到 Qt 的安装目录（<code>%QtDir%/migw.../bin</code>）。网上有教程说 Qt 默认自带已经编译好的 <code>qsqlmysql.dll</code> 和 <code>qsqlmysqld.dll</code> （路径在 <code>%QtDir%/mingw.../plugins/sqldrivers</code>），但是实测这些教程都已经老的不能再老了，我的安装目录下就没有自带的编译好的这两个 dll 文件，接下来我们开始着手安装和编译 MySQL 驱动。</p>
<h3 id="第一步：下载-MySQL-DLL文件"><a href="#第一步：下载-MySQL-DLL文件" class="headerlink" title="第一步：下载 MySQL DLL文件"></a>第一步：下载 MySQL DLL文件</h3><p>扔个地址： </p>
<blockquote>
<p><a href="https://dev.mysql.com/downloads/connector/cpp/">https://dev.mysql.com/downloads/connector/cpp/</a></p>
</blockquote>
<p>下载下来拷贝一下扔过去就好了。。。</p>
<p>（我记得当时搞了一个老版本的才能用。。。记不清了。。。需要的时候现搞吧。）</p>
<h3 id="第二步：-编译-MySQL-驱动"><a href="#第二步：-编译-MySQL-驱动" class="headerlink" title="第二步： 编译 MySQL 驱动"></a>第二步： 编译 MySQL 驱动</h3><p>这一步是重中之重，不巧的是我也忘的差不多了。。。</p>
<p>这里我们需要有 Qt 的源码，可以去下载一下。Qt 全部源码2G大小，我们可以仅选择模块进行下载。</p>
<p>用 Qt 打开源码目录下的<code>\src\plugins\sqldrivers\mysql\mysql.pro</code>。</p>
<p>在末尾加上两句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INCLUDEPATH += mysql安装目录\include</span><br><span class="line">LIBS += -Lmysql安装目录\lib\ -llibmysql</span><br></pre></td></tr></table></figure>

<p>构建项目后会生成 <code>qsqlmysql.dll</code> 和 <code>qsqlmysqld.dll</code>两个文件，然后拷贝到<code>%QtDir%/mingw.../plugins/sqldrivers</code>文件夹中。</p>
<p>准备部分到这里就大体结束了，理论上 Qt 就已经能成功连接 MySQL 。</p>
<h2 id="上路！连接-MySQL-和-SQLite"><a href="#上路！连接-MySQL-和-SQLite" class="headerlink" title="上路！连接 MySQL 和 SQLite"></a>上路！连接 MySQL 和 SQLite</h2><h3 id="配置工程文件"><a href="#配置工程文件" class="headerlink" title="配置工程文件"></a>配置工程文件</h3><p>若要使用 Qt 的 SQL 库，则需要在工程文件中添加相应的参数。</p>
<p>CMakeLists.txt:</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(Qt5 Sql)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(Ordering-System-Server PRIVATE Qt5::Sql)</span><br></pre></td></tr></table></figure>

<p>.pro工程文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">QT += sql</span><br></pre></td></tr></table></figure>



<h3 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h3><p>SQL 用到的库主要为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QSqlDatabase&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QSqlError&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QSqlRecord&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QSqlQuery&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QSqlIndex&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>其中 QSqlDatabase 是最重要的库，数据库的连接及其他基本操作都要在这个类上执行。</p>
<p>连接数据库时，我们主要会用到以下几个函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//添加数据库</span></span><br><span class="line">[<span class="keyword">static</span>] <span class="function">QSqlDatabase <span class="title">QSqlDatabase::addDatabase</span><span class="params">(<span class="keyword">const</span> QString &amp;type, <span class="keyword">const</span> QString &amp;connectionName = QLatin1String(defaultConnection))</span></span></span><br><span class="line"><span class="function"><span class="comment">//设置数据库相关信息</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QSqlDatabase::setHostName</span><span class="params">(<span class="keyword">const</span> QString &amp;host)</span>        <span class="comment">//主机地址</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QSqlDatabase::setDatabaseName</span><span class="params">(<span class="keyword">const</span> QString &amp;name)</span>    <span class="comment">//数据库名</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QSqlDatabase::setUserName</span><span class="params">(<span class="keyword">const</span> QString &amp;name)</span>    	   <span class="comment">//数据库用户名</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QSqlDatabase::setPassword</span><span class="params">(<span class="keyword">const</span> QString &amp;password)</span>    <span class="comment">//数据库密码</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QSqlDatabase::setPort</span><span class="params">(<span class="keyword">int</span> port)</span>                       <span class="comment">//数据库端口</span></span></span><br></pre></td></tr></table></figure>

<p>这里要特别注意一下<code>addDatabase()</code>这个函数的第二个参数 <em>connectionName</em> ，如果不指定这个参数，<strong>每次添加的数据库连接都会被应用程序当作默认连接</strong>。当初被这个坑了很久，因为大作业中服务端同时操作着两个数据库，一个远程 MySQL 数据库，一个本地 SQLite 数据库，添加第二个 SQLite 数据库后，就出锅不断，原因就在我没有注意第二个参数。</p>
<p><img src="https://gitee.com/skykeyjoker/PicCloud/raw/master/img/adddatabase.png" alt="Qt Doc中关于 addDatabase的介绍"></p>
<p>接下来分别就给一下连接 MySQL 和 SQLite 数据库的范例：</p>
<h4 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL:"></a>MySQL:</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QSqlDatabase db = QSqlDatabase::<span class="built_in">addDatabase</span>(<span class="string">&quot;QMYSQL&quot;</span>);   <span class="comment">//添加一个数据库 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//设置数据库信息</span></span><br><span class="line">db.<span class="built_in">setHostName</span>(_dbHost);</span><br><span class="line">db.<span class="built_in">setDatabaseName</span>(_dbName);</span><br><span class="line">db.<span class="built_in">setUserName</span>(_dbUser);</span><br><span class="line">db.<span class="built_in">setPassword</span>(_dbPasswd);</span><br><span class="line">db.<span class="built_in">setPort</span>(_dbPort);</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> dbRet = db.<span class="built_in">open</span>(); <span class="comment">//连接数据库</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!ret)</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;Can not open the DB&quot;</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;Open the DB successfully.&quot;</span>;</span><br></pre></td></tr></table></figure>



<p>SQLite:</p>
<p>因为 SQLite 数据库没有网络层，是一种本地储存的关系型数据库，因此连接的时候与 MySQL 有很大的差别。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置数据库文件名</span></span><br><span class="line">QString dbPath = QDir::<span class="built_in">currentPath</span>()+<span class="string">&quot;/&quot;</span>+<span class="string">&quot;orders.db&quot;</span>;</span><br><span class="line"></span><br><span class="line">sqliteDb = QSqlDatabase::<span class="built_in">addDatabase</span>(<span class="string">&quot;QSQLITE&quot;</span>,<span class="string">&quot;LocalSqlite&quot;</span>);</span><br><span class="line">sqliteDb.<span class="built_in">setDatabaseName</span>(dbPath);</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> ret = sqliteDb.<span class="built_in">open</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!ret)</span><br><span class="line">	<span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;Can not open the DB&quot;</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;Open the DB successfully.&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>数据库连接成功！</p>
<hr>
<p>MySQL 部分的第一章到此便结束了， 接下来的一章会讲解一些数据库的基本操作。</p>
<blockquote>
<p>补充：</p>
<p>MySQL 与 SQLite 的区别：</p>
<p><a href="https://blog.csdn.net/zbw1185/article/details/47975965">https://blog.csdn.net/zbw1185/article/details/47975965</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>Qt</tag>
        <tag>Sql</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下CMake使用</title>
    <url>/2020/07/21/cmake/</url>
    <content><![CDATA[<h1 id="Linux下CMake使用方法"><a href="#Linux下CMake使用方法" class="headerlink" title="Linux下CMake使用方法"></a>Linux下CMake使用方法</h1><p>在 linux 平台下使用 CMake 生成 Makefile 并编译的流程如下：</p>
<ol>
<li>编写 CMake 配置文件 CMakeLists.txt 。</li>
<li>执行命令 <code>cmake PATH</code> 或者 <code>ccmake PATH</code> 生成 Makefile 1 1<code>ccmake</code> 和 <code>cmake</code> 的区别在于前者提供了一个交互式的界面。。其中， <code>PATH</code> 是 CMakeLists.txt 所在的目录。</li>
<li>使用 <code>make</code> 命令进行编译。</li>
</ol>
<p>本文将从实例入手，一步步讲解 CMake 的常见用法，文中所有的实例代码可以在<a href="https://github.com/wzpan/cmake-demo">这里</a>找到。如果你读完仍觉得意犹未尽，可以继续学习我在文章末尾提供的其他资源。</p>
<span id="more"></span>

<h2 id="1-单个源文件"><a href="#1-单个源文件" class="headerlink" title="1.单个源文件"></a>1.单个源文件</h2><p>对于简单的项目，只需要写几行代码就可以了。例如，假设现在我们的项目中只有一个源文件 <a href="http://main.cc/">main.c</a> ，首先编写 CMakeLists.txt 文件，并保存在与 <a href="http://main.cc/">main.c</a> 源文件同个目录下：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># CMake 最低版本号要求</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span> (VERSION <span class="number">2.8</span>)</span><br><span class="line"><span class="comment"># 项目信息</span></span><br><span class="line"><span class="keyword">project</span> (Demo1)</span><br><span class="line"><span class="comment"># 指定生成目标</span></span><br><span class="line"><span class="keyword">add_executable</span>(Demo1 main.cc)</span><br></pre></td></tr></table></figure>

<p>CMakeLists.txt 的语法比较简单，由命令、注释和空格组成，其中命令是不区分大小写的。符号 <code>#</code> 后面的内容被认为是注释。命令由命令名称、小括号和参数组成，参数之间使用空格进行间隔。</p>
<p>对于上面的 ==CMakeLists.txt== 文件，依次出现了几个命令：</p>
<ol>
<li><code>cmake_minimum_required</code>：指定运行此配置文件所需的 CMake 的最低版本；</li>
<li><code>project</code>：参数值是 <code>Demo1</code>，该命令表示项目的名称是 <code>Demo1</code> 。</li>
<li><code>add_executable</code>： 将名为 <a href="http://main.cc/">main.c</a> 的源文件编译成一个名称为 Demo 的可执行文件。</li>
</ol>
<p>之后，在当前目录执行 <strong><code>cmake .</code></strong> ，得到 Makefile 后再使用 <strong><code>make</code></strong> 命令编译得到 Demo1 可执行文件。</p>
<h2 id="2-多个源文件"><a href="#2-多个源文件" class="headerlink" title="2.多个源文件"></a>2.多个源文件</h2><h3 id="1-同一目录，多个源文件"><a href="#1-同一目录，多个源文件" class="headerlink" title="1) 同一目录，多个源文件"></a>1) 同一目录，多个源文件</h3><p>上面的例子只有单个源文件。现在假如把 <code>power</code> 函数单独写进一个名为 <code>MathFunctions.c</code> 的源文件里，使得这个工程变成如下的形式：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">./Demo2</span><br><span class="line">    |</span><br><span class="line">    +--- main.cc</span><br><span class="line">    |</span><br><span class="line">    +--- MathFunctions.cc</span><br><span class="line">    |</span><br><span class="line">    +--- MathFunctions.h</span><br></pre></td></tr></table></figure>

<p>这个时候，CMakeLists.txt 可以改成如下的形式：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># CMake 最低版本号要求</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span> (VERSION <span class="number">2.8</span>)</span><br><span class="line"><span class="comment"># 项目信息</span></span><br><span class="line"><span class="keyword">project</span> (Demo2)</span><br><span class="line"><span class="comment"># 指定生成目标</span></span><br><span class="line"><span class="keyword">add_executable</span>(Demo main.cc MathFunctions.cc)</span><br></pre></td></tr></table></figure>

<p>唯一的改动只是在 <strong><code>add_executable</code></strong> 命令中增加了一个 <strong><code>MathFunctions.cc</code></strong> 源文件。这样写当然没什么问题，但是如果源文件很多，把所有源文件的名字都加进去将是一件烦人的工作。更省事的方法是使用 <strong><code>aux_source_directory</code></strong> 命令，该命令会查找指定目录下的所有源文件，然后将结果存进指定变量名。其语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">aux_source_directory(&lt;dir&gt; &lt;variable&gt;)</span><br></pre></td></tr></table></figure>

<p>因此，可以修改 CMakeLists.txt 如下：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># CMake 最低版本号要求</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span> (VERSION <span class="number">2.8</span>)</span><br><span class="line"><span class="comment"># 项目信息</span></span><br><span class="line"><span class="keyword">project</span> (Demo2)</span><br><span class="line"><span class="comment"># 查找当前目录下的所有源文件</span></span><br><span class="line"><span class="comment"># 并将名称保存到 DIR_SRCS 变量</span></span><br><span class="line"><span class="keyword">aux_source_directory</span>(. DIR_SRCS)</span><br><span class="line"><span class="comment"># 指定生成目标</span></span><br><span class="line"><span class="keyword">add_executable</span>(Demo <span class="variable">$&#123;DIR_SRCS&#125;</span>)</span><br></pre></td></tr></table></figure>

<p>这样，CMake 会将当前目录所有源文件的文件名赋值给变量 <code>DIR_SRCS</code> ，再指示变量 <code>DIR_SRCS</code> 中的源文件需要编译成一个名称为 Demo 的可执行文件。</p>
<h3 id="2-多个目录，多个源文件"><a href="#2-多个目录，多个源文件" class="headerlink" title="2) 多个目录，多个源文件"></a>2) 多个目录，多个源文件</h3><p>现在进一步将 MathFunctions.h 和 <a href="http://mathfunctions.cc/">MathFunctions.cc</a> 文件移动到 math 目录下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./Demo3</span><br><span class="line">    |</span><br><span class="line">    +--- main.cc</span><br><span class="line">    |</span><br><span class="line">    +--- math/</span><br><span class="line">          |</span><br><span class="line">          +--- MathFunctions.cc</span><br><span class="line">          |</span><br><span class="line">          +--- MathFunctions.h</span><br></pre></td></tr></table></figure>

<p>于这种情况，需要分别在项目根目录 Demo3 和 math 目录里各编写一个 CMakeLists.txt 文件。为了方便，我们可以先将 math 目录里的文件编译成静态库再由 main 函数调用。</p>
<p>根目录中的 CMakeLists.txt ：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># CMake 最低版本号要求</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span> (VERSION <span class="number">2.8</span>)</span><br><span class="line"><span class="comment"># 项目信息</span></span><br><span class="line"><span class="keyword">project</span> (Demo3)</span><br><span class="line"><span class="comment"># 查找当前目录下的所有源文件</span></span><br><span class="line"><span class="comment"># 并将名称保存到 DIR_SRCS 变量</span></span><br><span class="line"><span class="keyword">aux_source_directory</span>(. DIR_SRCS)</span><br><span class="line"><span class="comment"># 添加 math 子目录</span></span><br><span class="line"><span class="keyword">add_subdirectory</span>(<span class="keyword">math</span>)</span><br><span class="line"><span class="comment"># 指定生成目标 </span></span><br><span class="line"><span class="keyword">add_executable</span>(Demo main.cc)</span><br><span class="line"><span class="comment"># 添加链接库</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(Demo MathFunctions)</span><br></pre></td></tr></table></figure>

<p>该文件添加了下面的内容: 第3行，使用命令 <strong><code>add_subdirectory</code></strong> 指明本项目包含一个子目录 math，这样 <strong>math 目录下的 CMakeLists.txt 文件和源代码也会被处理</strong> 。第6行，使用命令 <strong><code>target_link_libraries</code></strong> 指明可执行文件 main 需要连接一个名为 MathFunctions 的链接库 。</p>
<p>==子目录中的 CMakeLists.txt==：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查找当前目录下的所有源文件</span></span><br><span class="line"><span class="comment"># 并将名称保存到 DIR_LIB_SRCS 变量</span></span><br><span class="line"><span class="keyword">aux_source_directory</span>(. DIR_LIB_SRCS)</span><br><span class="line"><span class="comment"># 生成链接库</span></span><br><span class="line"><span class="keyword">add_library</span> (MathFunctions <span class="variable">$&#123;DIR_LIB_SRCS&#125;</span>)</span><br></pre></td></tr></table></figure>

<p>在该文件中使用命令 <code>add_library</code> 将 src 目录中的源文件编译为静态链接库。</p>
<h2 id="3-正规一点的组织结构"><a href="#3-正规一点的组织结构" class="headerlink" title="3.正规一点的组织结构"></a>3.正规一点的组织结构</h2><p>正规一点来说，一般会把源文件放到<strong>src</strong>目录下，把头文件放入到<strong>include</strong>文件下，生成的对象文件放入到<strong>build</strong>目录下，最终输出的elf文件会放到<strong>bin</strong>目录下，这样整个结构更加清晰。让我们把前面的文件再次重新组织下，</p>
<p>我们在最外层目录下新建一个CMakeLists.txt，内容如下，</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span> (VERSION <span class="number">2.8</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span> (demo)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_subdirectory</span> (src)</span><br></pre></td></tr></table></figure>

<p>这里出现一个新的命令<code>add_subdirectory()</code>，这个命令==可以向当前工程添加存放源文件的子目录，并可以指定中间二进制和目标二进制的存放位置==，具体用法可以百度。<br>这里指定src目录下存放了源文件，当执行cmake时，就会进入src目录下去找src目录下的CMakeLists.txt，所以在<strong>src目录</strong>下也建立一个<strong>CMakeLists.txt</strong>，内容如下，</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">aux_source_directory</span> (. SRC_LIST)</span><br><span class="line"></span><br><span class="line"><span class="keyword">include_directories</span> (../<span class="keyword">include</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span> (main <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> (EXECUTABLE_OUTPUT_PATH <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/bin)</span><br></pre></td></tr></table></figure>


<p>这里又出现一个新的命令<code>set</code>，是用于定义变量的，<code>EXECUTABLE_OUT_PATH</code>和<code>PROJECT_SOURCE_DIR</code>是CMake自带的预定义变量，其意义如下，</p>
<blockquote>
<p><strong>EXECUTABLE_OUTPUT_PATH</strong> ：目标二进制可执行文件的存放位置<br><strong>PROJECT_SOURCE_DIR</strong>：工程的根目录</p>
</blockquote>
<p>所以，这里set的意思是把存放elf文件的位置设置为工程根目录下的bin目录。</p>
<p>添加好以上这2个CMakeLists.txt后，整体文件结构如下，</p>
<p>下面来运行cmake，不过这次先让我们切到build目录下，然后输入以下命令，<br><code>cmake ..</code><br>Makefile会在build目录下生成，然后在build目录下运行make，</p>
<p>运行ok，我们再切到bin目录下，发现main已经生成，并运行测试，</p>
<p>测试OK！</p>
<blockquote>
<p>这里解释一下为什么在build目录下运行cmake？从前面几个case中可以看到，如果不这样做，cmake运行时生成的附带文件就会跟源码文件混在一起，这样会对程序的目录结构造成污染，而在build目录下运行cmake，生成的附带文件就只会待在build目录下，如果我们不想要这些文件了就可以直接清空build目录，非常方便。</p>
</blockquote>
<p>另外一种写法：<br>前面的工程使用了2个CMakeLists.txt，这种写法是为了处理需要生成多个elf文件的情况，最外层的CMakeLists.txt用于掌控全局，使用<code>add_subdirectory</code>来添加要生成elf文件的源码目录。</p>
<p>如果只生成一个elf文件，那么上面的例子可以只使用一个CMakeLists.txt，可以把最外层的CMakeLists.txt内容改成如下，</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span> (VERSION <span class="number">2.8</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span> (demo)</span><br><span class="line"></span><br><span class="line"><span class="keyword">aux_source_directory</span> (src SRC_LIST)</span><br><span class="line"></span><br><span class="line"><span class="keyword">include_directories</span> (<span class="keyword">include</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span> (main <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> (EXECUTABLE_OUTPUT_PATH <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/bin)</span><br></pre></td></tr></table></figure>

<p>==同时，还要把src目录下的CMakeLists.txt删除。==</p>
<h2 id="4-动态库和静态库的编译控制"><a href="#4-动态库和静态库的编译控制" class="headerlink" title="4.动态库和静态库的编译控制"></a>4.动态库和静态库的编译控制</h2><p>有时我们只需要编译出动态库，静态库，然后等着让其它程序去使用。让我们看下这种情况该如何使用cmake。首先按照如下重新组织文件，只留下testFunc.h和TestFunc.c，</p>
<p>我们会在build目录下运行cmake，并把生成的库文件存放到lib目录下。<br><strong>最外层</strong>的CMakeLists.txt内容如下，</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span> (VERSION <span class="number">2.8</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span> (demo)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_subdirectory</span> (lib_testFunc)</span><br></pre></td></tr></table></figure>

<p><strong>lib_testFunc</strong>目录下的CMakeLists.txt如下，</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">aux_source_directory</span> (. SRC_LIST)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_library</span> (testFunc_shared SHARED <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br><span class="line"><span class="keyword">add_library</span> (testFunc_static STATIC <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set_target_properties</span> (testFunc_shared PROPERTIES OUTPUT_NAME <span class="string">&quot;testFunc&quot;</span>)</span><br><span class="line"><span class="keyword">set_target_properties</span> (testFunc_static PROPERTIES OUTPUT_NAME <span class="string">&quot;testFunc&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> (LIBRARY_OUTPUT_PATH <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/lib)</span><br></pre></td></tr></table></figure>

<p>这里又出现了新的命令和预定义变量，</p>
<blockquote>
<p><strong>add_library</strong>: 生成动态库或静态库(第1个参数指定库的名字；第2个参数决定是动态还是静态，如果没有就默认静态；第3个参数指定生成库的源文件)<br><strong>set_target_properties</strong>: 设置输出的名称，还有其它功能，如设置库的版本号等等<br>LIBRARY_OUTPUT_PATH: 库文件的默认输出路径，这里设置为工程目录下的lib目录<br>好了，让我们进入build目录下运行cmake ..，成功后再运行make，</p>
</blockquote>
<p>cd到lib目录下进行查看，发现已经成功生成了动态库和静态库，</p>
<blockquote>
<p>ps：可以看出前面使用<code>set_target_properties</code>重新定义了库的输出名字，如果不用<code>set_target_properties</code>也可以，那么库的名字就是<strong>add_library</strong>里定义的名字，只是我们连续2次使用add_library指定库名字时，这个名字不能相同，而<code>set_target_properties</code>可以把名字设置为相同，只是最终生成的库文件后缀不同，这样相对来说会好看点。</p>
</blockquote>
<h2 id="5-对库进行链接"><a href="#5-对库进行链接" class="headerlink" title="5.对库进行链接"></a>5.对库进行链接</h2><p>既然我们已经生成了库，那么就进行链接测试下。把build里的文件都删除，然后在在工程目录下新建src目录和bin目录，在src目录下添加一个main.c和一个CMakeLists.txt，整体结构如下，</p>
<p><img src="https://img-blog.csdn.net/20180827221422465?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3doYWh1MTk4OQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<p><strong>main.c</strong>内容如下，</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;testFunc.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    func(<span class="number">100</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>修改工程目录下的CMakeLists.txt</strong>，如下，</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span> (VERSION <span class="number">2.8</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span> (demo)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_subdirectory</span> (lib_testFunc)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_subdirectory</span> (src)</span><br></pre></td></tr></table></figure>

<p>只是使用<code>add_subdirectory</code>把<strong>src</strong>目录添加进来。<br><strong>src</strong>目录下的CMakeLists.txt如下，</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">aux_source_directory</span> (. SRC_LIST)</span><br><span class="line"><span class="comment"># find testFunc.h</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">include_directories</span> (../lib_testFunc)</span><br><span class="line"></span><br><span class="line"><span class="keyword">link_directories</span> (<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/lib)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span> (main <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span> (main testFunc)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> (EXECUTABLE_OUTPUT_PATH <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/bin)</span><br></pre></td></tr></table></figure>


<p>这里出现2个新的命令，</p>
<blockquote>
<p><code>link_directories</code>: 添加非标准的共享库搜索路径<br><code>target_link_libraries</code>: 把目标文件与库文件进行链接</p>
</blockquote>
<p>make成功，进入到bin目录下查看，发现main已经生成，并运行，</p>
<p>运行成功！</p>
<blockquote>
<p>ps：在lib目录下有testFunc的静态库和动态库，<code>target_link_libraries (main testFunc)</code>默认是使用动态库，如果lib目录下只有静态库，那么这种写法就会去链接静态库。也可以直接指定使用动态库还是静态库，写法是：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">target_link_libraries</span> (main libtestFunc.so)</span><br><span class="line"><span class="comment">#或</span></span><br><span class="line"><span class="keyword">target_link_libraries</span> (main libtestFunc.a)</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>ps： 查看elf文件使用了哪些库，可以使用<code>readelf -d ./xx</code>来查看</p>
</blockquote>
<h2 id="6-添加编译选项"><a href="#6-添加编译选项" class="headerlink" title="6.添加编译选项"></a>6.添加编译选项</h2><p>有时编译程序时想添加一些编译选项，如<code>-Wall</code>，<code>-std=c++11</code>等，就可以使用<code>add_compile_options</code>来进行操作。<br>这里以一个简单程序来做演示，main.cpp如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> data = <span class="number">100</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;data: &quot;</span> &lt;&lt; data &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>CMakeLists.txt内容如下，</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span> (VERSION <span class="number">2.8</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span> (demo)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> (EXECUTABLE_OUTPUT_PATH <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/bin)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_compile_options</span>(-std=c++<span class="number">11</span> -Wall) </span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(main main.cpp)</span><br></pre></td></tr></table></figure>


<p>整体目录结构如下，</p>
<p><img src="https://img-blog.csdnimg.cn/20190718210743197.png" alt="在这里插入图片描述"></p>
<p>然后cd到build目录下，执行<code>cmake .. &amp;&amp; make</code>命令，就可以在bin目录下得到main的elf文件</p>
<h2 id="7-添加控制选项"><a href="#7-添加控制选项" class="headerlink" title="7. 添加控制选项"></a>7. 添加控制选项</h2><p>有时希望在<strong>编译代码时只编译一些指定的源码</strong>，例如本来要编译生成多个bin或库文件，现在<strong>只想生成某些指定的bin或库文件</strong>，这时可以使用cmake的<strong>option</strong>命令。</p>
<p>这里仍然使用例子来解释，假设我们现在的工程会生成2个bin文件，main1和main2，现在整体结构体如下，</p>
<p><img src="https://img-blog.csdnimg.cn/20190811114036435.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3doYWh1MTk4OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>外层的CMakeLists.txt内容如下，</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">2.8</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span>(demo)</span><br><span class="line"></span><br><span class="line"><span class="keyword">option</span>(MYDEBUG <span class="string">&quot;enable debug compilation&quot;</span> <span class="keyword">OFF</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> (EXECUTABLE_OUTPUT_PATH <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/bin)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_subdirectory</span>(src)</span><br></pre></td></tr></table></figure>


<p>这里使用了<code>option</code>命令，其第一个参数是这个option的名字，第二个参数是字符串，用来描述这个option是来干嘛的，第三个是option的值，ON或OFF，也可以不写，不写就是默认OFF。</p>
<p>然后编写src目录下的CMakeLists.txt，如下</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span> (VERSION <span class="number">2.8</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(main1 main1.c)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (MYDEBUG)</span><br><span class="line">    <span class="keyword">add_executable</span>(main2 main2.c)</span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line">    <span class="keyword">message</span>(STATUS <span class="string">&quot;Currently is not in debug mode&quot;</span>)    </span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>

<p>注意，这里使用了<code>if-else</code>来根据option来决定是否编译main2.c<br>其中main1.c和main2.c的内容如下，</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main1.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello, this main1\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main2.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello, this main2\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>然后cd到build目录下输入<code>cmake .. &amp;&amp; make</code>就可以只编译出main1，如果想编译出main2，就把<code>MYDEBUG</code>设置为<strong>ON</strong>，再次输入<code>cmake .. &amp;&amp; make</code>重新编译。</p>
<p>每次想改变MYDEBUG时都需要去修改CMakeLists.txt，有点麻烦，其实可以通过cmake的命令行去操作，例如我们想把MYDEBUG设置为OFF，先cd到build目录，然后输入<code>cmake .. -DMYDEBUG=ON</code>，这样就可以编译出main1和main2 （在bin目录下）</p>
<blockquote>
<p>来源：<a href="https://blog.csdn.net/qq_28114615/article/details/90406140">https://blog.csdn.net/qq_28114615/article/details/90406140</a></p>
</blockquote>
<p><em>2020.3.29 19:01</em></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>cmake</tag>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title>二元运算符重载</title>
    <url>/2020/07/21/%E4%BA%8C%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/</url>
    <content><![CDATA[<h1 id="C-二元运算符重载"><a href="#C-二元运算符重载" class="headerlink" title="C++ 二元运算符重载"></a>C++ 二元运算符重载</h1><p>二元运算符需要两个参数，下面是二元运算符的实例。我们平常使用的加运算符（ + ）、减运算符（ - ）、乘运算符（ * ）和除运算符（ / ）都属于二元运算符。就像加(+)运算符。</p>
<p>下面的实例演示了如何重载加运算符（ + ）。类似地，您也可以尝试重载减运算符（ - ）和除运算符（ / ）。</p>
<span id="more"></span>

<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span> &#123;</span>   </span><br><span class="line">    <span class="keyword">double</span> length;      <span class="comment">// 长度   </span></span><br><span class="line">    <span class="keyword">double</span> breadth;     <span class="comment">// 宽度   </span></span><br><span class="line">    <span class="keyword">double</span> height;      <span class="comment">// 高度 </span></span><br><span class="line">    <span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getVolume</span><span class="params">(<span class="keyword">void</span>)</span>   </span></span><br><span class="line"><span class="function">    </span>&#123;      </span><br><span class="line">        <span class="keyword">return</span> length * breadth * height;   </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setLength</span><span class="params">( <span class="keyword">double</span> len )</span>   </span></span><br><span class="line"><span class="function">    </span>&#123;       </span><br><span class="line">        length = len;   </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setBreadth</span><span class="params">( <span class="keyword">double</span> bre )</span>   </span></span><br><span class="line"><span class="function">    </span>&#123;       </span><br><span class="line">        breadth = bre;   </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setHeight</span><span class="params">( <span class="keyword">double</span> hei )</span>   </span></span><br><span class="line"><span class="function">    </span>&#123;       </span><br><span class="line">        height = hei;   </span><br><span class="line">    &#125;   <span class="comment">// 重载 + 运算符，用于把两个 Box 对象相加   </span></span><br><span class="line">    Box <span class="keyword">operator</span>+(<span class="keyword">const</span> Box&amp; b)   </span><br><span class="line">    &#123;      </span><br><span class="line">        Box box;      </span><br><span class="line">        box.length = <span class="keyword">this</span>-&gt;length + b.length;      </span><br><span class="line">        box.breadth = <span class="keyword">this</span>-&gt;breadth + b.breadth;      </span><br><span class="line">        box.height = <span class="keyword">this</span>-&gt;height + b.height;      </span><br><span class="line">        <span class="keyword">return</span> box;   &#125; &#125;; </span><br><span class="line"><span class="comment">// 程序的主函数 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( )</span> </span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    Box Box1;                <span class="comment">// 声明 Box1，类型为 Box   </span></span><br><span class="line">    Box Box2;                <span class="comment">// 声明 Box2，类型为 Box   </span></span><br><span class="line">    Box Box3;                <span class="comment">// 声明 Box3，类型为 Box   </span></span><br><span class="line">    <span class="keyword">double</span> volume = <span class="number">0.0</span>;     <span class="comment">// 把体积存储在该变量中    </span></span><br><span class="line">    <span class="comment">// Box1 详述  </span></span><br><span class="line">    Box1.<span class="built_in">setLength</span>(<span class="number">6.0</span>);    </span><br><span class="line">    Box1.<span class="built_in">setBreadth</span>(<span class="number">7.0</span>);    </span><br><span class="line">    Box1.<span class="built_in">setHeight</span>(<span class="number">5.0</span>);    </span><br><span class="line">    <span class="comment">// Box2 详述   </span></span><br><span class="line">    Box2.<span class="built_in">setLength</span>(<span class="number">12.0</span>);    </span><br><span class="line">    Box2.<span class="built_in">setBreadth</span>(<span class="number">13.0</span>);    </span><br><span class="line">    Box2.<span class="built_in">setHeight</span>(<span class="number">10.0</span>);    </span><br><span class="line">    <span class="comment">// Box1 的体积   </span></span><br><span class="line">    volume = Box1.<span class="built_in">getVolume</span>();   </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Volume of Box1 : &quot;</span> &lt;&lt; volume &lt;&lt;endl;    </span><br><span class="line">    <span class="comment">// Box2 的体积   </span></span><br><span class="line">    volume = Box2.<span class="built_in">getVolume</span>();   </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Volume of Box2 : &quot;</span> &lt;&lt; volume &lt;&lt;endl;    </span><br><span class="line">    <span class="comment">// 把两个对象相加，得到 Box3   </span></span><br><span class="line">    Box3 = Box1 + Box2;    <span class="comment">// Box3 的体积   </span></span><br><span class="line">    volume = Box3.<span class="built_in">getVolume</span>();   </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Volume of Box3 : &quot;</span> &lt;&lt; volume &lt;&lt;endl;    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Volume of Box1 : 210</span><br><span class="line">Volume of Box2 : 1560</span><br><span class="line">Volume of Box3 : 5400</span><br></pre></td></tr></table></figure>





<h2 id="非成员函数与类成员二元运算-友元函数"><a href="#非成员函数与类成员二元运算-友元函数" class="headerlink" title="非成员函数与类成员二元运算(友元函数)"></a>非成员函数与类成员二元运算(友元函数)</h2><p>当 2 个对象相加时是没有顺序要求的，<strong>但要重载 ‘+’让其与一个数字相加则有顺序要求，可以通过加一个</strong>友元函数<strong>使另一个顺序的输入合法。</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">            <span class="built_in">A</span>();</span><br><span class="line">            <span class="built_in">A</span>(<span class="keyword">int</span> n);</span><br><span class="line">            A <span class="keyword">operator</span>+(<span class="keyword">const</span> A &amp; obj);</span><br><span class="line">            A <span class="keyword">operator</span>+(<span class="keyword">const</span> <span class="keyword">int</span> b);</span><br><span class="line">    		<span class="keyword">friend</span> A <span class="keyword">operator</span>+(<span class="keyword">const</span> <span class="keyword">int</span> b, A obj); </span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>; </span><br><span class="line">&#125; ;</span><br><span class="line">A::<span class="built_in">A</span>()</span><br><span class="line">&#123;</span><br><span class="line">    a=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">A::<span class="built_in">A</span>(<span class="keyword">int</span> n)<span class="comment">//构造函数 </span></span><br><span class="line">&#123;</span><br><span class="line">    a=n;</span><br><span class="line">&#125;</span><br><span class="line">A A::<span class="keyword">operator</span> +(<span class="keyword">const</span> A&amp; obj)<span class="comment">//重载+号用于 对象相加 </span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;a+obj.a;</span><br><span class="line">&#125;</span><br><span class="line">A A::<span class="keyword">operator</span>+(<span class="keyword">const</span> <span class="keyword">int</span> b)<span class="comment">//重载+号用于  对象与数相加</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">A</span>(a+b);</span><br><span class="line">&#125;</span><br><span class="line">A <span class="keyword">operator</span>+(<span class="keyword">const</span> <span class="keyword">int</span> b,  A obj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> obj+b;<span class="comment">//友元函数调用第二个重载+的成员函数  相当于 obj.operator+(b); </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">A::display</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">a1</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">A <span class="title">a2</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">    A a3,a4,a5;</span><br><span class="line">    a1.<span class="built_in">display</span>();</span><br><span class="line">    a2.<span class="built_in">display</span>();</span><br><span class="line">    <span class="keyword">int</span> m=<span class="number">1</span>;</span><br><span class="line">    a3=a1+a2;<span class="comment">//可以交换顺序，相当月a3=a1.operator+(a2); </span></span><br><span class="line">    a3.<span class="built_in">display</span>();</span><br><span class="line">    a4=a1+m;<span class="comment">//因为加了个友元函数所以也可以交换顺序了。</span></span><br><span class="line">    a4.<span class="built_in">display</span>();</span><br><span class="line">    a5=m+a1;</span><br><span class="line">    a5.<span class="built_in">display</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title>构造函数</title>
    <url>/2020/07/21/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="【C-】类构造函数（深拷贝与浅拷贝）"><a href="#【C-】类构造函数（深拷贝与浅拷贝）" class="headerlink" title="【C++】类构造函数（深拷贝与浅拷贝）"></a>【C++】类构造函数（深拷贝与浅拷贝）</h1><blockquote>
<p>原创Jacky_Feng 最后发布于2019-11-29 19:56:28 阅读数 16  收藏</p>
</blockquote>
<h2 id="1-什么是类的构造函数"><a href="#1-什么是类的构造函数" class="headerlink" title="1.什么是类的构造函数"></a>1.什么是类的构造函数</h2><p>类的构造函数是类的一种特殊的成员函数，它会在每次创建类的新对象时被自动调用。没创建一个对象都必须调用一次构造函数。</p>
<p>构造函数的名称与类的名称是完全相同的，并且不会返回任何类型，也不会返回void。构造函数可用于为某些成员变量设置初始值。</p>
<span id="more"></span>

<p>实例演示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 类Counter的构造函数</span></span><br><span class="line">    <span class="comment">// 特点：以类名作为函数名，无返回类型</span></span><br><span class="line">    <span class="built_in">Counter</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;object is being created&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 数据成员</span></span><br><span class="line">    <span class="keyword">int</span> m_value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Counter obj1;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>以上代码编译和执行的结果如下：</p>
<p><strong>object is being created</strong></p>
</blockquote>
<p> 该类对象obj1被创建时，编译系统为对象分配内存空间，并自动调用构造函数Counter()完成对象成员变量的初始化工作。</p>
<h2 id="2-构造函数的分类"><a href="#2-构造函数的分类" class="headerlink" title="2.构造函数的分类"></a>2.构造函数的分类</h2><h3 id="1）按函数有无参数分类"><a href="#1）按函数有无参数分类" class="headerlink" title="1）按函数有无参数分类"></a>1）按函数有无参数分类</h3><img src="https://img-blog.csdnimg.cn/20191129164917429.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phY2t5X0Zlbmc=,size_16,color_FFFFFF,t_70" alt="有无参数分类" style="zoom:80%;" />

<p> 其中所有带有默认值的有参构造函数会转变成默认构造函数。</p>
<h3 id="2）按参数的类型分类"><a href="#2）按参数的类型分类" class="headerlink" title="2）按参数的类型分类"></a>2）按参数的类型分类</h3><img src="https://img-blog.csdnimg.cn/20191129165633658.png" alt="按参数的类型分类" style="zoom:80%;" />

<p> 一个类中至少有上述两个构造函数，可以有更多的构造函数（构造函数允许重载），以实现不同形式对象的创建。</p>
<h2 id="3-构造函数的重载"><a href="#3-构造函数的重载" class="headerlink" title="3.构造函数的重载"></a>3.构造函数的重载</h2><p>和普通成员函数一样，构造函数是允许重载的。一个类中可以有多个重载的构造函数，创建对象时根据传递的实参来判断调用哪个构造函数。创建对象构造函数的调用是强制性的，一旦在类中定义了构造函数，那么创建对象时就一定要调用。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">String</span>(<span class="keyword">const</span> <span class="keyword">char</span> *str = <span class="literal">NULL</span>); <span class="comment">// 普通构造函数</span></span><br><span class="line">    <span class="built_in">String</span>(<span class="keyword">const</span> String &amp;other);    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    ~ <span class="built_in">String</span>(<span class="keyword">void</span>);                 <span class="comment">// 析构函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> *m_data; <span class="comment">// 用于保存字符串</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// String 的析构函数</span></span><br><span class="line">String::~<span class="built_in">String</span>(<span class="keyword">void</span>) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> [] m_data;</span><br><span class="line">    <span class="comment">// 由于m_data 是内部数据类型，也可以写成 delete m_data;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// String 的普通构造函数</span></span><br><span class="line">String::<span class="built_in">String</span>(<span class="keyword">const</span> <span class="keyword">char</span> *str) </span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Ordinary constructor is running&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 拷贝构造函数</span></span><br><span class="line">String::<span class="built_in">String</span>(<span class="keyword">const</span> String &amp;other) </span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Copy constructor is running&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	String  str1; </span><br><span class="line">	<span class="function">String  <span class="title">str2</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span></span>; </span><br><span class="line">	<span class="function">String  <span class="title">str3</span><span class="params">(str2)</span></span>; </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p> 上面代码编译和执行结果为：</p>
<img src="https://img-blog.csdnimg.cn/20191129172558212.png" alt="结果" style="zoom:80%;" />

 

<h2 id="4-常见的构造函数"><a href="#4-常见的构造函数" class="headerlink" title="4.常见的构造函数"></a>4.常见的构造函数</h2><h3 id="1）默认构造函数"><a href="#1）默认构造函数" class="headerlink" title="1）默认构造函数"></a>1）默认构造函数</h3><p>如果用户自己没有定义构造函数，那么编译器会自动生成一个默认构造函数，只是这个构造函数没有形参，函数体也是空的，不执行任何操作。例如：Student类的默认生成的构造函数如下：</p>
<p>​       <code> Student()&#123;&#125;</code></p>
<p>==一个类中必须有构造函数，要么用户自己定义，要么编译器自动生成。一旦用户自己定义了构造函数，不管几个，也不管形参如何，编译器都不再自动生成。==</p>
<p>调用不带参数的构造函数也可以省略括号。即创建对象Student stu()和Student stu是等价的。</p>
<h3 id="2）-拷贝构造函数"><a href="#2）-拷贝构造函数" class="headerlink" title="2） 拷贝构造函数"></a>2） 拷贝构造函数</h3><p>当以拷贝的方式初始化一个对象时，会调用一个特殊的构造函数，就是拷贝构造函数。拷贝构造函数的名称与类的名称一致，它必须的一个参数是本类型的一个引用变量。</p>
<p>注意，默认构造函数（即无参构造函数）不一定存在，但是拷贝构造函数总是会存在。</p>
<blockquote>
<p>拷贝构造函数常用的三种情况：</p>
<p>==①当用一个对象去初始化同类的另一个对象==。</p>
<p>例如：</p>
<p>​    A test_b(test_a);<br>​    A test_b = test_a;//这两条语句是等价的<br><strong>【注意】第二条语句是初始化语句，不是赋值语句。赋值语句的等号左边是一个早已有定义的变量，赋值语句不会引发拷贝构造函数的调用。</strong></p>
<pre><code>A test_a,test_b;
 test_b = test_a;//这句不会引发拷贝构造函数的调用，因为test_b早已生成，已经初始化过了
</code></pre>
<p>②==一个对象以值传递的方式传入函数体==，而调用拷贝构造函数时的参数，就是调用函数时所给的实参。</p>
<p>③==一个对象以值传递的方式从函数中返回==，而调用拷贝构造函数的参数，就是return语句所返回的对象。</p>
</blockquote>
<h4 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h4><p>浅拷贝是指在对象拷贝时，只对对象中的数据成员进行简单的赋值，默认拷贝构造函数执行的也是浅拷贝。大多数情况下“浅拷贝”可以很好的工作，但一旦对象存在动态成员，那么浅拷贝就会出问题。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rect</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Rect</span>()</span><br><span class="line">    &#123;</span><br><span class="line">     p=<span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	~<span class="built_in">Rect</span>()</span><br><span class="line">	&#123;</span><br><span class="line"> 		<span class="built_in">assert</span>(p!=<span class="literal">NULL</span>);</span><br><span class="line">    	<span class="keyword">delete</span> p;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> width;</span><br><span class="line">    <span class="keyword">int</span> height;</span><br><span class="line">    <span class="keyword">int</span> *p;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Rect rect1;</span><br><span class="line">    <span class="function">Rect <span class="title">rect2</span><span class="params">(rect1)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; 这段代码运行结束后，会出现运行错误。原因就在于在进行对象拷贝时，对于动态分配的内容没有正确的操作。</span><br></pre></td></tr></table></figure>

<p>原因分析：</p>
<p>在使用rect1复制rect2时，由于执行的是浅拷贝，只是将成员的值进行赋值，这时 rect1.p = rect2.p，也即这两个指针指向了堆里的同一个空间。</p>
<img src="https://img-blog.csdnimg.cn/20191129194029601.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phY2t5X0Zlbmc=,size_16,color_FFFFFF,t_70" alt="原因" style="zoom:80%;" />

<p> 在销毁对象时，两个对象的析构函数将对同一个内存空间释放两次，这就是错误出现的原因。我们需要的不是两个p有相同的值，而是两个p指向的空间有相同的值，解决办法就是使用“深拷贝”。</p>
<h4 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h4><p>深拷贝对于动态成员，并不是简单地复制，而是重新动态分配空间。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rect</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Rect</span>()</span><br><span class="line">    &#123;</span><br><span class="line">     p=<span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//深拷贝</span></span><br><span class="line">    <span class="built_in">Rect</span>(<span class="keyword">const</span> Rect&amp; r)</span><br><span class="line">    &#123;</span><br><span class="line">     width=r.width;</span><br><span class="line">        height=r.height;</span><br><span class="line">     p=<span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">100</span>);</span><br><span class="line">        *p=*(r.p);</span><br><span class="line">    &#125;</span><br><span class="line">~<span class="built_in">Rect</span>()</span><br><span class="line">&#123;</span><br><span class="line"> <span class="built_in">assert</span>(p!=<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> width;</span><br><span class="line">    <span class="keyword">int</span> height;</span><br><span class="line">    <span class="keyword">int</span> *p;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Rect rect1;</span><br><span class="line">    <span class="function">Rect <span class="title">rect2</span><span class="params">(rect1)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完成对象拷贝地过程为:</p>
<img src="https://img-blog.csdnimg.cn/2019112919463854.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phY2t5X0Zlbmc=,size_16,color_FFFFFF,t_70" alt="过程" style="zoom:80%;" />

<p> 此时rect1的p和rect2的p各自指向一段内存空间，但它们指向的空间具有相同的内容，这就是所谓的“深拷贝”。</p>
<blockquote>
<p>小结：</p>
<p><strong>拷贝构造函数有两种：深拷贝和浅拷贝</strong></p>
<p>当出现类的等号赋值时，会调用拷贝函数，在未定义显示拷贝构造函数的情况下，系统会调用默认的拷贝函数——即浅拷贝，它能够完成成员的一一复制。当数据成员中没有指针时，浅拷贝是可行的。但<strong>当数据成员中有指针</strong>时，如果采用简单的浅拷贝，则两类中的两个指针将指向同一个地址，当对象快结束时，会调用两次析构函数，而导致指针悬挂现象。所以，这时，必须采用深拷贝.</p>
<p>深拷贝与浅拷贝的区别就在于深拷贝会在堆内存中另外申请空间来储存数据，从而也就解决了指针悬挂的问题。<strong>简而言之，当数据成员中有指针时，必须要用深拷贝。</strong></p>
</blockquote>
<h2 id="5-综合实例分析"><a href="#5-综合实例分析" class="headerlink" title="5.综合实例分析"></a>5.综合实例分析</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CPoint</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//缺省构造函数,如果定义类时未指定任何构造函数，</span></span><br><span class="line">    <span class="comment">//系统将自动生成不带参数的缺省构造函数</span></span><br><span class="line">    <span class="built_in">CPoint</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;默认构造函数 &quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        x = <span class="number">0</span>;</span><br><span class="line">        y = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//带一个参数的可用于类型转换的构造函数</span></span><br><span class="line">	<span class="comment">//  explicit    //加上 explicit 可防止 CPoint pt1 = 1; 这种隐性转换</span></span><br><span class="line">    <span class="built_in">CPoint</span>(<span class="keyword">int</span> ix)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;1参数构造函数 &quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        x = ix;</span><br><span class="line">        y = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//带参数的构造函数</span></span><br><span class="line">	<span class="built_in">CPoint</span>(<span class="keyword">int</span> ix, <span class="keyword">int</span> iy)</span><br><span class="line">	&#123;</span><br><span class="line">    	cout &lt;&lt; <span class="string">&quot;2参数构造函数 &quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    	x = ix;</span><br><span class="line">   	 y = iy;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//拷贝构造函数,如果此函数不定义，系统将生成缺省拷贝构造函数功能,</span></span><br><span class="line">	<span class="comment">//缺省拷贝构造函数的行为是：用传入的对象参数的成员初始化正要建立的对象的相应成员</span></span><br><span class="line">	<span class="comment">//  explicit    //加上 explicit 可防止 CPoint pt2 = pt1; 这种隐性转换</span></span><br><span class="line">    <span class="built_in">CPoint</span>(<span class="keyword">const</span> CPoint &amp;cp)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;拷贝构造函数 &quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        x = cp.x;</span><br><span class="line">        y = cp.y;</span><br><span class="line">    &#125;</span><br><span class="line">    CPoint &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> CPoint &amp;cp)</span><br><span class="line">	&#123;</span><br><span class="line">    	cout &lt;&lt; <span class="string">&quot;赋值重载函数 &quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    	<span class="keyword">if</span> (<span class="keyword">this</span> != &amp;cp)</span><br><span class="line">    	&#123;</span><br><span class="line">       	 	x = cp.x;</span><br><span class="line">       	 	y = cp.y;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">return</span> (*<span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//析构函数，一个类中只能有一个析构函数,如果用户没有定义析构函数，</span></span><br><span class="line">	<span class="comment">//系统会自动未类生成一个缺省的析构函数</span></span><br><span class="line">	~<span class="built_in">CPoint</span>()</span><br><span class="line">	&#123;</span><br><span class="line">    	cout &lt;&lt; <span class="string">&quot;析构函数 &quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	CPoint &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> CPoint &amp;cp)</span><br><span class="line">	&#123;</span><br><span class="line">    	cout &lt;&lt; <span class="string">&quot;赋值重载函数 &quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    	<span class="keyword">if</span> (<span class="keyword">this</span> != &amp;cp)</span><br><span class="line">    	&#123;</span><br><span class="line">        	x = cp.x;</span><br><span class="line">        	y = cp.y;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">return</span> (*<span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//析构函数，一个类中只能有一个析构函数,如果用户没有定义析构函数，</span></span><br><span class="line">	<span class="comment">//系统会自动未类生成一个缺省的析构函数</span></span><br><span class="line">	~<span class="built_in">CPoint</span>()</span><br><span class="line">	&#123;</span><br><span class="line">    	cout &lt;&lt; <span class="string">&quot;析构函数 &quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">CPoint <span class="title">p0</span><span class="params">()</span></span>;        <span class="comment">//这是函数的声明，不是实例化类</span></span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; <span class="string">&quot;CPoint pt1;\t\t&quot;</span>;</span><br><span class="line">	CPoint pt1;         <span class="comment">//缺省构造函数</span></span><br><span class="line"> </span><br><span class="line">	cout &lt;&lt; endl &lt;&lt; <span class="string">&quot;CPoint pt2(1);\t\t&quot;</span>;</span><br><span class="line">	<span class="function">CPoint <span class="title">pt2</span><span class="params">(<span class="number">1</span>)</span></span>;      <span class="comment">//一个参数的构造函数</span></span><br><span class="line"> </span><br><span class="line">	cout &lt;&lt; endl &lt;&lt; <span class="string">&quot;CPoint pt3(1, 2);\t&quot;</span>;</span><br><span class="line">	<span class="function">CPoint <span class="title">pt3</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;   <span class="comment">//两个参数的构造函数</span></span><br><span class="line"> </span><br><span class="line">	cout &lt;&lt; endl &lt;&lt; <span class="string">&quot;CPoint pt4 = 1;\t\t&quot;</span>;</span><br><span class="line">	CPoint pt4 = <span class="number">1</span>;     <span class="comment">//等价于CPoint t4(1);  //explicit</span></span><br><span class="line"> </span><br><span class="line">	cout &lt;&lt; endl &lt;&lt; <span class="string">&quot;CPoint pt5 = t1;\t&quot;</span>;</span><br><span class="line">	CPoint pt5 = pt1;   <span class="comment">//CPoint(t1);</span></span><br><span class="line"> </span><br><span class="line">	cout &lt;&lt; endl &lt;&lt; <span class="string">&quot;CPoint pt6 = CPoint();\t&quot;</span>;</span><br><span class="line">	CPoint pt6 = <span class="built_in">CPoint</span>();  <span class="comment">//CPoint(1); CPoint(1,2);</span></span><br><span class="line"> </span><br><span class="line">	cout &lt;&lt; endl &lt;&lt; <span class="string">&quot;pt6 = CPoint(1);\t&quot;</span>;</span><br><span class="line">	pt6 = <span class="built_in">CPoint</span>(<span class="number">1</span>);</span><br><span class="line"> </span><br><span class="line">	cout &lt;&lt; endl &lt;&lt; <span class="string">&quot;pt6 = 1;\t\t&quot;</span>;</span><br><span class="line">	pt6 = <span class="number">1</span>;            <span class="comment">//首先调用单个参数的构造函数，生成临时对象CPoint(1), 然后调用赋值运算符函数</span></span><br><span class="line"> </span><br><span class="line">	cout &lt;&lt; endl &lt;&lt; <span class="string">&quot;pt6 = t1;\t\t&quot;</span>;</span><br><span class="line">	pt6 = pt1;          <span class="comment">//调用赋值运算符函数</span></span><br><span class="line"> </span><br><span class="line">	cout &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码编译和执行结果如下：</p>
<img src="https://img-blog.csdnimg.cn/2019112918062265.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phY2t5X0Zlbmc=,size_16,color_FFFFFF,t_70" alt="执行结果" style="zoom:80%;" />



<blockquote>
<p>————————————————<br>版权声明：本文为CSDN博主「Jacky_Feng」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/Jacky_Feng/article/details/103313208">https://blog.csdn.net/Jacky_Feng/article/details/103313208</a></p>
</blockquote>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title>欧拉筛法</title>
    <url>/2020/07/21/euler-prime/</url>
    <content><![CDATA[<h1 id="欧拉筛法"><a href="#欧拉筛法" class="headerlink" title="欧拉筛法"></a>欧拉筛法</h1><blockquote>
<p>原创程画 最后发布于2018-05-15 18:24:08 阅读数 4146  收藏</p>
</blockquote>
<p>想看欧拉筛法的可直接拉到最后。</p>
<p>相信各位对素数并不陌生，素数就是指不能被除了1和自身以外的别的数整除的数，比如2,3,5，而且根据欧几里得的证明来看，素数是无限的，普通的筛选素数的方法可能对较小的数据能在较短时间内完成筛选，但对于很大的数据（比如1e9）就会花费很长的时间。</p>
<span id="more"></span>

<h2 id="1-普通的求素数方法"><a href="#1-普通的求素数方法" class="headerlink" title="1.普通的求素数方法"></a>1.普通的求素数方法</h2><p>例如，普通的求素数方法时这样的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> pri[MAXN];</span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prime</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cnt=<span class="number">0</span>;</span><br><span class="line">	pri[cnt++]=<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">int</span> i,j;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">3</span>;i&lt;=n;++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">2</span>;j&lt;i;++j)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(i%j!=<span class="number">0</span>)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(j&gt;=i)</span><br><span class="line">			pri[cnt++]=i;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>根据素数的定义所写的代码很容易理解，但是运行的效率是不太优秀的，所以我们要改进，当然在学习的过程中相信大家也或多或少的学了些改进方法，一个简单的改进方法就是将第二个循环的结束条件改为j&lt;sqrt(i)，相应地再更改判断条件，这样当然可以减少我们运行所需要的时间，但是任然不够好，下面我们就来介绍一下埃式筛法和今天的真正目标——欧拉筛法。</p>
<h2 id="2-埃式筛法"><a href="#2-埃式筛法" class="headerlink" title="2.埃式筛法"></a>2.埃式筛法</h2><p>先来介绍埃式筛法，埃式筛法的基本思想就是，当我们遍历到一个素数时，把所有该素数的倍数（自然是合数）都筛选出来，我们来看看代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> prime[MAXN];</span><br><span class="line"><span class="keyword">bool</span> vis[MAXN];</span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Era_prime</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(!vis[i])</span><br><span class="line">			prime[cnt++]=i;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;=n;j+=i)</span><br><span class="line">		&#123;</span><br><span class="line">			vis[j]=<span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们有没被选过的素数时，加入素数数组prime并且将它的所有n以内的倍数给筛选出来（vis[j]=true），埃式筛法很容易理解，并且在效率上也比较优秀，时间复杂度为O(nlglgn)，但是在处理1e8以上的数据时，还是稍稍力不从心，所以接下来我们着重介绍下线性时间筛法——欧拉筛法，我们还是先来看下代码：</p>
<h2 id="3-欧拉筛法"><a href="#3-欧拉筛法" class="headerlink" title="3.欧拉筛法"></a>3.欧拉筛法</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> prime[MAXN];</span><br><span class="line"><span class="keyword">bool</span> vis[MAXN];</span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Euler_prime</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(!vis[i])</span><br><span class="line">		&#123;prime[cnt++]=i;vis[i]=<span class="literal">true</span>;&#125;<span class="comment">//vis[i]置为true或不置true都可以</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;cnt;++j)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(i*prime[j]&gt;n)<span class="comment">//判断是否越界</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			vis[i*prime[j]]=<span class="literal">true</span>;<span class="comment">//筛数</span></span><br><span class="line">			<span class="keyword">if</span>(i%prime[j]==<span class="number">0</span>)<span class="comment">//时间复杂度为O(n)的关键！</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>我们注意到，在用埃式筛法的同时，同一个数字也许会被筛选多次，比如6先被2筛选一次，再被3筛选一次，这样就浪费了很多不必要的时间，而欧拉筛法通过<code>if(i%prime[j]==0)break;</code>这一步就避免了重复筛选的发生，我们举个例子，比如，2先筛选了4，然后进行下一个循环，3筛选6和9，当我们执行到4的时候，可以发现，当<code>i==4</code>时，第一次运行到<code>if(i%prime[j]==0)</code>这一步的时候就直接<code>break;</code>掉了，这也就是说，当我们的合数进入循环时，其实它已经被之前的数筛选过了，所以当合数进入内层循环时，内层循环只执行了一次，从而减少了时间复杂度。</p>
<p>结束</p>
<blockquote>
<p>————————————————<br>版权声明：本文为CSDN博主「程画」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/chczy1/java/article/details/80327323">https://blog.csdn.net/chczy1/java/article/details/80327323</a></p>
</blockquote>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>转载</tag>
      </tags>
  </entry>
</search>
