<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>About Me</title>
    <url>/2020/07/21/about/</url>
    <content><![CDATA[<h2 id="Skykey"><a href="#Skykey" class="headerlink" title="Skykey"></a>Skykey</h2><h3 id="Hello-World-👋"><a href="#Hello-World-👋" class="headerlink" title="Hello,World! 👋"></a>Hello,World! 👋</h3><p>Hi, I’m Skykey 😉, a programmer 👨🏻‍💻 from China 🇨🇳. I’m an open-source profession and always develop in Cpp/Qt. Currently, I’m working on <a href="https://github.com/QtDocumentCN/QtDocumentCN">QtDocCN</a>. Besides programming, I like delicious food 🥗🥩🌮🍣 and doing sports 🏃⛹️‍♂️🏋🏼‍♂️.</p>
<span id="more"></span>

<p>​    <img align="right" alt="GIF" src="https://media.giphy.com/media/iIqmM5tTjmpOB9mpbn/giphy.gif" /></p>
<p><strong>Current Status Quo</strong></p>
<ul>
<li>👨🏻‍💻 I’m currently working on <a href="https://github.com/QtDocumentCN/QtDocumentCN">QtDocCN</a>.</li>
<li>🌱 I’m currently learning C++/Qt.</li>
<li>🤔  I hope to be a linux system development programmer. 🐧</li>
<li>💬 Ask me about anything and I would like to answer.</li>
<li>📫 Please email via <a href="zcxzxlc@163.com">zcxzxlc@163.com</a> to reach me.</li>
</ul>
<hr>
<p><img src="https://github-readme-stats.vercel.app/api?username=skykeyjoker&show_icons=true&hide_border=true" alt="stats"></p>
<p><img src="https://gitee.com/skykeyjoker/PicCloud/raw/master/img/dino.gif" alt="dino"></p>
]]></content>
  </entry>
  <entry>
    <title>Never Say Goodbye 写于2.18离珠海前夜</title>
    <url>/2022/02/18/Never_Say_Goodbye/</url>
    <content><![CDATA[<h1 id="Never-Say-Goodbye-写于2-18离珠海前夜"><a href="#Never-Say-Goodbye-写于2-18离珠海前夜" class="headerlink" title="Never Say Goodbye 写于2.18离珠海前夜"></a>Never Say Goodbye 写于2.18离珠海前夜</h1><p>这几天一直过得浑浑噩噩的。</p>
<span id="more"></span>

<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=1842025914&auto=1&height=66"></iframe>

<p>一两年前一直很发愁，铁定了心不想升学，本科就出去当社畜，可是心里真的完全没底。本科就出去当社畜，最好的途径就是校招，校招要比社招难度低不少吧？不过我对这种事情也不算特别清楚。但是自己水平实在是菜的很，将来简历上都没什么好写的。只能靠笨鸟先飞，读书的时候就提前找实习积累一下经验，也能增加自己的竞争力。可是问题就出在这，之前一直很发愁，我到底能不能找到<del>合适的</del>实习工作呢？为了找实习工作，也需要积累项目经验，需要刷算法题，需要刷面试题。项目实在写不了多少了，太菜，算法题也是刷着刷着就不想刷了，太累太费脑子，一直在拖拖拖摆烂。最后被兄弟提醒了一下，大三上的寒假就可以试着找实习工作了，立马紧张的不行，从兄弟那请教怎么写简历，在什么平台上找工作发简历，大体了解了一下面试的流程。</p>
<p>虽然说是想着谁要我我就去谁那里工作，但是心里对未来工作的城市多少还是有点要求的，比如不想去北京上海这两个超级大城市，能在成都这样的新一线城市工作最好。抱着试一试的心，在牛客上浏览了成都武汉深圳杭州几个城市的所有正在招人的C++岗位，看到适合的就投了一下，甚至还投了一个还是两个字节的岗位来着。哦对，忘记说了，我还是挺想去字节工作的，虽然是一个令人恶心的互联网大厂，不过可能是因为A-SOUL，字节对我有巨大的吸引力。后面有三家公司的HR打来了电话回复，一个在上课被我直接挂掉了（悲），一个认为我投的不合适，想问问我还会不会考虑其他岗位，那自然也是pass了。最后一个就是宽德私募，也就是我后面来实习的这家公司。宽德看中了我的简历，认为有培养的潜力，也要工作需要的项目经验，很自然地约了一周之后的周末面试。一周的准备时间，项目和算法题是肯定来不及了，只能狂刷面试题，面试题也是随便百度了一下，找到了一个作者在知乎上总结的两篇C++面试文章，抱着临阵磨枪不快也光的心态去刷。刷面试题那会甚至把所有能翘掉的课都翘掉了，很多娱乐活动也推辞掉了，专心背面试题。还好我还是有一点C++基础的，刷起来也没那么痛苦，边摸编刷，提前一天完成了任务。然后就是面试，直接是CTO面的，做完自我介绍后就开始讨论我的项目经验，也就是之前写的那个订餐系统。那个订餐系统最早的版本是当作C++课的大作业来写的，几乎是边学C++和Qt边写出来的，可以说是一个很简陋的玩具。后来C++和Qt的水平不断精进，也渐渐有了重写订餐系统的想法，但真正的重构拖到了大三上学期，花了一个多月的事件，陆陆续续地把订餐系统进行了一次程度相当大的重构，让这个玩具变得没那么简陋了，当然，还只是玩具而已。</p>
<p>回到正题，前面说关于这个订餐系统面试官跟我聊了好久，主要就是在问订餐系统TCP通信的部分。在交流时我提到了这个系统对网络稳定性的要求比较高，实时性很强，不能容忍太大的延迟。可能就是这几句话引起了面试官的兴趣，他告诉我，我这个项目的所谓的“实时性、低延迟”之类的其实都是很不像样子的，跟宽德在搞的系统比起来完全是小儿科。后面问了TCP的报文结构，我没怎么答上来。然后又问了我STL容器相关的问题，刚好是我在面试题里复习到的内容，对答如流。最后很顺利地通过了面试，HR后面就约谈了薪资和工作地点问题。当时投宽德我是冲着它的成都分部的岗位去的，但公司希望我能来珠海总部实习。本来我就已经从山东到遥远的四川成都上学，再去趟珠海实习一下也完全没什么好吧，立马答应了。答应后还花了很大精力去说服父母支持我去珠海实习，现在想想还挺有趣的。</p>
<p>大三上最后一门考试是1月5号，6号上午我就坐飞机来珠海到公司报到，7号正式开始实习生活。接下来说的实习生活也是这篇随笔最重要的部分。</p>
<p>实习被年假分成了两个阶段，年前是一月七号到一月二十八号（实际上年前我二十九号、三十号两天也在公司申请了加班）。三十一号的凌晨回到了山东老家开始<del>享受</del>年假，年后初六（二月六号）就坐飞机飞回了珠海，初七开始正式年后的实习，一直实习到二月二十八号上午去办理离职手续。</p>
<p>年前一到宽德就意识到了这家公司的福利有多好：一日三餐，实习生甚至提供酒店住宿，报销一个来回的机票。公司里有健身器材，有很多零食水果和饮料，每周三下午都会有肯德基、必胜客和奈雪外卖组成的下午茶。考勤弹性很大，一周工作五天，周末也不会加班。工资也不错，一天300。对我来说简直是捡到宝了。公司提供的酒店是一家老旧的连锁酒店，破破烂烂的，但是好在卫生条件说得过去，离公司也只有步行五分钟的距离。年前那会公司里也没有几个实习生，我自己一个人住，住在一间挤挤巴巴的单人间，窗户很小，空间也很小。房间进门就是床，越过床就是卫生间的门，整个屋子都很潮湿，有一股霉味。在房门和床之间、床和卫生间的门之间各有一个小空道，两个小空道靠着床头的位置各塞了一个小床头柜。床头柜前空间小的塞不进椅子，不过房间里也没提供椅子。晚上我想玩自己的笔记本电脑，就只能把电脑放在其中的一个床头柜上（另外一个床头柜放了A-SOUL跟欧莱雅男士联名的化妆品盒，我从成都带过来用），外接键盘因为太长还要放一部分在床上，没有椅子，就直接坐着自己的行李箱，就这样每晚挤挤巴巴地用电脑打守望先锋，床上摆着平板或者手机挂着A-SOUL的直播。</p>
<p>年前的任务量比较大，我工作态度也特别认真。年前的任务是低延迟系统的核心通信部分，基于Solarflare专业网卡的网络通信，我的任务是阅读官方的API文档，再根据一个现成的开源库，去封装一个网络通信库。这是我第一次做这么底层的东西，也是第一次实际见到以纳秒为工作单位的系统。那阵子虽然一边摸鱼一边研究，但是一整个白天下来天天都很累。珠海疫情没爆发前，每晚上在公司吃完饭，都要先出去溜达一圈散散步放松一下身心，再回到酒店挤在床头柜前打游戏、看直播，跟前女友聊天。晚上溜达的时候还发现了一家粤式饮品店，从外面看起来挺不错的样子。后来也进去了两次，喝姜撞奶，很好喝。年前一共有四个周末，这四个周末的周六我都主动申请或者被动（年假调休）在公司里加班。主动申请加班也是因为窝在酒店没啥事情做，还不如去公司摸摸鱼，赚加班费。休息或出去玩的话，周日一天就够了。第一周的周日去周边的小公园玩了一下，顺便爬了一下山，沿着步行山道散了很远的步，也爬到一座山的山顶远眺大海和海上的港珠澳大桥，我甚至觉得自己看到了澳门。公司在的珠海香洲区，有几座连在一起的山，一直绵延到海边。我的工位刚好靠着落地窗，从落地窗往外望就可以看到旁边的山。天晴的话，可以看到山上的步行山道有很小很小的行人经过，阴天下雨的话，会从海那边飘来很多云雾，给山围上一圈丝带，看起来仙气十足。</p>
<p>年前发生了一个挺倒霉的事情，刚买了快一年的小米11手机WIFI模块烧坏了，用不了WIFI，只能用流量上网。其实小米11刚发售就已经有很多用户因为WIFI模块失效申请售后（主板设计问题），我那会还很庆幸自己的小米11没有遇到这个问题，觉得自己运气不错，结果年前还是遭了。手机遭了，自己也很糟心，只能周末骑自行车跑到了一个很远的售后点去检查，然后申请了免费换新机的服务，又等了好几天才去取到新手机。不过售后点刚好在横琴区海边。我很喜欢海。第一次去售后点，返程的时候先沿着海边走了一段路，那会刚好疫情爆发没多久，路上几乎没什么行人。又在海边的一个公园买了肯德基当午饭，边看海边吃汉堡炸鸡，吃完才满足地回酒店休息。</p>
<p>年前的工资计算到一月二十五号，二十八号放假那天才发现二十六号就已经发工资了，申请的从成都到珠海的机票报销也已经到账了，一共发了4500+500=5000块钱。二十八号放假当晚，想了一下，决定咬咬牙奢侈一把，于是人生第一次自己单独去了公司楼下一家西餐厅吃完饭。平日里在工位上透过落地窗就可以看到那家西餐厅，那会就很羡慕那些坐在椅子上慢慢喝酒吃西餐的人，很想亲身体验一下他们这种悠哉游哉的生活。那顿晚饭点了茴香土豆、意面、三明治，甚至还点了一杯鸡尾酒，吃得很撑。因为年前疫情的原因，我一度以为自己不能回家过年了因而十分郁闷，不过还好最后还是回家了。但是直到快到放假前珠海才降为低风险地区，因此我也只能订了三十号晚上的机票，因为三十号的机票相对要便宜一点。我也就顺便申请了二十九、三十号两天在公司里加一下班，赚一下加班费。说是加班，其实更多是在摸鱼，在工位上玩手机刷B站，用公司电脑刷知乎，写回答发表文章。二十九号下午也早早地离开了公司，做完核酸后又骑自行车到第二个周末修手机时去的海边玩。那次海边热闹多了，熙熙攘攘的很多人，沙滩也终于解封了。我脱鞋踩着海水散了一会步，还禁不住馋买了一串糖葫芦边走边吃。也顺便去拍了珠海渔女雕像，珠海的知名地标。晚上从海边回去，找了一家牛肉火锅店，准备尝一尝惦记了很久的牛肉火锅。很可惜，我完全不知道怎么吃牛肉火锅，不知道哪些肉好吃，不知道各种肉分别需要涮几秒钟而不是直接一股脑倒进锅里。牛肉丸子也因为太大只，中间尝了三四次都没完全熟透，就扔在里面一直煮到最后才吃，肉都老的嚼不动了。三十号简简单单地休息了下，下午多睡了会，很晚才去机场。记得去机场的路上用B站后台播放了很多遍珈乐的歌。</p>
<p>年假挺快乐的，见到了父母，见到了一些想见到的亲戚，见到了前女友，也见到了关系最好的那群朋友，像往常一样，跟朋友们一起在其中一个朋友家做披萨之类的美食。初四还跟前女友一起去了百盛购物商场，让她帮忙挑着买了几件衣服。买的衣服挺贵的，狠狠地肉疼了一下，不过这也是第一次用自己赚的钱去买衣服。年假很短，过得很快。</p>
<p>年后初六下午我就回了珠海，在酒店安顿好后去了酒店旁边的一家餐饮店解决了午餐，开始期待年后的实习生活。那会还不知道年后会遇到什么。</p>
<p>年后公司的实习生变多了，公司为了节省开支，每两个实习生一起合住一间双人间。双人间面积大了很多很多，甚至在窗边还有一张小桌子和椅子，我立马霸占了那张小桌子和椅子，晚上打游戏看直播也终于不用那么挤挤巴巴了。舍友是个才大二的后辈，很开朗，人挺好的。他的基础不太行，所以晚上下班后经常会来找我请教问题。有时候晚上饿了，还会一起去（接近十二点）酒店楼下的一个路边摊吃重庆小面。</p>
<p>年后工作时间比较短，任务比较少，我的工作态度也变得摸了不少。一开始给我分配的任务是做一个决策树，我的妈，这可难倒我了，结果马上就换成了做一个高速查表类，其实就是哈希表，也有一个现成的开源库来研究。我变得摸了不少，决定慢慢拖工期，在DDL之前大体研究明白然后做个简单封装得了。周末也终于把放假前的心愿了结了，去广州找一个朋友玩。周六上午就坐高铁去了广州，全程才一个小时左右。朋友领着在广州逛了很多地方，吃了一些特色的食品，比如菠萝炒饭，作为一个山东人很难相信广东这边竟然会把菠萝看成番茄一样的存在，又是蔬菜又是水果，可以直接吃也可以用来做饭。晚上被朋友领着去吃了真正的牛肉火锅，见识到了地道的牛肉火锅的吃法，不同种类的牛肉要涮多久，也终于尝到了朋友一直说的独家自制调料，确实好吃。那顿牛肉火锅拯救了我对牛肉火锅的印象。我宣布从今往后火锅只有三种，四川火锅，潮汕牛肉火锅，其他火锅。晚上还去参观了广州塔，灯光很漂亮。广州塔附近的地段很繁华，高耸入云的摩天大厦，大厦里的公司几乎都是我们公司的友商或者同行，各种私募投资公司、证券公司和银行，不得不感叹广州金融业的发达。不过的确，也就只有这种行业能够买的起这附近的地皮了。第二天中午朋友领着吃了早午茶，吃了很多粤式小吃，早饭午饭一起解决。下午又坐高铁回到珠海，收心准备下一周的工作。</p>
<p>接着到来的就是情人节，情人节也没什么特别的，依旧是白天摸鱼和工作，晚上下班立马回到酒店休息。情人节晚上有A-SOUL的情人节限定直播，边打游戏边看直播，平常的日子平常的快乐。不过毕竟情人节，还是要庆祝一下的，发了一条QQ空间动态表示了一下。很平常的情人节的晚上，不过那会没想到这会是暴风雨前的宁静。晚上快12点，本来看似聊得好好的前女友突然心情不好，停止了聊天。我郁闷了一会，觉得没什么，就准备溜一下直播的录播切片然后睡觉。当晚嘉然的直播效果很好。嘉然在许愿的时候说了一句话，“你要相信你自己哦，你一直都超棒的”。这句话对我的杀伤力很大，这么多年来，身边的人几乎都在告诉我，你要怎么做，你应该怎么做，很少会有人会给我鼓励。那一段我窝在被子里反复看了很多遍，竟然哭了出来。孤身一人跑到这么远的地方来工作实习，深夜悄悄地破防。我上次哭应该还是大一下学期的期末考试，物理挂科，把这个消息告诉父母之后，父母问了一下详细情况，出乎意料地没有批评我而是鼓励我好好复习争取补考通过。晚上爸爸还发了一段录像，是父母和奶奶在家里吃完饭，很日常的晚饭，也没刻意做什么事情，只是录了一下奶奶和餐桌上的饭菜，那晚我看了很多遍这个录像，边看边哭。</p>
<p>十五号正常去工作，前女友一直到下午才愿意来跟我说话。问清冷战的原因后吵了一架，我很生气，提出了分手后删了她的好友。后面我冷静了下来，但是没有改变自己的决定。通过她的好友申请后，编辑发送了一段文字，大抵意思是我们两人不适合，还是分开，对彼此都好。这个分手的想法不是一时起意，实际上可能已经萌生了很久，每次大的争吵后可能都让这个想法越来越强烈。于是十五号彻底结束了持续了六年的恋情，变成一条单身狗。</p>
<p>年后原本就越来越不想工作了，甚至想要早点开学回学校休息。比起工作，读书真的轻松太多。分手之后，整个人浑浑噩噩的，更是什么事情也不想做了。刚分手的那两天，我甚至完全吃不进饭，扒两口就恶心的不行，反胃。时常会胸口痛，巨大的缺失感。这才明白之前感到的孤独其实都是假的，因为那会无论感到多孤独，实际上永远都会有一个人默默地等在那里，听我絮絮叨叨，听我各种抱怨，听我讲各种琐事，各种开心的事情烦恼的事情，无论听不听得懂，始终都在听。后面几天做的事情其实几乎跟之前是一样的，工作、摸鱼，吃饭，但又完全不一样。经常会下意识地打开手机，想要把刚刚遇到的事情分享给她，然后才意识到那个她已经不在那里等着我了。十五号晚上流着泪删光了动态，删光了留言，删光了照片。我把过去删了个干净，但好像组成自己的一部分也被删掉了，自己被删掉的那部分像一个黑洞，不断吸引着我、提醒着我，一种难以言表的缺失感、空虚感。后面几天，尤其是在见过她发了一条跟闺蜜出去吃火锅的动态后，自己逐渐没有刚开始那么难受，心里也只想着早日结束实习逃回学校。今天中午又在楼下那家餐饮店吃的午饭，点了一份上次因为不会念“粿”这个字而没点的粿条，顺便也点了上次也点过的汤。记得初六那次来，点了一份牛腩汤泡饭。那天专门拍了自己点的菜发给了她，想让她看看清淡的广东菜。她还说看起来好寒碜，因为她不喜欢像牛腩这种大肉块。今天吃时与当时完全是不同的两种心情。还好，明天就能逃回学校了。</p>
<p>这六年来我们两个人的故事，我想说成一个早已预料到结局、但还是心甘情愿地做了六年的梦，现在梦醒了。结局似乎在最初就已经可以预料到了，两家的关系太近，会受到各种阻力，除此之外，最重要的是两个人之间的不适合，性格很难相处，各方面的不适合。十四号那晚她不开心，是因为明明情人节，我却没有做什么特殊的表示，送花、送礼物或者最简单的发红包都没有做，这些事情其实都是很简单的，都是顺手就能做到的事情。关键的不在于形式，而是情感的表达。并非是这一次情感表达的缺失让她难过，而是日积月累的缺失让她彻底失望了。一直以来我以为自己明白喜欢是一种陪伴，是一种习惯，其实却一直都没有真正明白。六年来我一直在当烂人，没有珍惜这份感情，把这份感情当作理所应当，落得这个结局也是必然。就像她之前说的那样，明明是最好的时光，我们却一直用来等待。我的幼稚彻底毁了这段感情。</p>
<p>无论如何，我还是很感谢这六年来她愿意陪我去做这个梦。从小认识，初中再熟络起来，高一不明不白地在一起，高二经历了一次又一次地争吵，高三趋于稳定，大学成为异地恋，一直到今年。很感谢六年来的陪伴。翻照片时回忆起高二高三，每次大休，只有不到一天的休息时间，都要挤时间见面，还互相送过饭。大一暑假陪我去海边，晚上在海边散步，去逛海底世界。某年情人节家里下了大雪，一起在河边的雪地上画画……这些回忆我可能要花很久时间才能忘掉，最后可能也忘不掉。很不舍得结束，但是结束对两人都是最好的选择。她没必要再束缚在我身上，可以去争取本就应该属于她的更好的未来。我也应该学会怎样独立地活在这个世界上，去做一个坚强的大人而不是像现在这样懦弱幼稚的烂人。希望未来我们都能在彼此选择的道路上熠熠生辉。</p>
<p>这次珠海的实习之旅，得到了很多，也失去了很多。生活还在继续，我也应停下自己的脚步。</p>
<p>Never Say Goodbye。</p>
<p>写于2022.2.18，离珠海前夜。实际上写完已经十九日凌晨。</p>
<blockquote>
<p>晚风中闪过 几帧从前啊<br>飞驰中旋转 已不见了吗</p>
</blockquote>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>关于std::thread的二三事</title>
    <url>/2022/02/01/%E5%85%B3%E4%BA%8Estd_thread%E7%9A%84%E4%BA%8C%E4%B8%89%E4%BA%8B/</url>
    <content><![CDATA[<h1 id="关于std-thread的二三事"><a href="#关于std-thread的二三事" class="headerlink" title="关于std::thread的二三事"></a>关于std::thread的二三事</h1><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>很早之前写过一篇关于线程池文章，《<a href="https://zhuanlan.zhihu.com/p/367309864">基于C++11实现线程池</a>》，一直被网友翻出来，对里面的一些细节实现提了许多问题。其实更推荐大家去阅读后来写的另外一篇关于线程池的文章，《<a href="https://zhuanlan.zhihu.com/p/444375447">当我谈线程池时我谈些什么——线程池学习笔记</a>》。原因很简单，写第一篇线程池文章的时候，自己属实是菜的不行（现在依旧是菜的不行），花了很长时间去学习一些里面用到的C++11的新语法，文章里面讲的重点也是涉及到的C++11语法。所以，更关心线程池本身的实现的话，更适合去看新文章《<a href="https://zhuanlan.zhihu.com/p/444375447">当我谈线程池时我谈些什么——线程池学习笔记</a>》，作为现代C++语法的新学者，想花更多精力在学习现代C++语法的话，适合去看老文章《<a href="https://zhuanlan.zhihu.com/p/367309864">基于C++11实现线程池</a>》。</p>
<p>言归正传，在那篇老文章里有挺多网友提了一些<code>std::thread</code>相关的问题。今天看了会cppreference，写了点代码实践了下，集中回答了一些问题，顺便水篇文章算是学习笔记了。</p>
<span id="more"></span>

<h2 id="std-thread对象构建的新线程何时开始执行"><a href="#std-thread对象构建的新线程何时开始执行" class="headerlink" title="std::thread对象构建的新线程何时开始执行"></a>std::thread对象构建的新线程何时开始执行</h2><p>线程在构造关联的线程对象时立即开始执行，从提供给作为构造函数参数的顶层函数开始。</p>
<p>有几点需要注意：</p>
<ul>
<li>顶层函数的返回值将被忽略，而且若它以抛异常终止，则调用<code>std::terminate</code>。在需要获取返回值时，顶层函数可以通过<code>std::promise</code>或者修改共享变量（可能需要锁机制进行线程同步）。</li>
<li>当使用不带参数的默认构造函数<code>thread()</code>构造<code>std::thread</code>对象时，该对象不表示任何线程，也不会有新线程产生。</li>
<li>当时用移动构造函数<code>thread(thread&amp;&amp;other)</code>构造<code>std::thread</code>对象时，该对象会被构造为表示曾为<code>other</code>所表示的执行线程的<code>std::thread</code>对象。此调用后<code>other</code>不再表示执行线程。</li>
<li><code>std::thread</code>对象不可复制（复制构造函数已被删除）。没有两个<code>std::thread</code>对象会表示同一执行线程。</li>
</ul>
<h2 id="std-thread对象构建新线程时可以传入什么东西作为参数"><a href="#std-thread对象构建新线程时可以传入什么东西作为参数" class="headerlink" title="std::thread对象构建新线程时可以传入什么东西作为参数"></a>std::thread对象构建新线程时可以传入什么东西作为参数</h2><p><code>std::thread</code>常用的构造函数如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; class Function, class... Args &gt;</span></span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">thread</span><span class="params">( Function&amp;&amp; f, Args&amp;&amp;... args )</span></span>;</span><br></pre></td></tr></table></figure>

<p>其中，<code>f</code>为任意可调用对象（Callable），<code>args</code>为任意数目的作为可调用对象<code>f</code>的参数。</p>
<p>可调用对象（Callable）是C++的一个具名要求，常见的函数、成员函数、仿函数（函数对象）都属于可调用对象。</p>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>传入函数的情况最常见也最简单，例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Thread 1 executing\n&quot;</span>;</span><br><span class="line">        ++n;</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">10</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">   <span class="function">std::thread <span class="title">t</span><span class="params">(f1, n + <span class="number">1</span>)</span></span>;</span><br><span class="line">   t.<span class="built_in">join</span>();</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>仅需将函数名与函数参数分别传入即可。</p>
<h3 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h3><p>当需要传入类时，有两种情况，第一种是比较复杂的情况，我们需要传入类的成员函数。例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Thread 3 executing\n&quot;</span>;</span><br><span class="line">            ++n;</span><br><span class="line">            std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">10</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    foo f;</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(&amp;foo::bar, &amp;f)</span></span>; <span class="comment">// t 在对象 f 上运行 foo::bar()</span></span><br><span class="line">   	t.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们需要以<code>std::thread(&amp;类名::成员函数名, &amp;类实例)</code>的格式传入新线程。</p>
<h3 id="仿函数（函数对象）"><a href="#仿函数（函数对象）" class="headerlink" title="仿函数（函数对象）"></a>仿函数（函数对象）</h3><p>仿函数（或称函数对象）便是传入类的第二种情况，此时该类的工作比较简单（单一，并非指实际工作难度），例如标准库中的<code>std::function</code>, <code>std::bind</code>等，又例如第一篇文章中的<code>ThreadWorker</code>类。成为仿函数的类，一般来说需要**重载函数调用运算符()**。在<code>std::thread</code>对象构建新线程后，会自动进行INVOKE操作执行传入的可调用对象。INVOKE操作执行对象为仿函数时，会自动调用仿函数重载的函数调用运算符<code>operator()</code>。例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">baz</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Thread 4 executing\n&quot;</span>;</span><br><span class="line">            ++n;</span><br><span class="line">            std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">10</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(b)</span></span>; <span class="comment">// t 在对象 b 的副本上运行 baz::operator()</span></span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，新线程运行的仿函数实际上是传入时指定的仿函数的副本，这同时也就要求该仿函数是可拷贝的。</p>
<h3 id="函数参数传引用"><a href="#函数参数传引用" class="headerlink" title="函数参数传引用"></a>函数参数传引用</h3><p><code>std::thread</code>对象构造新线程时，会移动或按值复制线程函数的参数。若需要传递引用参数给线程函数，则必须包装它（例如用<code>std::ref</code>或<code>std::cref</code>）。例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">int</span>&amp; n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Thread 2 executing\n&quot;</span>;</span><br><span class="line">        ++n;</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">10</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(f2, std::ref(n))</span></span>; <span class="comment">// 按引用传递</span></span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>暂时就总结了这些，后续若有内容再更新。</p>
<h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><p><a href="https://zh.cppreference.com/w/cpp/thread/thread">std::thread-cppreference.com</a></p>
<p><a href="https://skykeyjoker.com/2021/04/22/C%2B%2B%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">C++并发编程</a></p>
<p><a href="https://paul.pub/cpp-memory-model/">C++内存模型</a></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>C++11</tag>
        <tag>C++14</tag>
        <tag>C++17</tag>
        <tag>C++并发</tag>
        <tag>学习心得</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux低延迟服务器调优</title>
    <url>/2022/01/27/Linux%E4%BD%8E%E5%BB%B6%E8%BF%9F%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%B0%83%E4%BC%98/</url>
    <content><![CDATA[<h1 id="Linux低延迟服务器调优"><a href="#Linux低延迟服务器调优" class="headerlink" title="Linux低延迟服务器调优"></a>Linux低延迟服务器调优</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>本文基于饶萌大佬的《Linux低延迟服务器系统调优》一文总结整理，自行补充了一些细节。大佬博文指路：</p>
<p><a href="https://zhuanlan.zhihu.com/p/58669088">Linux低延迟服务器系统调优</a></p>
<p>低延迟关键不在于低，而在于<strong>稳定</strong>，稳定即可预期，可掌控，这对高频领域来说尤其重要。谈及Linux低延迟技术时，人们经常提到“Kernel Bypass”（内核旁路），即绕过内核，这是因为内核处理不仅慢且延迟不稳定。因此一个延迟要求很高的实时任务是不能触碰内核的，“避免触碰”是一个比Bypass更高的要求：不能以<strong>任何</strong>方式进入内核。中断（Interrupt）是进入内核的方式之一，本文的关键点也在于避免关键线程被中断。即使中断发生时线程是空闲的，但重新回到用户态后CPU缓存被污染了，下一次处理请求的延迟也会变得不稳定。</p>
<span id="more"></span>

<h2 id="绑定核心"><a href="#绑定核心" class="headerlink" title="绑定核心"></a>绑定核心</h2><p>中断是CPU Core收到的，可以让关键线程<strong>绑定</strong>在某个Core上，然后避免各种中断源（IRQ）向这个Core发送中断。</p>
<p>绑定程序在一个核上运行，有两种方法：<code>taskset</code>和<code>sched_setaffinity</code>。</p>
<h3 id="CPU-Affinity"><a href="#CPU-Affinity" class="headerlink" title="CPU Affinity"></a>CPU Affinity</h3><p>中文译作“CPU亲和力”，是指在CMP结构下，能够将一个或多个进程绑定到一个或多个处理器上运行。</p>
<h3 id="查看进程分配的CPU-Core"><a href="#查看进程分配的CPU-Core" class="headerlink" title="查看进程分配的CPU Core"></a>查看进程分配的CPU Core</h3><p>可以使用<code>taskset</code>命令查看：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">taskset -c -p &lt;pid&gt;</span><br></pre></td></tr></table></figure>

<p>运行结构：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">pid 17147&#x27;s current affinity list: 3-5</span><br></pre></td></tr></table></figure>

<p>该CPU亲和力列表表明该进程可能会被安排在3-5中任意一个CPU Core上。</p>
<p>更具体地查看某进程当前正运行在哪个CPU Core上，我们可以使用<code>top</code>命令查看：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">top -p &lt;uid&gt;</span><br></pre></td></tr></table></figure>

<h3 id="taskset"><a href="#taskset" class="headerlink" title="taskset"></a>taskset</h3><p>使用<code>taskset</code>命令将进程绑定到指定核：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">taskset -cp &lt;core&gt; &lt;pid&gt;</span><br></pre></td></tr></table></figure>

<p>如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">taskset -cp 1,2,3 31693</span><br></pre></td></tr></table></figure>

<p>该例会将PID为31693的进程绑定到1-3核上运行。</p>
<h3 id="sched-setaffinity"><a href="#sched-setaffinity" class="headerlink" title="sched_setaffinity"></a>sched_setaffinity</h3><p>编写代码时，我们可以通过<code>sched_setaffinity()</code>函数设置CPU亲和力的掩码，从而将该线程或者进程与指定的CPU绑定。</p>
<p>一个CPU的亲和力掩码用一个<code>cpu_set_t</code>结构体来表示一个CPU集合，下面这几个宏分别对掩码集进行操作：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">CPU_ZERO</span>(<span class="keyword">cpu_set_t</span>* cpusetp);               <span class="comment">// 清空一个集合</span></span><br><span class="line"><span class="built_in">CPU_SET</span>(<span class="keyword">size_t</span> cpu, <span class="keyword">cpu_set_t</span>* cpusetp);    <span class="comment">// 加入CPU Core到集合</span></span><br><span class="line"><span class="built_in">CPU_CLR</span>(<span class="keyword">size_t</span> cpu, <span class="keyword">cpu_set_t</span>* cpusetp);    <span class="comment">// 从集合中删除指定的CPU Core</span></span><br><span class="line"><span class="built_in">CPU_ISSET</span>(<span class="keyword">size_t</span> cpu, <span class="keyword">cpu_set_t</span>* cpusetp);  <span class="comment">// 检查一个CPU Core是否在集合中</span></span><br></pre></td></tr></table></figure>

<p>使用<code>sched_setaffinity()</code>与<code>sched*_*getaffinity()</code>等函数需要引进头文件<code>sched.h</code>。</p>
<ul>
<li>头文件：<code>sched.h</code></li>
<li><code>int sched_setaffinity(pid_t pid, size_t cpusetsize, const cpu_set_t* mask)</code><br>该函数将PID为<em>pid</em>的进程设置为运行在<em>mask</em>指定的CPU Core上。<br>* 若<em>pid</em>为0，则表示指定当前进程。<br>* <em>cpusetsize</em>为<em>mask</em>的大小，通常为<code>sizeof(cpu_set_t)</code>。<br>* <em>cpuset</em>即用<code>cpu_set_t</code>结构体表示的CPU Core集合。<br>* 函数返回0表示成功，失败则返回-1。</li>
<li><code>int sched_getaffinity(pid_t pid, size_t cpusetsize, cpu_set_t* mask)</code><br>函数获取PID为<em>pid</em>的进程CPU亲和力掩码，并保存在<em>mask</em>结构体中，即获得指定pid当前可以运行在哪些CPU上。<br>* 若<em>pid</em>为0，则表示指定当前进程。<br>* <em>cpusetsize</em>为<em>mask</em>的大小，通常为<code>sizeof(cpu_set_t)</code>。<br>* <em>cpuset</em>即用<code>cpu_set_t</code>结构体表示的CPU Core集合。<br>* 函数返回0表示成功，失败则返回-1。</li>
</ul>
<p>使用示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __USE_GNU</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// CPU Core Binded sched_setaffinity</span></span><br><span class="line">    <span class="keyword">cpu_set_t</span> mask;  <span class="comment">// CPU Core Set</span></span><br><span class="line">    <span class="built_in">CPU_ZERO</span>(&amp;mask);  <span class="comment">// Set Zero</span></span><br><span class="line">    <span class="built_in">CPU_SET</span>(<span class="number">6</span>, &amp;mask);  <span class="comment">// Add core to set</span></span><br><span class="line">    <span class="built_in">CPU_SET</span>(<span class="number">7</span>, &amp;mask);</span><br><span class="line">    <span class="built_in">CPU_SET</span>(<span class="number">8</span>, &amp;mask);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> rc;</span><br><span class="line">    <span class="keyword">if</span>((rc = <span class="built_in">sched_setaffinity</span>(<span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(mask), &amp;mask))</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Warning: Set affinity failed!&quot;</span>&lt;&lt;<span class="built_in">strerror</span>(rc)&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">cpu_set_t</span> get;</span><br><span class="line">        <span class="keyword">if</span>((rc = <span class="built_in">sched_getaffinity</span>(<span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(get), &amp;get)))</span><br><span class="line">        &#123;</span><br><span class="line">             cout&lt;&lt;<span class="string">&quot;Waring: Could not get thread affinity.&quot;</span>&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">pid_t</span> pid = <span class="built_in">getpid</span>();</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Current PID: &quot;</span>&lt;&lt;pid&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">size_t</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="built_in">sysconf</span>(_SC_NPROCESSORS_CONF); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">CPU_ISSUE</span>(i, &amp;get))</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;Running on processor: &quot;</span>&lt;&lt;i&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：若使用到pthread，则需要将pthread.h放到sched.h之后，并在sched.h之前声明#define __USE_GNU，否则会出现undefined reference CPU_ZERO等错误。</p>
</blockquote>
<h2 id="屏蔽硬中断（硬盘、网卡）"><a href="#屏蔽硬中断（硬盘、网卡）" class="headerlink" title="屏蔽硬中断（硬盘、网卡）"></a>屏蔽硬中断（硬盘、网卡）</h2><p>中断源（IRQ）向CPU Core发送中断，CPU Core调用中断处理程序对中断进程处理。我们可以通过改写<code>/proc/irq/*/smp_affinity</code>文件，避免中断源（IRQ）向某些CPU Core发送中断。该方法对硬盘、网卡等设备引起的硬中断有效。</p>
<h3 id="查看设备中断数据"><a href="#查看设备中断数据" class="headerlink" title="查看设备中断数据"></a>查看设备中断数据</h3><p>通过查看<code>/proc/interrupts</code>文件可查看设备中断数据：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">           CPU0       CPU1       CPU2       CPU3       CPU4       CPU5       CPU6       CPU7       </span><br><span class="line">  0:         17          0          0          0          0          0          0          0   IO-APIC   2-edge      timer</span><br><span class="line">  8:          0          0          0          0          0          1          0          0   IO-APIC   8-edge      rtc0</span><br><span class="line">  9:       4058        258        157         14        464        454         34        134   IO-APIC   9-fasteoi   acpi</span><br><span class="line"> 16:     137153      19574      11430      10138      47072      27502      15934      10113   IO-APIC  16-fasteoi   ahci[0000:05:00.0], xhci-hcd:usb1, nvkm</span><br><span class="line"> 17:         16          3          1          9         35          2          2          1   IO-APIC  17-fasteoi   snd_hda_intel:card1</span><br><span class="line"> 18:      88952       2170       1592       1253       4255       5430       1790       1738   IO-APIC  18-fasteoi   wlp3s0</span><br><span class="line"> 22:     172111       2954       2515       1897       5000       3684       2479       2513   IO-APIC  22-fasteoi   snd_hda_intel:card0</span><br><span class="line">NMI:          0          0          0          0          0          0          0          0   Non-maskable interrupts</span><br><span class="line">LOC:     395090     279787     239243     235695     233918      90471      94234      90479   Local timer interrupts</span><br><span class="line">SPU:          0          0          0          0          0          0          0          0   Spurious interrupts</span><br><span class="line">PMI:          0          0          0          0          0          0          0          0   Performance monitoring interrupts</span><br><span class="line">IWI:          0          0          0          1          1          1          0          3   IRQ work interrupts</span><br><span class="line">RTR:          6          0          0          0          0          0          0          0   APIC ICR read retries</span><br><span class="line">RES:       7425       5663       4375       3801       3051       2825       1963       1787   Rescheduling interrupts</span><br><span class="line">CAL:         31         29         24         22         36         28         34         31   Function call interrupts</span><br><span class="line">TLB:      10387      11374      10758      11769       7566       8508       8799       7195   TLB shootdowns</span><br><span class="line">TRM:          2          2          2          2          2          2          2          2   Thermal event interrupts</span><br><span class="line">THR:          0          0          0          0          0          0          0          0   Threshold APIC interrupts</span><br><span class="line">MCE:          0          0          0          0          0          0          0          0   Machine check exceptions</span><br><span class="line">MCP:         17         17         17         17         17         17         17         17   Machine check polls</span><br><span class="line">ERR:          0</span><br><span class="line">MIS:          0</span><br><span class="line">PIN:          0          0          0          0          0          0          0          0   Posted-interrupt notification event</span><br><span class="line">PIW:          0          0          0          0          0          0          0          0   Posted-interrupt wakeup event</span><br></pre></td></tr></table></figure>

<ul>
<li>第一列是IRQ号</li>
<li>第二列开始表示某CPU内核被多少次中断。</li>
</ul>
<h3 id="SMP-AFFINITY"><a href="#SMP-AFFINITY" class="headerlink" title="SMP_AFFINITY"></a>SMP_AFFINITY</h3><p>SMP，即symmetric multiprocessing（对称多处理器），通过多个处理器处理程序的方式。smp_affinity文件处理一个IRQ的中断亲和性。在smp_affinity文件结合每个IRQ号在<code>/proc/irq/&#123;IRQ_NUMBER&#125;/smp_affinity</code>文件。该文件的值是一个16进制掩码表示系统的所有CPU核。</p>
<p>例如，Solarflare网卡的设备名为eth1，其中断如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grep eth1 /proc/interrupts</span><br></pre></td></tr></table></figure>

<p>输出如下：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">64:    95218  168786727  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  IR-PCI-MSI-edge  eth1-0</span><br><span class="line">65:    38440  53649095   0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  IR-PCI-MSI-edge  eth1-1</span><br><span class="line">66:    6207   1011519    0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  IR-PCI-MSI-edge  eth1-ptp</span><br></pre></td></tr></table></figure>

<p>可以看到eth1设备共有三个IRQ号：64,65,66，其相对应的smp_afffinity文件时：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat /proc/irq/64/smp_affinity</span><br><span class="line">cat /proc/irq/65/smp_affinity</span><br><span class="line">cat /proc/irq/66/smp_affinity</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000,00000000,00000000,0000000f</span><br><span class="line">0000,00000000,00000000,0000000f</span><br><span class="line">0000,00000000,00000000,0000000f</span><br></pre></td></tr></table></figure>

<p>smp_affinity是16进制表示，f就是二进制的1111，表示0-3这四个CPU Core都会参与处理中断。</p>
<p>假设我们想要指定仅0-1这两个核心处理中断，则可以写入如下数据到smp_affinity：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> 3 &gt; /proc/irq/64/smp_affinity</span><br><span class="line"><span class="built_in">echo</span> 3 &gt; /proc/irq/65/smp_affinity</span><br><span class="line"><span class="built_in">echo</span> 3 &gt; /proc/irq/66/smp_affinity</span><br></pre></td></tr></table></figure>

<h2 id="屏蔽软中断（Work-queue）"><a href="#屏蔽软中断（Work-queue）" class="headerlink" title="屏蔽软中断（Work queue）"></a>屏蔽软中断（Work queue）</h2><p>workqueue是自kernel2.6引入的一种任务执行机制，和softirq，tasklet并称下半部（bottom half）三剑客。workqueue在进程上下文异步执行任务，能够进行睡眠。可以通过改写<code>/sys/devices/virtual/workqueue/*/cpumask</code>文件实现屏蔽Work queue的软中断。</p>
<p><code>/sys/devices/virtual/workqueue/cpumask</code>文件中记录了全局的cpumask，可以影响所有的workqueue。文件内容格式与smp_affinity相同：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat /sys/devices/virtual/workqueue/cpumask</span><br></pre></td></tr></table></figure>

<p>输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000,00000000,00000000,00000007</span><br></pre></td></tr></table></figure>

<p>代表0-2这三个CPU Core用来处理work queue，我们可以通过写入”f”来仅让与核心进程无关的0-3这四个CPU Core参与work queue处理：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;f&#x27;</span> &gt; /sys/devices/virtual/workqueue/cpumask</span><br></pre></td></tr></table></figure>

<h2 id="屏蔽软中断（Local-Timer-Interrupt）"><a href="#屏蔽软中断（Local-Timer-Interrupt）" class="headerlink" title="屏蔽软中断（Local Timer Interrupt）"></a>屏蔽软中断（Local Timer Interrupt）</h2><p>Linux的scheduler time slice是通过LOC实现的，如果我们让一个线程独占一个CPU Core，就不需要scheduler在这个CPU Core上切换进程。可以通过<code>isolcpus</code>系统启动选项隔离一些核，让他们只能被绑定的线程使用。同时，我们还可以启用“adaptive-ticks”模式，达到减少独占线程收到LOC频率的效果，这可以通过<code>nohz_full</code>和<code>rcu_nocbs</code>启动选项实现。</p>
<p>假设令6-8三个核心屏蔽软中断，我们需要在系统启动选项中加入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nohz=on nohz_full=6-8 rcu_nocbs=6-8</span><br></pre></td></tr></table></figure>

<p>进入adaptive-ticks模式后，如果CPU Core上的running task只有一个时，系统向其发送的LOC频率会显著降低，但LOC不能被完全屏蔽，系统内核的一些操作比如计算CPU负载等仍然需要周期性的LOC。</p>
<h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><p>中断和smp_affinity：</p>
<p><a href="https://huataihuang.gitbooks.io/cloud-atlas/content/os/linux/kernel/cpu/interrupt_and_smp_affinity.html">中断和smp_affinity</a></p>
<p>SolarFlare资源汇总：</p>
<p><a href="https://williamlfang.github.io/shared/2019-12-20-solarflare%E8%B5%84%E6%BA%90%E6%B1%87%E6%80%BB/">SolarFlare资源汇总</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>学习心得</tag>
        <tag>Linux</tag>
        <tag>低延迟系统</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt实现简易心跳包机制</title>
    <url>/2022/01/01/tcpheart/</url>
    <content><![CDATA[<h1 id="Qt实现简易心跳包机制"><a href="#Qt实现简易心跳包机制" class="headerlink" title="Qt实现简易心跳包机制"></a>Qt实现简易心跳包机制</h1><p>因为网络通信的不稳定性，在一些实时性、网络稳定性要求较高的情境下，我们需要一个实时检测客户端与服务端之间的连接状态和通信功能是否运行正常的机制，心跳包机制便是其中之一。接下来我会讲一下在之前的一个小项目中，利用Qt实现的简易心跳包检测机制。</p>
<span id="more"></span>

<h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p><img src="%E5%AE%A2%E6%88%B7%E7%AB%AF.jpg" alt="客户端"></p>
<p><img src="%E6%9C%8D%E5%8A%A1%E7%AB%AF.jpg" alt="服务端"></p>
<p>心跳包检测的原理是客户端定时向服务端发送心跳包，服务端收到心跳包后立即回复客户端。此间客户端检查心跳包是否发送成功以及是否超时。在一些实时性要求比较高的情境下，检测心跳包超时是有必要的。可以通过记录等待回复的心跳包数来实现检测心跳包超时。</p>
<h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><h3 id="启动定时器"><a href="#启动定时器" class="headerlink" title="启动定时器"></a>启动定时器</h3><p>客户端的核心在于定时发送心跳包，这里我们利用一个<em>TcpHeart</em>类来实现定时发送心跳包。</p>
<p><em>TcpHeart</em>类声明如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QObject&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QTimer&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TcpHeart</span> :</span> <span class="keyword">public</span> QObject &#123;</span><br><span class="line">	Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">TcpHeart</span><span class="params">(QObject* parent = <span class="number">0</span>)</span></span>;</span><br><span class="line">	~<span class="built_in">TcpHeart</span>() <span class="keyword">noexcept</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">startHeartTimer</span><span class="params">()</span></span>;  <span class="comment">// 启动定时器</span></span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">sigHeartBad</span><span class="params">()</span></span>;  <span class="comment">// 心跳包错误信号</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">sigHeartReq</span><span class="params">()</span></span>;  <span class="comment">// 发送心跳包信号</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">slotTimeOut</span><span class="params">()</span></span>;  <span class="comment">// 定时事件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">slotHeartBack</span><span class="params">()</span></span>;  <span class="comment">// 收到服务端心跳包回复</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	QTimer* m_heart_timer;</span><br><span class="line">	<span class="keyword">int</span> m_count;  <span class="comment">// 等待回复心跳包累计数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><em>TcpHeart</em>核心是利用QTimer实现一个定时任务：启动一个定时器，定时器timeOut消息发出后，检测当前等待回复的心跳包数量。<strong>若等待回复的心跳包数量≤3</strong>，则可以继续发送心跳包，并增加等待回复的心跳包数量；否则采取心跳包超时处理，停止计时器并发送心跳包错误消息。</p>
<p>定时事件<code>slotTimeOut()</code>实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpHeart::slotTimeOut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (m_count &gt; <span class="number">2</span>) &#123;</span><br><span class="line">		m_count = <span class="number">0</span>;</span><br><span class="line">		m_heart_timer-&gt;<span class="built_in">stop</span>();</span><br><span class="line">		<span class="function">emit <span class="title">sigHeartBad</span><span class="params">()</span></span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	m_count++;</span><br><span class="line">	<span class="function">emit <span class="title">sigHeartReq</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在收到服务端心跳包回复后，我们需要将等待回复的心跳包计数清零。这里需要直接将计数清零，因为每次收到回复后，超时检测机制都应重新启动。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpHeart::slotHeartBack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	m_count = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>TcpHeart</em>的完整实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">TcpHeart::<span class="built_in">TcpHeart</span>(QObject *parent)</span><br><span class="line">	: <span class="built_in">QObject</span>(parent) &#123;</span><br><span class="line">	m_heart_timer = <span class="keyword">new</span> <span class="built_in">QTimer</span>(<span class="keyword">this</span>);</span><br><span class="line">	m_count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">connect</span>(m_heart_timer, &amp;QTimer::timeout, <span class="keyword">this</span>, &amp;TcpHeart::slotTimeOut);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TcpHeart::~<span class="built_in">TcpHeart</span>() <span class="keyword">noexcept</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpHeart::startHeartTimer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	m_heart_timer-&gt;<span class="built_in">start</span>(<span class="number">2000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpHeart::slotTimeOut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (m_count &gt; <span class="number">2</span>) &#123;</span><br><span class="line">		m_count = <span class="number">0</span>;</span><br><span class="line">		m_heart_timer-&gt;<span class="built_in">stop</span>();</span><br><span class="line">		<span class="function">emit <span class="title">sigHeartBad</span><span class="params">()</span></span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	m_count++;</span><br><span class="line">	<span class="function">emit <span class="title">sigHeartReq</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpHeart::slotHeartBack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	m_count = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="发送心跳包"><a href="#发送心跳包" class="headerlink" title="发送心跳包"></a>发送心跳包</h3><p>正式实现心跳包机制的类是<em>StatusClient</em>。<em>StatusClient</em>类声明如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QDebug&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QObject&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QTcpSocket&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;TcpHeart.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;json.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StatusClient</span> :</span> <span class="keyword">public</span> QObject &#123;</span><br><span class="line">	Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">StatusClient</span><span class="params">(<span class="keyword">const</span> QString host, <span class="keyword">const</span> <span class="keyword">int</span> port, QObject *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">connectedToServer</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">sigHeartBack</span><span class="params">()</span></span>;              <span class="comment">// 心跳包返回</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">signalDisconnectedToServer</span><span class="params">()</span></span>;<span class="comment">//  心跳包断连</span></span><br><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">slotStatusReadyRead</span><span class="params">()</span></span>; <span class="comment">// 客户端状态信道</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">slotWriteHeartSocket</span><span class="params">()</span></span>;<span class="comment">// 写心跳包</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">slotHeartBad</span><span class="params">()</span></span>;        <span class="comment">// 心跳包掉线处理</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">// 客户端状态信道</span></span><br><span class="line">	QTcpSocket *_statusSocket;<span class="comment">// 客户端状态信道</span></span><br><span class="line">	TcpHeart *heart;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	QString m_host;</span><br><span class="line">	<span class="keyword">int</span> m_port;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在我之前的那个小项目中，客户端服务端利用JSON进行通信，定义了一些双方之间通信的一些消息格式，如code字段区分正常消息与心跳包消息。</p>
<p><em>StatusClient</em>首先与心跳包服务器建立链接，在收到服务器端的”OK”消息后，便利用<em>TcpHeart</em>类开启定时器，定时向服务器发送心跳包。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StatusClient::slotStatusReadyRead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 收到服务端发来的客户端状态查询</span></span><br><span class="line">	QByteArray data;</span><br><span class="line">	data = _statusSocket-&gt;<span class="built_in">readAll</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">using</span> Json = nlohmann::json;</span><br><span class="line">	<span class="comment">// 判断是否为状态查询</span></span><br><span class="line">	QString dataStr = QString::<span class="built_in">fromUtf8</span>(data);</span><br><span class="line">	Json json = Json::<span class="built_in">parse</span>(dataStr.<span class="built_in">toUtf8</span>(), <span class="literal">nullptr</span>, <span class="literal">false</span>);</span><br><span class="line">	<span class="keyword">int</span> code = json[<span class="string">&quot;code&quot;</span>].get&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (code == <span class="number">2</span>) &#123;</span><br><span class="line">		QString msgStr = QString::<span class="built_in">fromStdString</span>(json[<span class="string">&quot;Msg&quot;</span>].get&lt;std::string&gt;());</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (msgStr == <span class="string">&quot;OK&quot;</span>)<span class="comment">// 服务器返回&quot;OK&quot;，开启心跳包检测</span></span><br><span class="line">		&#123;</span><br><span class="line">			heart = <span class="keyword">new</span> TcpHeart;</span><br><span class="line">			<span class="comment">// 开始心跳检测</span></span><br><span class="line">			heart-&gt;<span class="built_in">startHeartTimer</span>();</span><br><span class="line">			<span class="built_in">connect</span>(heart, &amp;TcpHeart::sigHeartReq, <span class="keyword">this</span>, &amp;StatusClient::slotWriteHeartSocket);<span class="comment">// 发送心跳包</span></span><br><span class="line">			<span class="built_in">connect</span>(<span class="keyword">this</span>, &amp;StatusClient::sigHeartBack, heart, &amp;TcpHeart::slotHeartBack);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 处理心跳包异常</span></span><br><span class="line">			<span class="built_in">connect</span>(heart, &amp;TcpHeart::sigHeartBad, <span class="keyword">this</span>, &amp;StatusClient::slotHeartBad);</span><br><span class="line">		&#125;</span><br><span class="line">        </span><br><span class="line">		...</span><br><span class="line">           </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>向服务端定时发送心跳包消息，若发送失败，进行心跳包掉线处理：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StatusClient::slotWriteHeartSocket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	QByteArray data;</span><br><span class="line">	<span class="comment">// 构建状态返回</span></span><br><span class="line">	<span class="keyword">using</span> Json = nlohmann::json;</span><br><span class="line">	Json jsonValue;</span><br><span class="line">	jsonValue[<span class="string">&quot;code&quot;</span>] = <span class="number">2</span>;</span><br><span class="line">	jsonValue[<span class="string">&quot;Msg&quot;</span>] = <span class="string">&quot;Heart&quot;</span>;</span><br><span class="line">	data = QString::<span class="built_in">fromStdString</span>(jsonValue.<span class="built_in">dump</span>(<span class="number">2</span>)).<span class="built_in">toUtf8</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 状态信道，向服务端发送心跳包</span></span><br><span class="line">	<span class="built_in">qDebug</span>() &lt;&lt; <span class="keyword">this</span>-&gt;<span class="built_in">thread</span>() &lt;&lt; <span class="string">&quot;发送一次心跳包&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 状态信道</span></span><br><span class="line">	<span class="keyword">bool</span> ret = _statusSocket-&gt;<span class="built_in">write</span>(data);</span><br><span class="line">	_statusSocket-&gt;<span class="built_in">waitForBytesWritten</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!ret) &#123;</span><br><span class="line">		<span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;发送心跳包失败&quot;</span>;</span><br><span class="line">		<span class="function">emit <span class="title">signalDisconnectedToServer</span><span class="params">()</span></span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>若从客户端收到心跳包回复，则重启<em>TcpHeart</em>对象的超时检测机制：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StatusClient::slotStatusReadyRead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 收到服务端发来的客户端状态查询</span></span><br><span class="line">	QByteArray data;</span><br><span class="line">	data = _statusSocket-&gt;<span class="built_in">readAll</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">using</span> Json = nlohmann::json;</span><br><span class="line">	<span class="comment">// 判断是否为状态查询</span></span><br><span class="line">	QString dataStr = QString::<span class="built_in">fromUtf8</span>(data);</span><br><span class="line">	Json json = Json::<span class="built_in">parse</span>(dataStr.<span class="built_in">toUtf8</span>(), <span class="literal">nullptr</span>, <span class="literal">false</span>);</span><br><span class="line">	<span class="keyword">int</span> code = json[<span class="string">&quot;code&quot;</span>].get&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (code == <span class="number">2</span>) &#123;</span><br><span class="line">		QString msgStr = QString::<span class="built_in">fromStdString</span>(json[<span class="string">&quot;Msg&quot;</span>].get&lt;std::string&gt;());</span><br><span class="line"></span><br><span class="line">		...</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 心跳反馈</span></span><br><span class="line">		<span class="keyword">if</span> (msgStr == <span class="string">&quot;HEART_BACK&quot;</span>) &#123;</span><br><span class="line">			<span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;HEART BACK ONCE&quot;</span>;</span><br><span class="line">			<span class="function">emit <span class="title">sigHeartBack</span><span class="params">()</span></span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="心跳包掉线处理"><a href="#心跳包掉线处理" class="headerlink" title="心跳包掉线处理"></a>心跳包掉线处理</h3><p>收到<em>TcpHeart</em>的心跳包超时消息后，进行相应的掉线处理：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StatusClient::slotHeartBad</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 断线处理</span></span><br><span class="line">	<span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;心跳包断线&quot;</span>;</span><br><span class="line">	_statusSocket-&gt;<span class="built_in">disconnectFromHost</span>();</span><br><span class="line">	<span class="function">emit <span class="title">signalDisconnectedToServer</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="完整实现"><a href="#完整实现" class="headerlink" title="完整实现"></a>完整实现</h3><p>客户端完整实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">StatusClient::<span class="built_in">StatusClient</span>(<span class="keyword">const</span> QString host, <span class="keyword">const</span> <span class="keyword">int</span> port, QObject *parent)</span><br><span class="line">	: <span class="built_in">m_host</span>(host),</span><br><span class="line">	  <span class="built_in">m_port</span>(port),</span><br><span class="line">	  <span class="built_in">QObject</span>(parent) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StatusClient::connectedToServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	_statusSocket = <span class="keyword">new</span> QTcpSocket;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">connect</span>(_statusSocket, &amp;QTcpSocket::readyRead, <span class="keyword">this</span>, &amp;StatusClient::slotStatusReadyRead);</span><br><span class="line">	<span class="built_in">connect</span>(_statusSocket, &amp;QTcpSocket::disconnected, <span class="keyword">this</span>, &amp;StatusClient::signalDisconnectedToServer);</span><br><span class="line"></span><br><span class="line">	_statusSocket-&gt;<span class="built_in">connectToHost</span>(m_host, m_port);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!_statusSocket-&gt;<span class="built_in">waitForConnected</span>()) &#123;</span><br><span class="line">		<span class="function">emit <span class="title">signalDisconnectedToServer</span><span class="params">()</span></span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StatusClient::slotStatusReadyRead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 收到服务端发来的客户端状态查询</span></span><br><span class="line">	QByteArray data;</span><br><span class="line">	data = _statusSocket-&gt;<span class="built_in">readAll</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">using</span> Json = nlohmann::json;</span><br><span class="line">	<span class="comment">// 判断是否为状态查询</span></span><br><span class="line">	QString dataStr = QString::<span class="built_in">fromUtf8</span>(data);</span><br><span class="line">	Json json = Json::<span class="built_in">parse</span>(dataStr.<span class="built_in">toUtf8</span>(), <span class="literal">nullptr</span>, <span class="literal">false</span>);</span><br><span class="line">	<span class="keyword">int</span> code = json[<span class="string">&quot;code&quot;</span>].get&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (code == <span class="number">2</span>) &#123;</span><br><span class="line">		QString msgStr = QString::<span class="built_in">fromStdString</span>(json[<span class="string">&quot;Msg&quot;</span>].get&lt;std::string&gt;());</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (msgStr == <span class="string">&quot;OK&quot;</span>)<span class="comment">// 服务器返回&quot;OK&quot;，开启心跳包检测</span></span><br><span class="line">		&#123;</span><br><span class="line">			heart = <span class="keyword">new</span> TcpHeart;</span><br><span class="line">			<span class="comment">// 开始心跳检测</span></span><br><span class="line">			heart-&gt;<span class="built_in">startHeartTimer</span>();</span><br><span class="line">			<span class="built_in">connect</span>(heart, &amp;TcpHeart::sigHeartReq, <span class="keyword">this</span>, &amp;StatusClient::slotWriteHeartSocket);<span class="comment">// 发送心跳包</span></span><br><span class="line">			<span class="built_in">connect</span>(<span class="keyword">this</span>, &amp;StatusClient::sigHeartBack, heart, &amp;TcpHeart::slotHeartBack);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 处理心跳包异常</span></span><br><span class="line">			<span class="built_in">connect</span>(heart, &amp;TcpHeart::sigHeartBad, <span class="keyword">this</span>, &amp;StatusClient::slotHeartBad);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 心跳反馈</span></span><br><span class="line">		<span class="keyword">if</span> (msgStr == <span class="string">&quot;HEART_BACK&quot;</span>) &#123;</span><br><span class="line">			<span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;HEART BACK ONCE&quot;</span>;</span><br><span class="line">			<span class="function">emit <span class="title">sigHeartBack</span><span class="params">()</span></span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StatusClient::slotWriteHeartSocket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	QByteArray data;</span><br><span class="line">	<span class="comment">// 构建状态返回</span></span><br><span class="line">	<span class="keyword">using</span> Json = nlohmann::json;</span><br><span class="line">	Json jsonValue;</span><br><span class="line">	jsonValue[<span class="string">&quot;code&quot;</span>] = <span class="number">2</span>;</span><br><span class="line">	jsonValue[<span class="string">&quot;Msg&quot;</span>] = <span class="string">&quot;Heart&quot;</span>;</span><br><span class="line">	data = QString::<span class="built_in">fromStdString</span>(jsonValue.<span class="built_in">dump</span>(<span class="number">2</span>)).<span class="built_in">toUtf8</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 状态信道，向服务端发送心跳包</span></span><br><span class="line">	<span class="built_in">qDebug</span>() &lt;&lt; <span class="keyword">this</span>-&gt;<span class="built_in">thread</span>() &lt;&lt; <span class="string">&quot;发送一次心跳包&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 状态信道</span></span><br><span class="line">	<span class="keyword">bool</span> ret = _statusSocket-&gt;<span class="built_in">write</span>(data);</span><br><span class="line">	_statusSocket-&gt;<span class="built_in">waitForBytesWritten</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!ret) &#123;</span><br><span class="line">		<span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;发送心跳包失败&quot;</span>;</span><br><span class="line">		<span class="function">emit <span class="title">signalDisconnectedToServer</span><span class="params">()</span></span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StatusClient::slotHeartBad</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 断线处理</span></span><br><span class="line">	<span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;心跳包断线&quot;</span>;</span><br><span class="line">	_statusSocket-&gt;<span class="built_in">disconnectFromHost</span>();</span><br><span class="line">	<span class="function">emit <span class="title">signalDisconnectedToServer</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><p>服务端<em>StatusServer</em>声明如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QDebug&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QObject&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QTcpServer&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QTcpSocket&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;json.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StatusServer</span> :</span> <span class="keyword">public</span> QObject &#123;</span><br><span class="line">	Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">StatusServer</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> statusPort, QObject *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">serverEstablished</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">serverError</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">establishServer</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">slotNewStatusConnection</span><span class="params">()</span></span>;<span class="comment">// 状态信道链接</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">slotStatusReadyRead</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">// 状态信道</span></span><br><span class="line">	QTcpServer *_tcpStatusServer;</span><br><span class="line">	QList&lt;QTcpSocket *&gt; _tcpStatusClients;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> m_statusPort;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>服务端逻辑很简单，启动监听，保存客户端的链接，向客户端发送心跳初始化消息并回复客户端的心跳包。完整实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">StatusServer::<span class="built_in">StatusServer</span>(<span class="keyword">const</span> <span class="keyword">int</span> statusPort, QObject *parent)</span><br><span class="line">	: <span class="built_in">m_statusPort</span>(statusPort),</span><br><span class="line">	  <span class="built_in">QObject</span>(parent) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StatusServer::establishServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	_tcpStatusServer = <span class="keyword">new</span> QTcpServer;</span><br><span class="line">	<span class="keyword">bool</span> ret = _tcpStatusServer-&gt;<span class="built_in">listen</span>(QHostAddress::Any, m_statusPort);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!ret) &#123;</span><br><span class="line">		<span class="function">emit <span class="title">serverError</span><span class="params">()</span></span>;</span><br><span class="line">		<span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;状态服务器建立失败&quot;</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span></span><br><span class="line">		emit <span class="built_in">serverEstablished</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">connect</span>(_tcpStatusServer, &amp;QTcpServer::newConnection, <span class="keyword">this</span>, &amp;StatusServer::slotNewStatusConnection);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StatusServer::slotNewStatusConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 处理状态信道的新连接</span></span><br><span class="line">	QTcpSocket *currentSocket = _tcpStatusServer-&gt;<span class="built_in">nextPendingConnection</span>();</span><br><span class="line">	_tcpStatusClients.<span class="built_in">push_back</span>(currentSocket);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 向客户端发送初始化消息，启动心跳包</span></span><br><span class="line">	<span class="keyword">using</span> Json = nlohmann::json;</span><br><span class="line">	QByteArray sendData;</span><br><span class="line">	Json sendJsonData;</span><br><span class="line">	sendJsonData[<span class="string">&quot;code&quot;</span>] = <span class="number">2</span>;</span><br><span class="line">	sendJsonData[<span class="string">&quot;Msg&quot;</span>] = <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">	sendData = QString::<span class="built_in">fromStdString</span>(sendJsonData.<span class="built_in">dump</span>(<span class="number">2</span>)).<span class="built_in">toUtf8</span>();</span><br><span class="line">	currentSocket-&gt;<span class="built_in">write</span>(sendData);</span><br><span class="line">	currentSocket-&gt;<span class="built_in">flush</span>();</span><br><span class="line">	currentSocket-&gt;<span class="built_in">waitForBytesWritten</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">connect</span>(currentSocket, &amp;QTcpSocket::readyRead, <span class="keyword">this</span>, &amp;StatusServer::slotStatusReadyRead);</span><br><span class="line">	<span class="built_in">connect</span>(currentSocket, &amp;QTcpSocket::disconnected, [=, <span class="keyword">this</span>]() &#123;</span><br><span class="line">		_tcpStatusClients.<span class="built_in">removeAll</span>(currentSocket);</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StatusServer::slotStatusReadyRead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;心跳包thread&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;<span class="built_in">thread</span>();</span><br><span class="line">	<span class="comment">// 状态信道，处理客户端发来的心跳包</span></span><br><span class="line">	QTcpSocket *currentSocket = (QTcpSocket *) <span class="built_in">sender</span>();</span><br><span class="line">	QByteArray msgData = currentSocket-&gt;<span class="built_in">readAll</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">using</span> Json = nlohmann::json;</span><br><span class="line">	Json jsonData = Json::<span class="built_in">parse</span>(msgData.<span class="built_in">data</span>(), <span class="literal">nullptr</span>, <span class="literal">false</span>);</span><br><span class="line">	<span class="keyword">int</span> code = jsonData[<span class="string">&quot;code&quot;</span>].get&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (code == <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="built_in">qDebug</span>() &lt;&lt; currentSocket &lt;&lt; <span class="string">&quot;收到一次心跳包&quot;</span>;</span><br><span class="line">		QString msg = QString::<span class="built_in">fromStdString</span>(jsonData[<span class="string">&quot;Msg&quot;</span>].get&lt;std::string&gt;());</span><br><span class="line">		<span class="keyword">if</span> (msg == <span class="string">&quot;Heart&quot;</span>) &#123;</span><br><span class="line">			QByteArray sendData;</span><br><span class="line">			Json sendJsonData;</span><br><span class="line">			sendJsonData[<span class="string">&quot;code&quot;</span>] = <span class="number">2</span>;</span><br><span class="line">			sendJsonData[<span class="string">&quot;Msg&quot;</span>] = <span class="string">&quot;HEART_BACK&quot;</span>;</span><br><span class="line">			sendData = QString::<span class="built_in">fromStdString</span>(sendJsonData.<span class="built_in">dump</span>(<span class="number">2</span>)).<span class="built_in">toUtf8</span>();</span><br><span class="line">			currentSocket-&gt;<span class="built_in">write</span>(sendData);</span><br><span class="line">			currentSocket-&gt;<span class="built_in">flush</span>();</span><br><span class="line">			currentSocket-&gt;<span class="built_in">waitForBytesWritten</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>学习心得</tag>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title>当我谈线程池时我谈些什么</title>
    <url>/2021/12/12/%E5%BD%93%E6%88%91%E8%B0%88%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%97%B6%E6%88%91%E8%B0%88%E4%BA%9B%E4%BB%80%E4%B9%88/</url>
    <content><![CDATA[<h1 id="当我谈线程池时我谈些什么"><a href="#当我谈线程池时我谈些什么" class="headerlink" title="当我谈线程池时我谈些什么"></a>当我谈线程池时我谈些什么</h1><p>最近跟着purecpp社区里的两篇博文复习了一下两种线程池的C++实现（单任务队列、多任务队列），相比于之前那篇C++11实现线程池的博文，语言版本进行了一点小更新（C++14-C++17）。在这里结合代码记录一下学习心得。</p>
<blockquote>
<p>12.12，然然首播一周年辣（嘉然小姐首播周年快乐）</p>
</blockquote>
<span id="more"></span>

<h2 id="单任务队列线程池"><a href="#单任务队列线程池" class="headerlink" title="单任务队列线程池"></a>单任务队列线程池</h2><p>用现代的C++标准库（线程+锁+条件变量）实现一个单任务队列的线程池非常简单。就像之前那篇博文里面讲的一样，原理非常简单，对新手而言最复杂的其实就是C++11众多的新语言特性罢了。</p>
<p>一个简易的单任务队列线程池的实现思路：在线程池构造时初始化线程数，在析构时停止线程池。对外也只需要提供提交任务的接口就够了。</p>
<h3 id="接口设计"><a href="#接口设计" class="headerlink" title="接口设计"></a>接口设计</h3><h4 id="返回类型"><a href="#返回类型" class="headerlink" title="返回类型"></a>返回类型</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">ThreadPool</span><span class="params">(<span class="keyword">size_t</span> threads = std::thread::hardware_concurrency())</span></span>;  <span class="comment">// 构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">enqueue</span><span class="params">(F &amp;&amp;f, Args &amp;&amp;...args)</span></span>; <span class="comment">// 入队接口</span></span><br></pre></td></tr></table></figure>

<p>入队接口<code>enqueue()</code>这个模板函数返回值使用了<code>auto</code>关键字进行推导，实际上的返回值其实是一个future。future的类型如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> return_type = std::<span class="keyword">invoke_result_t</span>&lt;F, Args...&gt;;</span><br><span class="line">std::future&lt;return_type&gt; res;</span><br></pre></td></tr></table></figure>

<p>也就是说这个future返回的类型实际上是任务的返回类型。</p>
<h4 id="输入参数"><a href="#输入参数" class="headerlink" title="输入参数"></a>输入参数</h4><p>输入参数是一个可调用对象和它的参数，这里利用了C++11的可变参数模板来实现传递任意数量的可调用对象的参数。</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadPool</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">ThreadPool</span><span class="params">(<span class="keyword">size_t</span> threads = std::thread::hardware_concurrency())</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function">	<span class="keyword">auto</span> <span class="title">enqueue</span><span class="params">(F &amp;&amp;f, Args &amp;&amp;...args)</span></span>;</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">ThreadPool</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::vector&lt;std::thread&gt; workers;</span><br><span class="line">	std::queue&lt;std::function&lt;<span class="keyword">void</span>()&gt;&gt; tasks;</span><br><span class="line">	std::mutex queue_mutex;</span><br><span class="line">	std::condition_variable condition;</span><br><span class="line">	<span class="keyword">bool</span> stop;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个简易单任务队列线程池的成员只有一个线程组，一个任务队列。为了保证任务队列的线程安全，我们还提供了一个锁。同时我们还提供了一个条件变量，利用锁和条件变量，我们可以实现线程通知机制。线程通知机制指的是，刚开始时线程池中是没有任务的，所有的线程都等待任务的到来，当一个任务进入到线程池中，就会通知<strong>一个</strong>线程去处理到来的任务。</p>
<p>同时我们又提供了一个stop变量，用来在析构的时候停止和清理任务和线程。因为懒（高情商：RAII风格线程池，生命周期基本上与应用的生命周期一致），没有提供stop接口。</p>
<p>下面是具体实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Diana &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// * 简易多线程单任务队列线程池，使用线程安全队列，接口更人性化。</span></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">ThreadPool</span> &#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="keyword">explicit</span> <span class="title">ThreadPool</span><span class="params">(<span class="keyword">size_t</span> threads = std::thread::hardware_concurrency())</span> : stop(false) &#123;</span></span><br><span class="line">			<span class="comment">// 根据threads数量创建多个线程</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; threads; ++i) &#123;</span><br><span class="line">				workers.<span class="built_in">emplace_back</span>([<span class="keyword">this</span>]() &#123;</span><br><span class="line">					<span class="keyword">for</span> (;;) &#123;<span class="comment">// 工作线程就是一个死循环，不停查询任务队列并取出任务执行</span></span><br><span class="line">						std::function&lt;<span class="built_in"><span class="keyword">void</span></span>()&gt; task;</span><br><span class="line"></span><br><span class="line">						&#123;</span><br><span class="line">							std::unique_lock&lt;std::mutex&gt; <span class="built_in">lock</span>(<span class="keyword">this</span>-&gt;queue_mutex);</span><br><span class="line">							<span class="keyword">this</span>-&gt;condition.<span class="built_in">wait</span>(lock,</span><br><span class="line">												 [<span class="keyword">this</span>]() &#123;</span><br><span class="line">													 <span class="keyword">return</span> <span class="keyword">this</span>-&gt;stop || !<span class="keyword">this</span>-&gt;tasks.<span class="built_in">empty</span>();<span class="comment">// 条件变量等待线程池不为空或者stop</span></span><br><span class="line">												 &#125;);</span><br><span class="line">							<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;stop &amp;&amp; <span class="keyword">this</span>-&gt;tasks.<span class="built_in">empty</span>())<span class="comment">// 线程池为空且stop，证明线程池结束，退出线程</span></span><br><span class="line">								<span class="keyword">return</span>;</span><br><span class="line">							task = std::<span class="built_in">move</span>(<span class="keyword">this</span>-&gt;tasks.<span class="built_in">front</span>());<span class="comment">// 取出任务</span></span><br><span class="line">							<span class="keyword">this</span>-&gt;tasks.<span class="built_in">pop</span>();</span><br><span class="line">						&#125;</span><br><span class="line"></span><br><span class="line">						<span class="built_in">task</span>();<span class="comment">// 执行任务</span></span><br><span class="line">					&#125;</span><br><span class="line">				&#125;);<span class="comment">// lambda表达式构建</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function">		<span class="keyword">auto</span> <span class="title">enqueue</span><span class="params">(F &amp;&amp;f, Args &amp;&amp;...args)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">using</span> return_type = std::<span class="keyword">invoke_result_t</span>&lt;F, Args...&gt;;</span><br><span class="line">			<span class="keyword">auto</span> task = std::make_shared&lt;std::packaged_task&lt;<span class="built_in">return_type</span>()&gt;&gt;(</span><br><span class="line">					std::<span class="built_in">bind</span>(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...));<span class="comment">// 完美转发，构造任务仿函数的指针</span></span><br><span class="line">			std::future&lt;return_type&gt; res = task-&gt;<span class="built_in">get_future</span>();                  <span class="comment">// 获得函数执行的future返回</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(queue_mutex)</span></span>;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (stop) &#123;</span><br><span class="line">					<span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;enqueue on stopped Thread pool&quot;</span>);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				tasks.<span class="built_in">emplace</span>([task = std::<span class="built_in">move</span>(task)]() &#123; (*task)(); &#125;);<span class="comment">// 塞入任务队列</span></span><br><span class="line">			&#125;                                                            <span class="comment">// 入队列后即可解锁</span></span><br><span class="line">			condition.<span class="built_in">notify_one</span>();                                      <span class="comment">// 仅唤醒一个线程，避免无意义的竞争</span></span><br><span class="line">			<span class="keyword">return</span> res;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		~<span class="built_in">ThreadPool</span>() &#123;</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(queue_mutex)</span></span>;</span><br><span class="line">				stop = <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			condition.<span class="built_in">notify_all</span>();<span class="comment">// 唤醒所有线程，清理任务</span></span><br><span class="line">			<span class="keyword">for</span> (std::thread &amp;worker: workers)</span><br><span class="line">				worker.<span class="built_in">join</span>();<span class="comment">// 阻塞，等待所有线程执行结束</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		std::vector&lt;std::thread&gt; workers;</span><br><span class="line">		std::queue&lt;std::function&lt;<span class="keyword">void</span>()&gt;&gt; tasks;</span><br><span class="line">		std::mutex queue_mutex;</span><br><span class="line">		std::condition_variable condition;</span><br><span class="line">		<span class="keyword">bool</span> stop;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">&#125;;<span class="comment">// namespace Diana</span></span><br></pre></td></tr></table></figure>

<p>细节上的东西，注释已经写完了。</p>
<p>注意在有队伍进入队列时，仅需要notify_one()，避免无意义的线程竞争；在停止线程池时，要notify_all()唤醒所有进程。由于线程在等待stop标志，所以当唤醒之后才会把队列中的任务取出执行直到队列为空的时候才会退出线程。</p>
<h3 id="重构：分离队列代码，编写线程安全任务队列"><a href="#重构：分离队列代码，编写线程安全任务队列" class="headerlink" title="重构：分离队列代码，编写线程安全任务队列"></a>重构：分离队列代码，编写线程安全任务队列</h3><p>这里进行一次重构，像之前那片博文一样，封装一个线程安全队列：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Diana &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// * 线程安全队列</span></span><br><span class="line">	<span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">SafeQueue</span> &#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> T &amp;item)</span> </span>&#123;</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="function">std::scoped_lock <span class="title">lock</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">				queue_.<span class="built_in">push</span>(item);</span><br><span class="line">			&#125;</span><br><span class="line">			cond_.<span class="built_in">notify_one</span>();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T &amp;&amp;item)</span> </span>&#123;<span class="comment">// 两个push方法，此处不是万能引用而是单纯右值</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="function">std::scoped_lock <span class="title">lock</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">				queue_.<span class="built_in">push</span>(std::<span class="built_in">move</span>(item));</span><br><span class="line">			&#125;</span><br><span class="line">			cond_.<span class="built_in">notify_one</span>();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">bool</span> <span class="title">pop</span><span class="params">(T &amp;item)</span> </span>&#123;</span><br><span class="line">			<span class="function">std::unique_lock <span class="title">lock</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">			cond_.<span class="built_in">wait</span>(lock, [&amp;]() &#123;</span><br><span class="line">				<span class="keyword">return</span> !queue_.<span class="built_in">empty</span>() || stop_;</span><br><span class="line">			&#125;);</span><br><span class="line">			<span class="keyword">if</span> (queue_.<span class="built_in">empty</span>())</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			item = std::<span class="built_in">move</span>(queue_.<span class="built_in">front</span>());</span><br><span class="line">			queue_.<span class="built_in">pop</span>();</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function">std::<span class="keyword">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">			<span class="function">std::scoped_lock <span class="title">lock</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">			<span class="keyword">return</span> queue_.<span class="built_in">size</span>();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">			<span class="function">std::scoped_lock <span class="title">lock</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">			<span class="keyword">return</span> queue_.<span class="built_in">empty</span>();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="function">std::scoped_lock <span class="title">lock</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">				stop_ = <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			cond_.<span class="built_in">notify_all</span>();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		std::condition_variable cond_;</span><br><span class="line">		<span class="keyword">mutable</span> std::mutex mtx_;</span><br><span class="line">		std::queue&lt;T&gt; queue_;</span><br><span class="line">		<span class="keyword">bool</span> stop_ = <span class="literal">false</span>;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">&#125;;<span class="comment">// namespace Diana</span></span><br></pre></td></tr></table></figure>

<p>线程安全任务队列需要注意的细节不多。注意一下这里写了两个push方法，原因是在该模板类特化后，T已经是一个具体的类型，T&amp;&amp;就不再是泛型编程中常见的万能引用，而是一个单纯的右值了。我们可以通过再添加一个模板成员函数来合并两个push：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(U&amp;&amp; item)</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in"><span class="keyword">static_assert</span></span>(std::is_same&lt;U,T&gt;::value==<span class="literal">true</span>);</span><br><span class="line">        <span class="function">std::scoped_lock <span class="title">lock</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">        queue_.<span class="built_in">push</span>(std::forward(item));</span><br><span class="line">    &#125;</span><br><span class="line">    cond_.<span class="built_in">notify_one</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要注意的是，记得判断一下U和T的类型是一样的。</p>
<p>利用这个安全队列，我们可以重写一下单任务队列的线程池：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Diana &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">using</span> WorkItem = std::function&lt;<span class="built_in"><span class="keyword">void</span></span>()&gt;;</span><br><span class="line">	<span class="comment">// * 简易多线程单任务队列线程池，使用SafeQueue线程安全队列。</span></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">SimplePool</span> &#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="keyword">explicit</span> <span class="title">SimplePool</span><span class="params">(<span class="keyword">size_t</span> threads = std::thread::hardware_concurrency())</span> </span>&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; threads; ++i) &#123;</span><br><span class="line">				workers_.<span class="built_in">emplace_back</span>([<span class="keyword">this</span>]() &#123;</span><br><span class="line">					<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">						std::function&lt;<span class="built_in"><span class="keyword">void</span></span>()&gt; task;</span><br><span class="line">						<span class="keyword">if</span> (!queue_.<span class="built_in">pop</span>(task))</span><br><span class="line">							<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">						<span class="keyword">if</span> (task)</span><br><span class="line">							<span class="built_in">task</span>();</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(WorkItem item)</span> </span>&#123;</span><br><span class="line">			queue_.<span class="built_in">push</span>(std::<span class="built_in">move</span>(item));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		~<span class="built_in">SimplePool</span>() &#123;</span><br><span class="line">			queue_.<span class="built_in">stop</span>();</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; thd: workers_)</span><br><span class="line">				thd.<span class="built_in">join</span>();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		SafeQueue&lt;WorkItem&gt; queue_;</span><br><span class="line">		std::vector&lt;std::thread&gt; workers_;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">&#125;;<span class="comment">// namespace Diana</span></span><br></pre></td></tr></table></figure>

<p>入队接口enqueue()史诗级简化。当然，这种简化也带来一些不便：使用std::function&lt;void()&gt;作为参数，不想前面的那个传入可调用对象及其参数，在实际使用时需要用户进行包装，这个会在后面功能测试的时候讲。</p>
<hr>
<h2 id="多任务队列线程池"><a href="#多任务队列线程池" class="headerlink" title="多任务队列线程池"></a>多任务队列线程池</h2><p>其实多任务队列的线程池的设计思路也是很简单的：每个线程对应着一个自己的任务队列。因为前面对任务队列进行了抽取重构，编写一个多任务队列的线程池也非常简单。</p>
<p>我们对原本单任务队列的线程池的入队接口进行改造：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">schedule_by_id</span><span class="params">(WorkItem fn, <span class="keyword">size_t</span> id = <span class="number">-1</span>)</span></span></span><br></pre></td></tr></table></figure>

<p>当提交一个任务时，我们可以指定它放到任意一个线程的任务队列中。在用户没有指定任务队列时，就为该任务随机选择一个线程所对应的任务队列。</p>
<h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><p>简单多任务队列线程池实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Diana &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">using</span> WorkItem = std::function&lt;<span class="built_in"><span class="keyword">void</span></span>()&gt;;</span><br><span class="line">	<span class="comment">// * 简易多线程多任务队列线程池，使用SafeQueue线程安全队列。</span></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">MultiplePool</span> &#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="keyword">explicit</span> <span class="title">MultiplePool</span><span class="params">(<span class="keyword">size_t</span> thread_num = std::thread::hardware_concurrency())</span></span></span><br><span class="line"><span class="function">			: queues_(thread_num),</span></span><br><span class="line"><span class="function">			  thread_num_(thread_num) &#123;</span></span><br><span class="line">			<span class="keyword">auto</span> worker = [<span class="keyword">this</span>](<span class="keyword">size_t</span> id) &#123;</span><br><span class="line">				<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">					WorkItem task&#123;&#125;;</span><br><span class="line">					<span class="keyword">if</span> (!queues_[id].<span class="built_in">pop</span>(task))</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">					<span class="keyword">if</span> (task)</span><br><span class="line">						<span class="built_in">task</span>();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;;</span><br><span class="line"></span><br><span class="line">			workers_.<span class="built_in">reserve</span>(thread_num_);</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; thread_num_; ++i) &#123;</span><br><span class="line">				workers_.<span class="built_in">emplace_back</span>(worker, i);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">int</span> <span class="title">schedule_by_id</span><span class="params">(WorkItem fn, <span class="keyword">size_t</span> id = <span class="number">-1</span>)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (fn == <span class="literal">nullptr</span>)</span><br><span class="line">				<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (id == <span class="number">-1</span>) &#123;</span><br><span class="line">				id = <span class="built_in">rand</span>() % thread_num_;<span class="comment">// 随机插入到一个线程的任务队列中</span></span><br><span class="line">				queues_[id].<span class="built_in">push</span>(std::<span class="built_in">move</span>(fn));</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="built_in">assert</span>(id &lt; thread_num_);<span class="comment">// 插入指定线程的任务队列</span></span><br><span class="line">				queues_[id].<span class="built_in">push</span>(std::<span class="built_in">move</span>(fn));</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		~<span class="built_in">MultiplePool</span>() &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; queue: queues_) &#123;</span><br><span class="line">				queue.<span class="built_in">stop</span>();<span class="comment">// 停止每一个任务队列</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; worker: workers_) &#123;</span><br><span class="line">				worker.<span class="built_in">join</span>();<span class="comment">// 阻塞，等待每个线程执行结束</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		std::vector&lt;Diana::SafeQueue&lt;WorkItem&gt;&gt; queues_;<span class="comment">// 每个线程对应一个任务队列</span></span><br><span class="line">		<span class="keyword">size_t</span> thread_num_;</span><br><span class="line">		std::vector&lt;std::thread&gt; workers_;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">&#125;;<span class="comment">// namespace Diana</span></span><br></pre></td></tr></table></figure>

<p>需要注意的细节也在代码注释中写明了。</p>
<hr>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>我们编写如下测试代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_thread_pool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;test_thread_pool()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	Diana::ThreadPool threadPool;</span><br><span class="line">	threadPool.<span class="built_in">enqueue</span>([] &#123; std::cout &lt;&lt; <span class="string">&quot;hello\n&quot;</span>; &#125;);</span><br><span class="line">	<span class="keyword">auto</span> future = threadPool.<span class="built_in">enqueue</span>([](std::string str) &#123; <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span> + str; &#125;, <span class="string">&quot;world&quot;</span>);</span><br><span class="line">	std::cout &lt;&lt; future.<span class="built_in">get</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">funA</span><span class="params">(std::string str)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;hello&quot;</span> + str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_simple_thread_pool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;test_simple_thread_pool()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	Diana::SimplePool threadPool;</span><br><span class="line">	threadPool.<span class="built_in">enqueue</span>([] &#123; std::cout &lt;&lt; <span class="string">&quot;hello\n&quot;</span>; &#125;);</span><br><span class="line">	<span class="comment">// * 此处必须使用shared_ptr进行包装，</span></span><br><span class="line">	<span class="comment">// * 否则在std::function&lt;void()&gt;中会尝试生成std::packaged_task的拷贝构造函数，</span></span><br><span class="line">	<span class="comment">// ! std::packaged_task禁止拷贝操作</span></span><br><span class="line">	<span class="keyword">auto</span> task = std::make_shared&lt;std::packaged_task&lt;std::<span class="built_in">string</span>()&gt;&gt;(std::<span class="built_in">bind</span>(funA, <span class="string">&quot;world&quot;</span>));</span><br><span class="line">	std::future&lt;std::string&gt; res = task-&gt;<span class="built_in">get_future</span>();</span><br><span class="line">	threadPool.<span class="built_in">enqueue</span>([task = std::<span class="built_in">move</span>(task)] &#123; (*task)(); &#125;);</span><br><span class="line">    <span class="comment">// ! 以下实现方法是错误的</span></span><br><span class="line">	<span class="comment">//	auto task = std::packaged_task&lt;std::string()&gt;(std::bind(funA, &quot;world&quot;));</span></span><br><span class="line">	<span class="comment">//	std::future&lt;std::string&gt; res = task.get_future();</span></span><br><span class="line">	<span class="comment">//	threadPool.enqueue(std::move(task));</span></span><br><span class="line">	std::cout &lt;&lt; res.<span class="built_in">get</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_multiple_thread_pool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;test_multiple_thread_pool&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	Diana::MultiplePool threadPool;</span><br><span class="line">	threadPool.<span class="built_in">schedule_by_id</span>([] &#123; std::cout &lt;&lt; <span class="string">&quot;hello\n&quot;</span>; &#125;);</span><br><span class="line">	<span class="keyword">auto</span> task = std::make_shared&lt;std::packaged_task&lt;std::<span class="built_in">string</span>()&gt;&gt;(std::<span class="built_in">bind</span>(funA, <span class="string">&quot;world&quot;</span>));</span><br><span class="line">	std::future&lt;std::string&gt; res = task-&gt;<span class="built_in">get_future</span>();</span><br><span class="line">	threadPool.<span class="built_in">schedule_by_id</span>([task = std::<span class="built_in">move</span>(task)] &#123; (*task)(); &#125;);</span><br><span class="line">	std::cout &lt;&lt; res.<span class="built_in">get</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们分别为三个版本的线程池（未重构的单任务队列线程池+重构后的单任务队列线程池+多任务队列线程池）编写了接口测试。</p>
<p>未重构的单任务队列线程池，因为接口简单，没有什么需要特别注意的东西。</p>
<p>重构后的单任务队列线程池和多任务队列线程池，可以看到我写了一些注释，还注释了一些错误的任务提交方式。还记得前面重构时，我们把提交任务的接口参数改成了std::function&lt;void()&gt;嘛？为了配合这个参数格式，以及利用future进行异步编程，我们需要对异步获取结果的方法进行包装（之前的版本在入队接口中为用户做了这些事情）。比较需要注意的一点是我们需要用一个shared_ptr智能指针来对packaged_task进行包装，这是因为在std::function&lt;void()&gt;中会尝试生成std::packaged_task的拷贝构造函数，而std::packaged_task是禁止进行拷贝操作的，这会引起编译器的报错（感谢群里的大佬帮我整明白了这个事情）。</p>
<blockquote>
<p><a href="https://zh.cppreference.com/w/cpp/utility/functional/function">cppreference-std::funtion：</a></p>
<p>类模板 <code>std::function</code> 是通用多态函数包装器。 <code>std::function</code> 的实例能存储、复制及调用任何<a href="https://zh.cppreference.com/w/cpp/named_req/CopyConstructible"><em>可复制构造</em> <em>(CopyConstructible)</em> </a>的<a href="https://zh.cppreference.com/w/cpp/named_req/Callable"><em>可调用</em> <em>(Callable)</em> </a><em>目标</em>——函数、 <a href="https://zh.cppreference.com/w/cpp/language/lambda">lambda 表达式</a>、 <a href="https://zh.cppreference.com/w/cpp/utility/functional/bind">bind 表达式</a>或其他函数对象，还有指向成员函数指针和指向数据成员指针。</p>
<p>存储的可调用对象被称为 <code>std::function</code> 的<em>目标</em>。若 <code>std::function</code> 不含目标，则称它为<em>空</em>。调用<em>空</em> <code>std::function</code> 的<em>目标</em>导致抛出 <a href="https://zh.cppreference.com/w/cpp/utility/functional/bad_function_call">std::bad_function_call</a> 异常。</p>
<p><code>std::function</code> 满足<a href="https://zh.cppreference.com/w/cpp/named_req/CopyConstructible"><em>可复制构造</em> <em>(CopyConstructible)</em> </a>和<a href="https://zh.cppreference.com/w/cpp/named_req/CopyAssignable"><em>可复制赋值</em> <em>(CopyAssignable)</em> </a>。</p>
</blockquote>
<blockquote>
<p><a href="https://zh.cppreference.com/w/cpp/thread/packaged_task/packaged_task">cppreference-std::packaged_task构造函数：</a></p>
<p>构造新的 <code>std::packaged_task</code> 对象。</p>
<ol>
<li><p>…</p>
</li>
<li><p>复制构造函数被删除， <code>std::packaged_task</code> 仅可移动。</p>
</li>
<li><p>…</p>
</li>
</ol>
</blockquote>
<h2 id="性能比较"><a href="#性能比较" class="headerlink" title="性能比较"></a>性能比较</h2><p>根据性能测试，重构和未重构版本的单任务队列线程池有着细微的性能差别（未重构版本略优）。而在数据量足够大的情况下，因为多任务队列的设计，多任务队列线程池性能甚至达到了单任务队列线程池的两倍。</p>
<h2 id="写在后面"><a href="#写在后面" class="headerlink" title="写在后面"></a>写在后面</h2><p>后面大概还会继续研究一下work steal线程池，也会写篇学习心得=。=</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol>
<li><a href="http://www.purecpp.org/detail?id=2260">Purecpp：聊聊线程池（一）</a></li>
<li><a href="http://www.purecpp.org/detail?id=2261">Purecpp：聊聊线程池（二）</a></li>
</ol>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>C++11</tag>
        <tag>C++14</tag>
        <tag>C++17</tag>
        <tag>C++并发</tag>
        <tag>学习心得</tag>
      </tags>
  </entry>
  <entry>
    <title>C++日期与时间编程（C++11-C++17）</title>
    <url>/2021/05/19/C++%E6%97%A5%E6%9C%9F%E4%B8%8E%E6%97%B6%E9%97%B4%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="C-日期与时间编程（C-11-C-17）"><a href="#C-日期与时间编程（C-11-C-17）" class="headerlink" title="C++日期与时间编程（C++11-C++17）"></a>C++日期与时间编程（C++11-C++17）</h1><h2 id="0x00-导言"><a href="#0x00-导言" class="headerlink" title="0x00 导言"></a>0x00 导言</h2><p>日期和时间是在编程中常常接触到的东西，而C++也为程序员提供了强（复）大（杂）的日期和时间编程的相关支持。在C++20标准中，C++的<code>chrono</code>库继C++11标准后也迎来了空前绝后大更新，但本文讨论的重点主要集中在C++11至C++17标准中日期和时间相关的内容，C++20标准中的<code>chrono</code>新东西完全可以另开一个坑。</p>
<p>在翻了N篇cppreference标准、chrome爽吃我800Mb的内存之后，我果断决定把这次的学习心得记下来，以防以后全部忘光光（实在太多了.jpg）。本片学习心得纯新手向，求大佬轻喷。</p>
<span id="more"></span>

<h2 id="0x01-概论"><a href="#0x01-概论" class="headerlink" title="0x01 概论"></a>0x01 概论</h2><p>先给两个例子：</p>
<ol>
<li>获取当前时间</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 实现1 **/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">time_t</span> now = <span class="built_in">time</span>(<span class="literal">nullptr</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Now is: &quot;</span> &lt;&lt; <span class="built_in">ctime</span>(&amp;now);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 实现2 **/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> now = chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line">	<span class="keyword">time_t</span> time = chrono::system_clock::<span class="built_in">to_time_t</span>(now);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Now is: &quot;</span> &lt;&lt; <span class="built_in">ctime</span>(&amp;time) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>计算时间差</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 实现1 **/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">time_t</span> time1 = <span class="built_in">time</span>(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000000</span>; i++) &#123;</span><br><span class="line">  		sum += <span class="built_in">sqrt</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">time_t</span> time2 = <span class="built_in">time</span>(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">double</span> time_diff = <span class="built_in">difftime</span>(time2, time1);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;time1: &quot;</span> &lt;&lt; time1 &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;time2: &quot;</span> &lt;&lt; time2 &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;time_diff: &quot;</span> &lt;&lt; time_diff &lt;&lt; <span class="string">&quot;s&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 实现2 **/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> start = chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line">	<span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000000</span>; i++) &#123;</span><br><span class="line">    	sum += <span class="built_in">sqrt</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">auto</span> end = chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">auto</span> time_diff = end - start;</span><br><span class="line">	<span class="keyword">auto</span> duration = chrono::duration_cast&lt;chrono::seconds&gt;(time_diff);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Operation cost : &quot;</span> &lt;&lt; duration.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot;s&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上文的两个要求都分别给出了两种实现方法，那接下来要说的事情已经显而易见了：</p>
<p><strong>C++给出了两类日期时间API，分别是：</strong></p>
<ul>
<li>C-Style日期时间库，主要位于<code>&lt;ctime&gt;</code>头文件（原C语言<code>&lt;time.h&gt;</code>头文件的C++版本）中。</li>
<li><code>chrono</code>库：C++11新增的API。</li>
</ul>
<p>在C++11引入<code>chrono</code>库之前，C++程序员只能使用C-Style的日期时间库。然而，C-Style日期时间库有着鲜明的缺点：<strong>精度只有秒级别</strong>（当时），这对于对时间有着高精度要求的程序来说是完全不够用的。而C++11引入的<code>chrono</code>库解决了这个问题，它极大地扩展了对精度的支持。当然，针对习惯C-Style日期时间库的程序员来说，C++17也进行了精度的扩充，详情请见下文。</p>
<p>本文也会分为C-Style和<code>chrono</code>两个板块进行讲解。</p>
<h2 id="0x02-必备的知识"><a href="#0x02-必备的知识" class="headerlink" title="0x02 必备的知识"></a>0x02 必备的知识</h2><p>在正式进入日期时间库的讨论之前，我们应该先复习一下与日期时间相关的必要知识。</p>
<h3 id="UTC时间"><a href="#UTC时间" class="headerlink" title="UTC时间"></a>UTC时间</h3><p><strong>协调世界时</strong>（<strong>C</strong>oordinated <strong>U</strong>niversial <strong>T</strong>ime，简称<strong>UTC</strong>）是最主要的时间标准，其以原子时秒长为基础，在时刻上尽量接近于格林威治标准时间。</p>
<p>协调世界时是世界上调节时钟和时间的主要时间标准，它与0度经线的平太阳时相差不超过1秒。因此UTC时间+8即可获得北京标准时间（UTC+8）。</p>
<h3 id="本地时间"><a href="#本地时间" class="headerlink" title="本地时间"></a>本地时间</h3><p>本地时间与当地的时区相关，例如中国当地时间采用了北京标准时间（UTC+8）.</p>
<h3 id="纪元时间"><a href="#纪元时间" class="headerlink" title="纪元时间"></a>纪元时间</h3><p><strong>纪元时间</strong>（Epoch time）又被称为Unix时间（常用Linux的小伙伴可能会比较熟悉）。它表示1970年1月1日00:00UTC以来所经历的<strong>秒数</strong>（不考虑闰秒）。</p>
<p>例如北京时间2021年5月18日晚上9点07分32秒的纪元时间为：<code>1621372052</code>。</p>
<p>作为一个敏感的CPP程序员，你应该很快就意识到这个大整数在储存会产生很多问题，例如溢出。然而事实正是如此，在一些历史机器上，使用了32位的有符号整数来储存这个时间戳，因此产生在结果就是：在2038-01-19 03:14:07这一刻，该值会溢出。</p>
<p>另外，如果你对为什么选1970-1-1日零点做位纪元时间起点，可以看一下这个帖子：</p>
<p><a href="https://stackoverflow.com/questions/1090869/why-is-1-1-1970-the-epoch-time">Why is 1/1/1970 the “epoch time”?</a></p>
<h2 id="0x03-C-Style-日期时间库"><a href="#0x03-C-Style-日期时间库" class="headerlink" title="0x03 C-Style 日期时间库"></a>0x03 C-Style 日期时间库</h2><p>C-Style日期时间库主要位于<code>&lt;ctime&gt;</code>头文件中，下面给出头文件中包含的常用的<em>类型</em>和<em>函数</em>。</p>
<h3 id="常用类型与函数"><a href="#常用类型与函数" class="headerlink" title="常用类型与函数"></a>常用类型与函数</h3><p><strong>类型</strong></p>
<table>
<thead>
<tr>
<th>类型名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>clock_t</td>
<td>进程运行时间</td>
</tr>
<tr>
<td>size_t</td>
<td>sizeof运算符返回的无符号整数类型</td>
</tr>
<tr>
<td>time_t</td>
<td>从纪元起的时间类型</td>
</tr>
<tr>
<td>tm</td>
<td>日历时间类型</td>
</tr>
<tr>
<td>timespec*(C++17)*</td>
<td>以秒和纳秒表示的时间（C++17）</td>
</tr>
</tbody></table>
<p><strong>函数</strong></p>
<table>
<thead>
<tr>
<th>函数名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>std::clock_t clock()</td>
<td>返回自程序启动时起的原始处理器时钟时间</td>
</tr>
<tr>
<td>std::time_t time(std::time_t* arg)</td>
<td>返回自纪元起计的系统当前时间</td>
</tr>
<tr>
<td>double difftime(std::time_t time_end, std::time_t time_beg)</td>
<td>计算时间之间的差</td>
</tr>
<tr>
<td>int timespec_get(std::timespec* ts, int base)<em>(C++17)</em></td>
<td>返回基于给定时间基底的日历时间（C++17）</td>
</tr>
<tr>
<td>char* ctime(const std::time_t* time)</td>
<td>转换 time_t 对象为文本表示</td>
</tr>
<tr>
<td>char* asctime(const std::tm* time_ptr)</td>
<td>转换 tm 对象为文本表示</td>
</tr>
<tr>
<td>std::size_t strftime(char* str, std::size_t count, const char* format, const std::tm* time)</td>
<td>转换 tm 对象到自定义的文本表示</td>
</tr>
<tr>
<td>std::size_t wcsftime( wchar_t* str, std::size_t count, const wchar_t* format, const std::tm* time)</td>
<td>转换 tm 对象为定制的宽字符串文本表示</td>
</tr>
<tr>
<td>std::tm* gmtime(const std::time_t* time)</td>
<td>将time_t转换成UTC表示的时间</td>
</tr>
<tr>
<td>std::tm* localtime(const std::time_t *time)</td>
<td>将time_t转换成本地时间</td>
</tr>
<tr>
<td>std::time_t mktime(std::tm* time)</td>
<td>将tm格式的时间转换成time_t表示的时间</td>
</tr>
</tbody></table>
<p>函数和数据类型又多又杂有木有，刚开始接触的时候很容易弄混且不太容易记住，这里借鉴一下大佬的一张图来理解记忆：</p>
<p><img src="C:\Users\Skykey\Desktop\ctime.png"></p>
<p>这幅图中，以数据类型为中心，带方向的实心箭头表示该函数返回相应类型的结果。</p>
<ul>
<li>clock函数比较特别，它返回进程运行的时间，因而是相对独立的。</li>
<li>time_t描述纪元时间（精确到秒），使用time函数获得。</li>
<li>timespec类型在time_t的基础上增加了纳秒的精度，需要通过timespec_get函数获取。该类型与函数为C++17新增内容。</li>
<li>tm是日历类型，包含了年月日等信息。可以通过gmtime，localtime和mktime函数进行time_t和tm类型的相互转化。</li>
<li>gmtime和localtime两个函数存在时区差异相关问题。</li>
<li>time_t和tm结构都可以用字符串格式输出。ctime和asctime输出的格式是固定的，如果需要自定义格式，需要使用strftime或者wcsftime函数。</li>
</ul>
<h3 id="计算进程运行的时间"><a href="#计算进程运行的时间" class="headerlink" title="计算进程运行的时间"></a>计算进程运行的时间</h3><p>clock函数会返回从关联到进程开始执行的实现定义时期的起，进程所用的粗略处理器时间。将此值除以<code>CLOCKS_PER_SEC</code>常量可转换为秒。</p>
<p>这里给出cppreference上clock函数示例的简化版：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;threads.h&gt;</span> <span class="comment">// POSIX 中的 pthread.h</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 函数 f() 做一些耗时的工作</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">void</span>* thr_data)</span> <span class="comment">// POSIX 中返回 void*</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">double</span> d = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n=<span class="number">0</span>; n&lt;<span class="number">10000</span>; ++n)</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> m=<span class="number">0</span>; m&lt;<span class="number">10000</span>; ++m)</span><br><span class="line">           d += d*n*m;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">clock_t</span> t1 = <span class="built_in">clock</span>();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">thrd_t</span> thr1, thr2;  <span class="comment">// C11 ；POSIX 中用 pthread_t</span></span><br><span class="line">    <span class="built_in">thrd_create</span>(&amp;thr1, f, <span class="literal">NULL</span>); <span class="comment">// C11 ； POSIX 中用 pthread_create</span></span><br><span class="line">    <span class="built_in">thrd_create</span>(&amp;thr2, f, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">thrd_join</span>(thr1, <span class="literal">NULL</span>); <span class="comment">// C11 ； POSIX 中用 pthread_join</span></span><br><span class="line">    <span class="built_in">thrd_join</span>(thr2, <span class="literal">NULL</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">clock_t</span> t2 = <span class="built_in">clock</span>();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">double</span> dur = <span class="number">1000.0</span>*(t2-t1)/CLOCKS_PER_SEC;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;CPU time used (per clock(): %.2f ms\n&quot;</span>, dur);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可能的输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CPU time used (per clock(): 1580.00 ms</span><br></pre></td></tr></table></figure>

<p>我们应当注意，clock时间或许会快于或慢于挂钟时间，这取决于操作系统给予程序的执行资源。在单处理器的情况下，若CPU为其他进程所共享，clock可能慢于挂钟，若当前进程为多线程，而有更多资源可用，clock时间可能会快于挂钟。在多处理器情况下，若进程使用了多线程，那么clock时间可能要慢于挂钟。</p>
<h3 id="获取纪元时间"><a href="#获取纪元时间" class="headerlink" title="获取纪元时间"></a>获取纪元时间</h3><p>使用time函数可以获取储存于time_t类型返回值里的纪元时间。</p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">time_t</span> epoch_time = <span class="built_in">time</span>(<span class="literal">nullptr</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Epoch time: &quot;</span> &lt;&lt; epoch_time &lt;&lt;endl; </span><br></pre></td></tr></table></figure>

<p>在北京时间2021年5月18日晚上9点07分32秒输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Epoch time: 1621372052</span><br></pre></td></tr></table></figure>



<h3 id="计算时间差"><a href="#计算时间差" class="headerlink" title="计算时间差"></a>计算时间差</h3><p>在一些情况下我们需要计算操作所花费的<strong>时间长度</strong>。可以看出，time_t结构中储存的是<strong>时间点</strong>，而通过常识我们得知：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">时间差（时间长度） = 时间点 - 时间点</span><br></pre></td></tr></table></figure>

<p>在C-Style日期时间库中，我们可以通过difftime函数来计算两个时间点的差。</p>
<p>下面给出cppreference的示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::<span class="keyword">time_t</span> start = std::<span class="built_in">time</span>(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">double</span> d;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 一些耗时操作</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n=<span class="number">0</span>; n&lt;<span class="number">10000</span>; ++n) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> m=<span class="number">0</span>; m&lt;<span class="number">100000</span>; ++m) &#123;</span><br><span class="line">           d += d*n*m;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Wall time passed: &quot;</span></span><br><span class="line">              &lt;&lt; std::<span class="built_in">difftime</span>(std::<span class="built_in">time</span>(<span class="literal">NULL</span>), start) &lt;&lt; <span class="string">&quot; s.\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可能的输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Wall time passed: 7 s.</span><br></pre></td></tr></table></figure>



<h3 id="UTC时间与本地时间"><a href="#UTC时间与本地时间" class="headerlink" title="UTC时间与本地时间"></a>UTC时间与本地时间</h3><p>在C-Style日期时间库中，我们可以使用gmtime将std::time_t的纪元时间转换为UTC时间，使用localtime将纪元时间转换为本地时区所代表的日历时间。</p>
<p>gmtime与localtime返回值的类型为tm结构，即日历时间的结构描述，其结构如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tm</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> tm_sec;</span><br><span class="line">  <span class="keyword">int</span> tm_min</span><br><span class="line">  <span class="keyword">int</span> tm_hour;</span><br><span class="line">  <span class="keyword">int</span> tm_mday;</span><br><span class="line">  <span class="keyword">int</span> tm_mon;</span><br><span class="line">  <span class="keyword">int</span> tm_year;</span><br><span class="line">  <span class="keyword">int</span> tm_wday;</span><br><span class="line">  <span class="keyword">int</span> tm_yday;</span><br><span class="line">  <span class="keyword">int</span> tm_isdst;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>有两点我们需要注意：</p>
<ul>
<li>tm_mon表示的范围为[0, 11]。转换成日常使用的月份表示需要+1。</li>
<li>tm_year表示的是自1900年之后所过的年份数。转换成日常使用的年份表示需要+1900。</li>
</ul>
<p>下面给出示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">time_t</span> now = <span class="built_in">time</span>(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">tm* gm_time = <span class="built_in">gmtime</span>(&amp;now);</span><br><span class="line">tm* local_time = <span class="built_in">localtime</span>(&amp;now);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;gmtime: &quot;</span> &lt;&lt; <span class="built_in">asctime</span>(gm_time);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;local_time: &quot;</span> &lt;&lt; <span class="built_in">asctime</span>(local_time);</span><br></pre></td></tr></table></figure>

<p>输出如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">gmtime: Tue May <span class="number">18</span> <span class="number">21</span>:<span class="number">36</span>:<span class="number">48</span> <span class="number">2021</span></span><br><span class="line">local_time: Tue May <span class="number">18</span> <span class="number">21</span>:<span class="number">36</span>:<span class="number">48</span> <span class="number">2021</span></span><br></pre></td></tr></table></figure>



<h3 id="输出时间和日期"><a href="#输出时间和日期" class="headerlink" title="输出时间和日期"></a>输出时间和日期</h3><p>获取了时间，我们自然想要将时间以字符串的形式打印出来。此时可以使用ctime函数。</p>
<p>应注意的是，ctime函数打印的格式是固定的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Www Mmm dd hh:mm:ss yyyy\n</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">time_t</span> now = <span class="built_in">time</span>(<span class="literal">nullptr</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Now is: &quot;</span> &lt;&lt; <span class="built_in">ctime</span>(&amp;now);</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Now is: Tue May 18 21:39:46 2021</span><br></pre></td></tr></table></figure>

<p>而tm储存的日期时间结构，我们也可以使用asctime函数将其转换为字符串格式。</p>
<p>然而，ctime和asctime函数其输出的格式都是固定的，在有格式要求的情况下，我们通常有两种做法：</p>
<ol>
<li><p>拆分tm结构体的字段：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">time_t now = time(nullptr);</span><br><span class="line">tm* t = localtime(&amp;now);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &quot;Now is: &quot; &lt;&lt; t-&gt;tm_year + 1900 &lt;&lt; &quot;/&quot; &lt;&lt; t-&gt;tm_mon + 1&lt;&lt; &quot;/&quot; &lt;&lt; t-&gt;tm_mday &lt;&lt; &quot; &quot;;</span><br><span class="line">cout &lt;&lt; t-&gt;tm_hour &lt;&lt; &quot;:&quot; &lt;&lt; t-&gt;tm_min &lt;&lt; &quot;:&quot; &lt;&lt; t-&gt;tm_sec &lt;&lt; endl;</span><br></pre></td></tr></table></figure></li>
<li><p>使用strftime或者wcsftime函数来指定格式输出。函数格式可以参考以下文档：</p>
<p><a href="https://zh.cppreference.com/w/cpp/chrono/c/strftime">https://zh.cppreference.com/w/cpp/chrono/c/strftime</a></p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;locale&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::locale::<span class="built_in">global</span>(std::<span class="built_in">locale</span>(<span class="string">&quot;ja_JP.utf8&quot;</span>));</span><br><span class="line">    std::<span class="keyword">time_t</span> t = std::<span class="built_in">time</span>(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">char</span> mbstr[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">if</span> (std::<span class="built_in">strftime</span>(mbstr, <span class="built_in"><span class="keyword">sizeof</span></span>(mbstr), <span class="string">&quot;%A %c&quot;</span>, std::<span class="built_in">localtime</span>(&amp;t))) &#123;</span><br><span class="line">        std::cout &lt;&lt; mbstr &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">火曜日 2011年12月27日 17時39分03秒</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="C-17新内容timespec，迈向纳秒精度"><a href="#C-17新内容timespec，迈向纳秒精度" class="headerlink" title="C++17新内容timespec，迈向纳秒精度"></a>C++17新内容timespec，迈向纳秒精度</h3><p>纪元时间的精度只有秒，这在很多时候是不够用的。为了解决这个问题，C++17增加timespec类型，提供了纳秒级别的精度。</p>
<p>一些熟悉C语言的朋友可能会立即满头问号：timespec不是在C11（注意看，是C11，不是CPP11）就已经引入了么？</p>
<p>但事实的确如此，严格的C++的C-Style日期时间库，在C++17标准才正式引入timespec类型。</p>
<p>timespec类型结构如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> &#123;</span></span><br><span class="line">  std::<span class="keyword">time_t</span> tv_sec;</span><br><span class="line">  <span class="keyword">long</span> tv_nsec;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中tv_nsec成员保存了纳秒数。</p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">timespec ts;</span><br><span class="line"><span class="built_in">timespec_get</span>(&amp;ts, TIME_UTC);</span><br><span class="line"><span class="keyword">char</span> buff[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">strftime</span>(buff, <span class="keyword">sizeof</span> buff, <span class="string">&quot;%D %T&quot;</span>, std::<span class="built_in">gmtime</span>(&amp;ts.tv_sec));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Current time: %s.%09ld UTC\n&quot;</span>, buff, ts.tv_nsec);</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Current time: <span class="number">05</span>/<span class="number">18</span>/<span class="number">21</span> <span class="number">13</span>:<span class="number">50</span>:<span class="number">58.667861100</span> UTC</span><br></pre></td></tr></table></figure>



<p>C-Style日期时间库至此已基本结束，接下来讲解C++11起新增的chrono库。</p>
<hr>
<h2 id="0x04-chrono库"><a href="#0x04-chrono库" class="headerlink" title="0x04 chrono库"></a>0x04 chrono库</h2><p>chrono是以各种精度跟踪时间的类型的灵活汇集。chrono库定义三种主要类型以及工具函数和常用的typedef：</p>
<ul>
<li>时钟</li>
<li>时长</li>
<li>时间点</li>
</ul>
<h3 id="时钟"><a href="#时钟" class="headerlink" title="时钟"></a>时钟</h3><p>C++11的chrono库主要包含了三种类型的时钟：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>system_clock</td>
<td>来自系统范畴实时时钟的挂钟时间</td>
</tr>
<tr>
<td>steady_clock</td>
<td>决不会调整的单调时钟</td>
</tr>
<tr>
<td>high_resolution_clock</td>
<td>拥有可用的最短嘀嗒周期的时钟</td>
</tr>
</tbody></table>
<p>system_clock来源是系统时钟。然而在大多数系统上，系统时间是可以在任何时候被调节的。所以如果用来计算两个时间点的时间差，这并不是一个好的选择。</p>
<p>steady_clock是一个单调时钟。此时钟的时间点无法减少，因为物理十几件向前移动。因而steady_clock是度量间隔的最适宜的选择。</p>
<p>high_resolution_clock表示实现提供的拥有最小计次周期的时钟。它可以是system_clock或steady_clock的别名，或者第三个独立时钟。</p>
<p>对于high_resolution_clock，cppreference给出了以下需要我们注意的地方：</p>
<p><a href="https://zh.cppreference.com/w/cpp/chrono/high_resolution_clock">https://zh.cppreference.com/w/cpp/chrono/high_resolution_clock</a></p>
<blockquote>
<p><code>high_resolution_clock</code> 在不同标准库实现之间实现不一致，而应该避免使用它。通常它只是 <a href="https://zh.cppreference.com/w/cpp/chrono/steady_clock">std::chrono::steady_clock</a> 或 <a href="https://zh.cppreference.com/w/cpp/chrono/system_clock">std::chrono::system_clock</a> 的别名，但实际是哪个取决于库或配置。它是 <code>system_clock</code> 时不是单调的（即时间能后退）。例如对于 gcc 的 libstdc++ 它是 <code>system_clock</code> ，对于 MSVC 它是 <code>steady_clock</code> ，而对于 clang 的 libc++ 它取决于配置。</p>
<p>通常用户应该直接使用 <a href="https://zh.cppreference.com/w/cpp/chrono/steady_clock">std::chrono::steady_clock</a> 或 <a href="https://zh.cppreference.com/w/cpp/chrono/system_clock">std::chrono::system_clock</a> 代替 <code>std::chrono::high_resolution_clock</code> ：对时长度量使用 <code>steady_clock</code> ，对壁钟时间使用 <code>system_clock</code> 。</p>
</blockquote>
<p>对于这三个时钟类，有着以下共同的成员：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>now()</td>
<td>静态成员函数，返回当前时间，类型为clock::time_point</td>
</tr>
<tr>
<td>time_point</td>
<td>成员类型，当前时钟的时间点类型。</td>
</tr>
<tr>
<td>duration</td>
<td>成员类型，时钟的时长类型。</td>
</tr>
<tr>
<td>rep</td>
<td>成员类型，时钟的tick类型，等同于clock::duration::rep</td>
</tr>
<tr>
<td>period</td>
<td>成员类型，时钟的单位，等同于clock::duration::period</td>
</tr>
<tr>
<td>is_steady</td>
<td>静态成员类型：是否是稳定时钟，对于steady_clock来说该值一定是true</td>
</tr>
</tbody></table>
<p>每个时钟类都有着一个静态成员函数<code>new()</code>来获取当前时间。该函数的返回类型则是由该时钟类的time_point描述，例如<code>std::chrono::time_point&lt;std::chrono::system_clock&gt;</code>或者<code>std::chrono::time_point&lt;std::chrono::steady_clock&gt;</code>。我们可以使用auto关键字来简写（auto是个好文明）。</p>
<p>阅读文档，我们不难发现system_clock有着与另外两个clock所不具有的特性：它是唯一有能力映射其时间点到C-Style时间的C++时钟。system_clock提供了两个静态成员函数来与std::time_t进行互相转换：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>to_time_t</td>
<td>转换系统时钟时间点为 std::time_t</td>
</tr>
<tr>
<td>from_time_t</td>
<td>转换 std::time_t 到系统时钟时间点</td>
</tr>
</tbody></table>
<p>为了方便理解和记忆，我们也用一副图来描述几种时间类型的转换：</p>
<p><img src="C:\Users\Skykey\Desktop\conversion.png"></p>
<h3 id="时长"><a href="#时长" class="headerlink" title="时长"></a>时长</h3><p>人类对精度的要求永无止境。C-Style日期时间库为了提供对纳秒的精度，增加了timespec类型及相关的函数。那如果以后对更高精度的需求越来越高，C++标准库还要不断增加更多的类型和配套函数吗？这明显是一个不合理的设计。因而C++标准提出了一个新的解决思路，而这个思路涉及到了C++11引入的一个新的头文件和类型：ratio。</p>
<h4 id="ratio"><a href="#ratio" class="headerlink" title="ratio"></a>ratio</h4><p><code>std::ratio</code>定义在<code>&lt;ratio&gt;</code>文件中，提供了编译期的比例计算功能。</p>
<p><code>std::ratio</code>的定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;</span><br><span class="line">    std::<span class="keyword">intmax_t</span> Num,</span><br><span class="line">    std::<span class="keyword">intmax_t</span> Denom = <span class="number">1</span></span><br><span class="line">&gt; class ratio;</span><br></pre></td></tr></table></figure>

<p>类成员Num即为分子，类成员Denom即为分母。我们可以直接通过调用类成员来获取相关值。</p>
<p><code>&lt;ratio&gt;</code>头文件还包含了：ratio_add，ratio_subtract，ratio_multiply，ratio_divide来完成分数的加减乘除四则运算。</p>
<p>例如，想要计算5/7 + 59/1023，我们可以这样写：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ratio_add&lt;ratio&lt;<span class="number">5</span>, <span class="number">7</span>&gt;, ratio&lt;<span class="number">59</span>, <span class="number">1023</span>&gt;&gt; result;</span><br><span class="line"><span class="keyword">double</span> value = ((<span class="keyword">double</span>) result.num) / result.den;</span><br><span class="line">cout &lt;&lt; result.num &lt;&lt; <span class="string">&quot;/&quot;</span> &lt;&lt; result.den &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; value &lt;&lt; endl;</span><br></pre></td></tr></table></figure>



<p>对于编译期有理数算数的相关内容，可以在这篇文档中找到更多信息：</p>
<p><a href="https://zh.cppreference.com/w/cpp/numeric/ratio">https://zh.cppreference.com/w/cpp/numeric/ratio</a></p>
<p>有了ratio之后，结合<code>std::chrono::duration</code>，我们便可以表示任意精度的值了。</p>
<p>例如，相对于秒来说，毫秒是1/1,000，微秒是1/1,000,000，纳秒是1/1,000,000,000。通过ratio就可以这样表达：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::ratio&lt;<span class="number">1</span>, <span class="number">1000</span>&gt;       milliseconds;</span><br><span class="line">std::ratio&lt;<span class="number">1</span>, <span class="number">1000000</span>&gt;    microseconds;</span><br><span class="line">std::ratio&lt;<span class="number">1</span>, <span class="number">1000000000</span>&gt; nanoseconds;</span><br></pre></td></tr></table></figure>



<h4 id="时长类型"><a href="#时长类型" class="headerlink" title="时长类型"></a>时长类型</h4><p>类模板 std::chrono::duration 表示时间间隔。有了ratio之后，表达时长就很方便了，下面是chrono库中提供的很常用的几个时长单位：</p>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">定义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">std::chrono::nanoseconds</td>
<td align="left">duration&lt;/*至少 64 位的有符号整数类型*/, std::nano&gt;</td>
</tr>
<tr>
<td align="left">std::chrono::microseconds</td>
<td align="left">duration&lt;/*至少 55 位的有符号整数类型*/, std::micro&gt;</td>
</tr>
<tr>
<td align="left">std::chrono::milliseconds</td>
<td align="left">duration&lt;/*至少 45 位的有符号整数类型*/, std::milli&gt;</td>
</tr>
<tr>
<td align="left">std::chrono::seconds</td>
<td align="left">duration&lt;/*至少 35 位的有符号整数类型*/&gt;</td>
</tr>
<tr>
<td align="left">std::chrono::minutes</td>
<td align="left">duration&lt;/*至少 29 位的有符号整数类型*/, std::ratio&lt;60»</td>
</tr>
<tr>
<td align="left">std::chrono::hours</td>
<td align="left">duration&lt;/*至少 23 位的有符号整数类型*/, std::ratio&lt;3600»</td>
</tr>
</tbody></table>
<p>我们可以调用duration类的<code>count()</code>成员函数来获取具体数值。</p>
<h4 id="时长运算"><a href="#时长运算" class="headerlink" title="时长运算"></a>时长运算</h4><p>时长运算可以直接使用“+”或“-”相加相减。chrono库也提供了几个常用的函数：</p>
<table>
<thead>
<tr>
<th align="left">函数</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">duration_cast</td>
<td align="left">进行时长的转换</td>
</tr>
<tr>
<td align="left">floor(C++17)</td>
<td align="left">以向下取整的方式，将一个时长转换为另一个时长</td>
</tr>
<tr>
<td align="left">ceil(C++17)</td>
<td align="left">以向上取整的方式，将一个时长转换为另一个时长</td>
</tr>
<tr>
<td align="left">round(C++17)</td>
<td align="left">转换时长到另一个时长，就近取整，偶数优先</td>
</tr>
<tr>
<td align="left">abs(C++17)</td>
<td align="left">获取时长的绝对值</td>
</tr>
</tbody></table>
<p>例如：想要知道2个小时零5分钟一共是多少秒，可以这样写：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">chrono::hours <span class="title">two_hours</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="function">chrono::minutes <span class="title">five_minutes</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> duration = two_hours + five_minutes;</span><br><span class="line"><span class="keyword">auto</span> seconds = chrono::duration_cast&lt;chrono::seconds&gt;(duration);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;02:05 is &quot;</span> &lt;&lt; seconds.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot; seconds&quot;</span> &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>我们可以得到：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">02:05 is 7500 seconds</span><br></pre></td></tr></table></figure>

<p>从C++14开始，你甚至可以用字面值来描述常见的时长。这包括：</p>
<ul>
<li><code>h</code>表示小时</li>
<li><code>min</code>表示分钟</li>
<li><code>s</code>表示秒</li>
<li><code>ms</code>表示毫秒</li>
<li><code>us</code>表示微妙</li>
<li><code>ns</code>表示纳秒</li>
</ul>
<p>这些字面值位于<code>std::chrono_literals</code>命名空间下。于是，可以这样表达2个小时以及5分钟：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono_literals;</span><br><span class="line"><span class="keyword">auto</span> two_hours = <span class="number">2</span>h;</span><br><span class="line"><span class="keyword">auto</span> five_minutes = <span class="number">5</span>min;</span><br></pre></td></tr></table></figure>



<h3 id="时间点"><a href="#时间点" class="headerlink" title="时间点"></a>时间点</h3><p>时钟的now函数返回的值就是一个时间点，时间点包含了时钟和时长两个信息。</p>
<p>类模板<code>std::chrono::time_point</code>表示时间中的一个点，定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Clock</span>,</span></span><br><span class="line"><span class="class">    <span class="keyword">class</span> <span class="title">Duration</span> =</span> <span class="keyword">typename</span> Clock::duration</span><br><span class="line">&gt; <span class="class"><span class="keyword">class</span> <span class="title">time_point</span>;</span></span><br></pre></td></tr></table></figure>

<p>与我们的常识一致，时间点具有加法和减法操作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">时间点 + 时长 = 时间点</span><br><span class="line">时间点 - 时间点 = 时长</span><br></pre></td></tr></table></figure>

<p>因而我们可以通过两个时间点相减来计算一个时间间隔，示例如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> start = chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line"><span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000000</span>; i++) &#123;</span><br><span class="line">    sum += <span class="built_in">sqrt</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">auto</span> end = chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> time_diff = end - start;</span><br><span class="line"><span class="keyword">auto</span> duration = chrono::duration_cast&lt;chrono::milliseconds&gt;(time_diff);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Operation cost : &quot;</span> &lt;&lt; duration.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot;ms&quot;</span> &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>两个时间点也存在着比较操作，用于判断一个时间点在另外一个时间点之前还是之后，<code>std::chrono::time_point</code>重载了<code>==</code>，<code>!=</code>，<code>&lt;</code>，<code>&lt;=</code>，<code>&gt;</code>，<code>&gt;=</code>操作符来实现比较操作。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>C++11</tag>
        <tag>C++17</tag>
        <tag>学习心得</tag>
        <tag>日期与时间编程</tag>
      </tags>
  </entry>
  <entry>
    <title>基于C++11实现线程池</title>
    <url>/2021/04/23/cpp11-thread-pool/</url>
    <content><![CDATA[<h1 id="基于C-11实现线程池"><a href="#基于C-11实现线程池" class="headerlink" title="基于C++11实现线程池"></a>基于C++11实现线程池</h1><h2 id="0x00-导入"><a href="#0x00-导入" class="headerlink" title="0x00 导入"></a>0x00 导入</h2><p>前些日子通过阅读几篇博客，大体学习了一下C++的并发编程（主要是多线程、异步部分）。手撸了一个多生产者-多消费者模型之后，最终觉得这也只是小打小闹而已，需要整个硬货。经过一番思考之后，手撸一个线程池貌似是一个非常合适的练习。线程池前前后后一共折腾了四五个小时左右，最令我意外的是——原本以为最难理解的并发部分反而是最简单的部分，线程池实现中大量的CPP11语法糖才是真正影响我理解的部分。经过三四个小时的阅读博文、查阅资料以及向大佬求教之后，我才真正对线程池实现有了比较深入地理解。“纸上得来终觉浅，绝知此事要躬行。”经历这一番折腾后才清楚地认识到了自己对CPP11理解的薄弱，遂写下这篇博客来总结自己对线程池实现以及所涉及到的CPP11语法糖的理解，方便自己以后再次阅读源码时有所考据。</p>
<p>文章大量借鉴、节选了众多参考资料，并结合自己的理解进行讲解。参考资料会在最后列出。</p>
<p>这篇总结会将重心放在C++11的语法糖上，对于C++11的并发编程部分（<code>std::thread</code>, <code>std::future</code>等）将仅进行最简洁最必要的阐述。有关并发编程部分可以移步至几篇大佬总结的比较好的博文中进行补充学习：</p>
<ol>
<li>《C++并发编程（从C++11到C++17）》：<a href="https://paul.pub/cpp-concurrency">https://paul.pub/cpp-concurrency</a></li>
<li>《从pthread转换到std::thread》：<a href="https://segmentfault.com/a/1190000002655852">https://segmentfault.com/a/1190000002655852</a></li>
<li>《货比三家：C++中的task based并发》：<a href="https://segmentfault.com/a/1190000002706259">https://segmentfault.com/a/1190000002706259</a></li>
</ol>
<span id="more"></span>

<h2 id="0x01-逐步实现线程池"><a href="#0x01-逐步实现线程池" class="headerlink" title="0x01 逐步实现线程池"></a>0x01 逐步实现线程池</h2><h3 id="线程池原理"><a href="#线程池原理" class="headerlink" title="线程池原理"></a>线程池原理</h3><p><strong>C++11</strong>加入了线程库，从此告别了标准库不支持并发的历史。然而C++对于多线程的支持还是比较低级，稍微高级一点的用法都需要自己去实现，比如线程池、信号量等。线程池（thread pool）这个东西，一般在面试时的回答都是：“管理一个任务队列，一个线程队列，然后每次去一个任务分配给一个线程去做，循环往复。”这回答貌似没有问题，但是写起程序来的时候就出问题了。</p>
<p>有什么问题？线程池一般是要复用线程，所以如果是取一个task分配给某一个thread，执行完之后再重新分配，在语言层面这是基本不能实现的：C++的thread都是执行一个固定的task函数，执行完之后线程也就结束了。所以该如何实现task和thread的分配呢？</p>
<p><strong>让每一个thread创建后，就去执行调度函数：循环获取task，然后执行。</strong></p>
<p>这个循环该什么时候停止呢？</p>
<p>很简单，<strong>当线程池停止使用时</strong>，循环停止。</p>
<p>这样一来，就保证了thread函数的唯一性，而且复用线程执行task。</p>
<p>总结一下，我们的线程池的主要组成部分有二：</p>
<ul>
<li>任务队列（Task Queue）</li>
<li>线程池（Thread Pool）</li>
</ul>
<p>线程池与任务队列之间的匹配操作，是典型的<em>生产者-消费者</em>模型，本模型使用了两个工具：一个==mutex== + 一个==条件变量==。mutex就是锁，保证任务的添加和移除（获取）的互斥性；一个条件变量保证多个线程获取task的同步性：当任务队列为空时，线程应该等待（阻塞）。</p>
<p>接下来我们就可以逐渐将一块块积木拼成一个完整的简易线程池。</p>
<h3 id="积木1：任务队列（Task-Queue）"><a href="#积木1：任务队列（Task-Queue）" class="headerlink" title="积木1：任务队列（Task Queue）"></a>积木1：任务队列（Task Queue）</h3><p>我们会理所当然地希望任务以发送它相同的顺序来逐个执行，因此队列是最适合的数据结构。</p>
<p>这里我们把任务队列单拿出来，独自为类，方便以后进行各种骚操作。</p>
<p>将任务队列单拿出来之后，我们应考虑一个问题：正如上一节提到的线程池task与thread的分配方法所示，线程池中的线程会持续查询任务队列是否有可用工作。当两个甚至多个线程试图同时执行查询工作时，这会引起难以估计的灾难。因而我们需要对C++的<code>std::queue</code>进行包装，实现一个<strong>线程安全</strong>的<em>SafeQueue</em>。</p>
<p>实现一个线程安全的<em>SafeQueue</em>原理很简单，利用<strong>mutex</strong>来限制并发访问即可。我们可以在<em>SafeQueue</em>类中定义一个<code>std::mutex</code>类型的成员变量，并在相应的操作接口（如入队接口<code>enqueue()</code>）中利用互斥体包装器来管理这个mutex，确保没有其他人正在访问该资源。</p>
<p>下面给出完整的<em>SafeQueue</em>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SafeQueue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::queue&lt;T&gt; m_queue; <span class="comment">//利用模板函数构造队列</span></span><br><span class="line"></span><br><span class="line">    std::mutex m_mutex; <span class="comment">// 访问互斥信号量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SafeQueue</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">SafeQueue</span>(SafeQueue &amp;&amp;other) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">SafeQueue</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="comment">// 返回队列是否为空</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_mutex)</span></span>; <span class="comment">// 互斥信号变量加锁，防止m_queue被改变</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> m_queue.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_mutex)</span></span>; <span class="comment">// 互斥信号变量加锁，防止m_queue被改变</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> m_queue.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 队列添加元素</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(T &amp;t)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">        m_queue.<span class="built_in">emplace</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 队列取出元素</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dequeue</span><span class="params">(T &amp;t)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_mutex)</span></span>; <span class="comment">// 队列加锁</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (m_queue.<span class="built_in">empty</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        t = std::<span class="built_in">move</span>(m_queue.<span class="built_in">front</span>()); <span class="comment">// 取出队首元素，返回队首元素值，并进行右值引用</span></span><br><span class="line"></span><br><span class="line">        m_queue.<span class="built_in">pop</span>(); <span class="comment">// 弹出入队的第一个元素</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="积木2：线程池（Thread-Pool）"><a href="#积木2：线程池（Thread-Pool）" class="headerlink" title="积木2：线程池（Thread Pool）"></a>积木2：线程池（Thread Pool）</h3><p>线程池是线程池模型的主体，我们将它拆成更小的部分来逐步分析，方便理解。</p>
<h4 id="2-1-提交函数"><a href="#2-1-提交函数" class="headerlink" title="2-1 提交函数"></a>2-1 提交函数</h4><p>线程池最重要的方法就是负责向任务队列添加任务。我们的提交函数应该做到以下两点：</p>
<ul>
<li>接收任何参数的任何函数。（普通函数，==Lambda==，==成员函数==……）</li>
<li>立即返回“东西”，避免阻塞主线程。这里返回的“东西”或者说“对象”应该包含任务结束的结果。</li>
</ul>
<p>完整的提交函数如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Submit a function to be executed asynchronously by the pool</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">submit</span><span class="params">(F &amp;&amp;f, Args &amp;&amp;...args)</span> -&gt; std::future&lt;<span class="title">decltype</span><span class="params">(f(args...))</span>&gt; ①</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// Create a function with bounded parameter ready to execute</span></span><br><span class="line">        std::function&lt;<span class="keyword">decltype</span>(<span class="built_in">f</span>(args...))()&gt; func = std::<span class="built_in">bind</span>(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...); ②<span class="comment">// 连接函数和参数定义，特殊函数类型，避免左右值错误</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Encapsulate it into a shared pointer in order to be able to copy construct</span></span><br><span class="line">        <span class="keyword">auto</span> task_ptr = std::make_shared&lt;std::packaged_task&lt;<span class="keyword">decltype</span>(<span class="built_in">f</span>(args...))()&gt;&gt;(func);  ③</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Warp packaged task into void function</span></span><br><span class="line">        std::function&lt;<span class="built_in"><span class="keyword">void</span></span>()&gt; warpper_func = [task_ptr]()</span><br><span class="line">        &#123;</span><br><span class="line">            (*task_ptr)();</span><br><span class="line">        &#125;;  ④</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 队列通用安全封包函数，并压入安全队列</span></span><br><span class="line">        m_queue.<span class="built_in">enqueue</span>(warpper_func);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 唤醒一个等待中的线程</span></span><br><span class="line">        m_conditional_lock.<span class="built_in">notify_one</span>();  ⑤</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回先前注册的任务指针</span></span><br><span class="line">        <span class="keyword">return</span> task_ptr-&gt;<span class="built_in">get_future</span>();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>C++11众多的语法糖正式来袭。下面讲一下需要注意的地方：</p>
<ol>
<li><p><code>submit()</code>是一个模板函数，这很明显。<code>template&lt;typename F, typename... Args&gt;</code>中的<code>typename... Args</code>是C++11引入的<strong>可变模版参数</strong>（variadic templates），很容易理解。</p>
<p>首先来看长得奇奇怪怪的函数头部分，<code>auto submit(F &amp;&amp;f, Args &amp;&amp;...args) -&gt; std::future&lt;decltype(f(args...))&gt;</code>，这里函数类型的定义用到了叫做<strong>“尾返回类型推导”</strong>的技巧。</p>
<p>按照标准，<code>auto</code>关键字不能用于函数形参的类型推导，==在C++14以前==，也不能直接用<code>auto func()</code>的形式来推导函数的返回类型。</p>
<p>因此传统C++中我们必须这么写：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function">R <span class="title">add</span><span class="params">(T x, U y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样存在很明显的缺陷：事实上很多时候我们并不知道<code>add()</code>这个函数会进行什么操作，获取什么样的返回类型。</p>
<p>最终在C++11中这个问题得到了解决。C++11关键字<code>decltype</code>解决了<code>auto</code>关键字只能对变量类型进行类型推导的缺陷。它的用法也很简单，应该也是看过C++11标准就能记住的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(表达式)</span><br></pre></td></tr></table></figure>

<p>但是为了利用<code>decltype</code>来推导函数的返回类型，我们并不能直接写出这种形式的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(x+y) <span class="built_in">add</span>(T x, U y)</span><br></pre></td></tr></table></figure>

<p>因为编译器在读到<code>decltype(x+y)</code>时，<code>x</code>和<code>y</code>尚未定义。而这个问题的解决方案，正是<strong>尾返回类型推导</strong>。C++11引入了一个<strong>尾返回类型</strong>（trailing return type），利用<code>auto</code>关键字将返回类型后置：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add2</span><span class="params">(T x, U y)</span> -&gt; <span class="title">decltype</span><span class="params">(x+y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，看起来奇奇怪怪的函数头中关于函数的返回类型的定义已经清楚明了：该函数的返回值将从<code>std::future&lt;decltype(f(args...))&gt;</code>中自动推导得出。</p>
<p>接着谈函数头。这里我们谈一下<code>std::future</code>，它提供了一个==访问异步操作结果==的途径。我们可以使用<code>std::future</code>的<code>wait()</code>方法来设置屏障，阻塞线程，实现线程同步。并最终使用<code>std::future</code>的<code>get()</code>方法来获得执行结果。</p>
<p>对于<code>std::future</code>，可以在这篇文献中找到更详细的讲解：</p>
<p><a href="https://changkun.de/modern-cpp/zh-cn/07-thread/index.html#7-3-%E6%9C%9F%E7%89%A9">https://changkun.de/modern-cpp/zh-cn/07-thread/index.html#7-3-%E6%9C%9F%E7%89%A9</a></p>
<p>总的来说，在我们的程序中，最后将会获得返回类型为 实例化为<code>f(args...)</code>的<code>std::future&lt;&gt;</code> 的<code>submit</code>函数。</p>
<p>如果我们阅读其他一些博文或者Github上著名的99行C++11实现线程池，我们可能会看到以下形式的添加任务方法的定义：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">ThreadPool::enqueue</span><span class="params">(F&amp;&amp; f, Args&amp;&amp;... args)</span> -&gt; std::future&lt;<span class="keyword">typename</span> std::result_of&lt;<span class="title">F</span><span class="params">(Args...)</span>&gt;::type&gt;</span></span><br></pre></td></tr></table></figure>

<p>为什么我们这里不采用<code>std::result_of&lt;&gt;::type</code>的方法而是使用<code>decltype(f(args...))</code>方法，这个要结合下一点来理解。</p>
</li>
<li><p>这里我们使用了<code>std::function</code>进行包装从而产生了一个特殊函数，这个特殊函数使用<code>std::bind</code>将函数<code>f</code>和参数<code>args</code>绑定起来。</p>
<p>简单来说，<code>std::function</code>可以对多个相似的函数进行包装（即通用的描述方法）。<code>std::function</code>可以hold住任何可以通过“()”来调用的对象，包括：</p>
<ul>
<li>普通函数</li>
<li>成员函数</li>
<li>lambda</li>
<li><code>std::bind</code></li>
</ul>
<p>而<code>std::bind</code>可以<strong>将调用函数时的部分参数先制定好，留下一部分在真正调用时确定</strong>。（当然，你也可以直接指定全部参数，在调用时不再指定。）</p>
<p>对于<code>std::function</code>和<code>std::bind</code>，我们可以移步这篇博客获得更详细的讲解：</p>
<p><a href="https://paul.pub/cpp-lambda-function-bind/">https://paul.pub/cpp-lambda-function-bind/</a></p>
<p>这里我们会注意到，<code>std::bind</code>中，出现了一个<code>std::forward()</code>的特殊方法。<code>std::forward()</code>又被称作<strong>完美转发</strong>。简单来说，<code>std::forward()</code>将会完整保留参数的引用类型进行转发。如果参数是左值引用（<em>lvalue</em>），该方法会将参数保留左值引用的形式进行转发，如果参数是右值引用（<em>rvalue</em>），该方法会将参数保留右值引用的形式进行转发。而我们这里为什么要使用这个方法呢？</p>
<p>我们会对为什么使用<code>std::forward()</code>方法产生疑惑，可能是因为我们看到了函数头中的<code>F&amp;&amp; f</code>和<code>Args&amp;&amp;... args</code>，这难道不已经指明这个函数接收的参数类型应为右值引用吗？<strong>其实不然。</strong>这里的<code>F&amp;&amp; f</code>和<code>Args&amp;&amp;... args</code>中的<code>&amp;&amp;</code>并非是右值引用意思，而是一种特殊现象，这个现象被称作<strong>万能引用</strong>（universal reference）。</p>
<p><strong>万能引用</strong>可以简单理解为，当<code>T</code>是模板参数时，<code>T&amp;&amp;</code>的作用主要是保持值类别进行转发。然而，<strong>一个绑定到universial reference上的对象可能具有lvaluesness或者rvalueness，正是因为有这种二义性</strong>，所以产生了<code>std::forward</code>。</p>
<p>有关于万能引用、完美转发以及背后所隐藏的引用折叠，可以在这篇知乎回答中找到更详细的介绍：</p>
<p><a href="https://zhuanlan.zhihu.com/p/99524127">https://zhuanlan.zhihu.com/p/99524127</a></p>
<p>总的来说，②会产生一个以 函数<code>f(arg...)</code>返回类型 为返回类型、不含参数的特殊函数包装<code>func</code>。</p>
<p>这里我们也不难注意到，在网上其他的示例中，这里使用了如下方法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> return_type = <span class="keyword">typename</span> std::result_of&lt;<span class="built_in">F</span>(Args...)&gt;::type;</span><br></pre></td></tr></table></figure>

<p>可以看到，这里再次像这些示例在函数头中一样，使用了<code>std::result_of</code>方法，而结合上文，我们也不难理解为什么本文会使用<code>std::function</code>方法，即更方便地增加对将成员函数和lambda表达式作为参数的支持。</p>
</li>
<li><p>这里我们使用<code>std::make_shared&lt;&gt;()</code>方法，声明了一个<code>std::packaged_task&lt;decltype(f(args...))()&gt;</code>类型的智能指针，并将前面<code>std::function</code>方法声明的特殊函数包装<code>func</code>传入作为<code>std::packaged_task</code>的实例化参数。智能指针将更方便我们对该<code>std::packaged_task</code>对象进行管理。</p>
<p><code>std::packaged_task</code>可以用来封装任何可以调用的目标，从而用于实现异步的调用。</p>
</li>
<li><p>这里我们再次利用<code>std::function</code>，将<em>task_ptr</em>指向的<strong>std::packaged_task</strong>对象取出并包装为void函数。这样我们的代码将更加美观优雅。</p>
<p>当然，我们也可以像其他示例一样，将这一步和下一步任务进入队列操作简化为一步：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">m_queue.<span class="built_in">enqueue</span>([task_ptr]()&#123;</span><br><span class="line">    (*task_ptr)();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li><p>这里条件变量会通知一个处于<em>wait</em>状态的线程，该线程将会从任务队列中取得任务并执行。</p>
<p>这里简要介绍一下条件变量（<code>std::condition_variable</code>）：</p>
<p>条件变量 <code>std::condition_variable</code> 是为了解决死锁而生，当互斥操作不够用而引入的。比如，线程可能需要等待某个条件为真才能继续执行，而一个忙等待循环中可能会导致所有其他线程都无法进入临界区使得条件为真时，就会发生死锁。所以，<code>condition_variable</code>实例被创建出现主要就是用于唤醒等待线程从而避免死锁。<code>std::condition_variable</code>的<code>notify_one()</code>用于唤醒一个线程；<code>notify_all()</code>则是通知所有线程。</p>
</li>
</ol>
<p>提交函数到此结束。</p>
<hr>
<h4 id="2-2-内置工作线程类"><a href="#2-2-内置工作线程类" class="headerlink" title="2-2 内置工作线程类"></a>2-2 内置工作线程类</h4><p>本文在线程池中设立私有成员类<em>ThreadWoker</em>作为内置线程工作类，执行真正的工作。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadWorker</span> // 内置线程工作类</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_id; <span class="comment">// 工作id</span></span><br><span class="line"></span><br><span class="line">    ThreadPool *m_pool; <span class="comment">// 所属线程池</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">ThreadWorker</span>(ThreadPool *pool, <span class="keyword">const</span> <span class="keyword">int</span> id) : <span class="built_in">m_pool</span>(pool), <span class="built_in">m_id</span>(id)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载()操作</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::function&lt;<span class="built_in"><span class="keyword">void</span></span>()&gt; func; <span class="comment">// 定义基础函数类func</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> dequeued; <span class="comment">// 是否正在取出队列中元素</span></span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 判断线程池是否关闭，没有关闭则从任务队列中循环提取任务</span></span><br><span class="line">        <span class="keyword">while</span> (!m_pool-&gt;m_shutdown)</span><br><span class="line">        &#123;</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 为线程环境加锁，互访问工作线程的休眠和唤醒</span></span><br><span class="line">                <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_pool-&gt;m_conditional_mutex)</span></span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果任务队列为空，阻塞当前线程</span></span><br><span class="line">                <span class="keyword">if</span> (m_pool-&gt;m_queue.<span class="built_in">empty</span>())</span><br><span class="line">                &#123;</span><br><span class="line">                    m_pool-&gt;m_conditional_lock.<span class="built_in">wait</span>(lock); <span class="comment">// 等待条件变量通知，开启线程</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 取出任务队列中的元素</span></span><br><span class="line">                dequeued = m_pool-&gt;m_queue.<span class="built_in">dequeue</span>(func);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果成功取出，执行工作函数</span></span><br><span class="line">            <span class="keyword">if</span> (dequeued)</span><br><span class="line">                <span class="built_in">func</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里应该重点关注重载()操作的<code>void operator()()</code>，这里面进行了任务的取出与执行。</p>
<p>参照注释和上文，我们使用了一个while循环，在线程池处于工作时循环从任务队列中提取任务。并利用条件变量，在任务队列为空时阻塞当前线程，等待上文中的提交函数添加任务后发出的通知。在任务队列不为空时，我们将任务队列中的任务取出，并放在事先声明的基础函数类<em>func</em>中。成功取出后便立即执行该任务。</p>
<h4 id="线程池完整代码"><a href="#线程池完整代码" class="headerlink" title="线程池完整代码"></a>线程池完整代码</h4><p>下面给出线程池的完整代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadPool</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ThreadWorker</span> // 内置线程工作类</span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> m_id; <span class="comment">// 工作id</span></span><br><span class="line"></span><br><span class="line">        ThreadPool *m_pool; <span class="comment">// 所属线程池</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// 构造函数</span></span><br><span class="line">        <span class="built_in">ThreadWorker</span>(ThreadPool *pool, <span class="keyword">const</span> <span class="keyword">int</span> id) : <span class="built_in">m_pool</span>(pool), <span class="built_in">m_id</span>(id)</span><br><span class="line">        &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重载()操作</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            std::function&lt;<span class="built_in"><span class="keyword">void</span></span>()&gt; func; <span class="comment">// 定义基础函数类func</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">bool</span> dequeued; <span class="comment">// 是否正在取出队列中元素</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (!m_pool-&gt;m_shutdown)</span><br><span class="line">            &#123;</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 为线程环境加锁，互访问工作线程的休眠和唤醒</span></span><br><span class="line">                    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_pool-&gt;m_conditional_mutex)</span></span>;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 如果任务队列为空，阻塞当前线程</span></span><br><span class="line">                    <span class="keyword">if</span> (m_pool-&gt;m_queue.<span class="built_in">empty</span>())</span><br><span class="line">                    &#123;</span><br><span class="line">                        m_pool-&gt;m_conditional_lock.<span class="built_in">wait</span>(lock); <span class="comment">// 等待条件变量通知，开启线程</span></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 取出任务队列中的元素</span></span><br><span class="line">                    dequeued = m_pool-&gt;m_queue.<span class="built_in">dequeue</span>(func);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果成功取出，执行工作函数</span></span><br><span class="line">                <span class="keyword">if</span> (dequeued)</span><br><span class="line">                    <span class="built_in">func</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> m_shutdown; <span class="comment">// 线程池是否关闭</span></span><br><span class="line"></span><br><span class="line">    SafeQueue&lt;std::function&lt;<span class="built_in"><span class="keyword">void</span></span>()&gt;&gt; m_queue; <span class="comment">// 执行函数安全队列，即任务队列</span></span><br><span class="line"></span><br><span class="line">    std::vector&lt;std::thread&gt; m_threads; <span class="comment">// 工作线程队列</span></span><br><span class="line"></span><br><span class="line">    std::mutex m_conditional_mutex; <span class="comment">// 线程休眠锁互斥变量</span></span><br><span class="line"></span><br><span class="line">    std::condition_variable m_conditional_lock; <span class="comment">// 线程环境锁，可以让线程处于休眠或者唤醒状态</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 线程池构造函数</span></span><br><span class="line">    <span class="built_in">ThreadPool</span>(<span class="keyword">const</span> <span class="keyword">int</span> n_threads = <span class="number">4</span>)</span><br><span class="line">        : <span class="built_in">m_threads</span>(std::vector&lt;std::thread&gt;(n_threads)), <span class="built_in">m_shutdown</span>(<span class="literal">false</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ThreadPool</span>(<span class="keyword">const</span> ThreadPool &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ThreadPool</span>(ThreadPool &amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    ThreadPool &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> ThreadPool &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    ThreadPool &amp;<span class="keyword">operator</span>=(ThreadPool &amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Inits thread pool</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m_threads.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            m_threads.<span class="built_in">at</span>(i) = std::<span class="built_in">thread</span>(<span class="built_in">ThreadWorker</span>(<span class="keyword">this</span>, i)); <span class="comment">// 分配工作线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Waits until threads finish their current task and shutdowns the pool</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_shutdown = <span class="literal">true</span>;</span><br><span class="line">        m_conditional_lock.<span class="built_in">notify_all</span>(); <span class="comment">// 通知，唤醒所有工作线程</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m_threads.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (m_threads.<span class="built_in">at</span>(i).<span class="built_in">joinable</span>()) <span class="comment">// 判断线程是否在等待</span></span><br><span class="line">            &#123;</span><br><span class="line">                m_threads.<span class="built_in">at</span>(i).<span class="built_in">join</span>(); <span class="comment">// 将线程加入到等待队列</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Submit a function to be executed asynchronously by the pool</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">submit</span><span class="params">(F &amp;&amp;f, Args &amp;&amp;...args)</span> -&gt; std::future&lt;<span class="title">decltype</span><span class="params">(f(args...))</span>&gt;</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// Create a function with bounded parameter ready to execute</span></span><br><span class="line">        std::function&lt;<span class="keyword">decltype</span>(<span class="built_in">f</span>(args...))()&gt; func = std::<span class="built_in">bind</span>(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...); <span class="comment">// 连接函数和参数定义，特殊函数类型，避免左右值错误</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Encapsulate it into a shared pointer in order to be able to copy construct</span></span><br><span class="line">        <span class="keyword">auto</span> task_ptr = std::make_shared&lt;std::packaged_task&lt;<span class="keyword">decltype</span>(<span class="built_in">f</span>(args...))()&gt;&gt;(func);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Warp packaged task into void function</span></span><br><span class="line">        std::function&lt;<span class="built_in"><span class="keyword">void</span></span>()&gt; warpper_func = [task_ptr]()</span><br><span class="line">        &#123;</span><br><span class="line">            (*task_ptr)();</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 队列通用安全封包函数，并压入安全队列</span></span><br><span class="line">        m_queue.<span class="built_in">enqueue</span>(warpper_func);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 唤醒一个等待中的线程</span></span><br><span class="line">        m_conditional_lock.<span class="built_in">notify_one</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回先前注册的任务指针</span></span><br><span class="line">        <span class="keyword">return</span> task_ptr-&gt;<span class="built_in">get_future</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>结合注释应该能很轻松的理解线程池剩余的代码。</p>
<p>注意一下<code>init()</code>函数和<code>shutdown()</code>函数：</p>
<ul>
<li>在线程池初始化函数<code>init()</code>中，我们声明并分配工作线程，将工作线程放入工作线程队列<em>m_threads</em>中。</li>
<li>在线程池关闭函数<code>shutdown()</code>中，我们唤醒所有工作线程，并等待期完成所有工作后关闭线程池。</li>
</ul>
<p>这里我们也可以改进一下代码，将<code>shutdown()</code>函数中的工作转移到<em>ThreadPool</em>的析构函数中，从而更便利日后的使用。</p>
<p>至此，线程池全文讲解结束，后附完整项目代码及参考资料。</p>
<h2 id="0x02-项目完整代码"><a href="#0x02-项目完整代码" class="headerlink" title="0x02 项目完整代码"></a>0x02 项目完整代码</h2><h3 id="线程池代码"><a href="#线程池代码" class="headerlink" title="线程池代码"></a>线程池代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//thread_pool.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> THREAD_POOL_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THREAD_POOL_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Thread safe implementation of a Queue using a std::queue</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SafeQueue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::queue&lt;T&gt; m_queue; <span class="comment">//利用模板函数构造队列</span></span><br><span class="line"></span><br><span class="line">    std::mutex m_mutex; <span class="comment">// 访问互斥信号量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SafeQueue</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">SafeQueue</span>(SafeQueue &amp;&amp;other) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">SafeQueue</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="comment">// 返回队列是否为空</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_mutex)</span></span>; <span class="comment">// 互斥信号变量加锁，防止m_queue被改变</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> m_queue.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_mutex)</span></span>; <span class="comment">// 互斥信号变量加锁，防止m_queue被改变</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> m_queue.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 队列添加元素</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(T &amp;t)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">        m_queue.<span class="built_in">emplace</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 队列取出元素</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dequeue</span><span class="params">(T &amp;t)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_mutex)</span></span>; <span class="comment">// 队列加锁</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (m_queue.<span class="built_in">empty</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        t = std::<span class="built_in">move</span>(m_queue.<span class="built_in">front</span>()); <span class="comment">// 取出队首元素，返回队首元素值，并进行右值引用</span></span><br><span class="line"></span><br><span class="line">        m_queue.<span class="built_in">pop</span>(); <span class="comment">// 弹出入队的第一个元素</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadPool</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ThreadWorker</span> // 内置线程工作类</span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> m_id; <span class="comment">// 工作id</span></span><br><span class="line"></span><br><span class="line">        ThreadPool *m_pool; <span class="comment">// 所属线程池</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// 构造函数</span></span><br><span class="line">        <span class="built_in">ThreadWorker</span>(ThreadPool *pool, <span class="keyword">const</span> <span class="keyword">int</span> id) : <span class="built_in">m_pool</span>(pool), <span class="built_in">m_id</span>(id)</span><br><span class="line">        &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重载()操作</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            std::function&lt;<span class="built_in"><span class="keyword">void</span></span>()&gt; func; <span class="comment">// 定义基础函数类func</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">bool</span> dequeued; <span class="comment">// 是否正在取出队列中元素</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (!m_pool-&gt;m_shutdown)</span><br><span class="line">            &#123;</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 为线程环境加锁，互访问工作线程的休眠和唤醒</span></span><br><span class="line">                    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_pool-&gt;m_conditional_mutex)</span></span>;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 如果任务队列为空，阻塞当前线程</span></span><br><span class="line">                    <span class="keyword">if</span> (m_pool-&gt;m_queue.<span class="built_in">empty</span>())</span><br><span class="line">                    &#123;</span><br><span class="line">                        m_pool-&gt;m_conditional_lock.<span class="built_in">wait</span>(lock); <span class="comment">// 等待条件变量通知，开启线程</span></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 取出任务队列中的元素</span></span><br><span class="line">                    dequeued = m_pool-&gt;m_queue.<span class="built_in">dequeue</span>(func);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果成功取出，执行工作函数</span></span><br><span class="line">                <span class="keyword">if</span> (dequeued)</span><br><span class="line">                    <span class="built_in">func</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> m_shutdown; <span class="comment">// 线程池是否关闭</span></span><br><span class="line"></span><br><span class="line">    SafeQueue&lt;std::function&lt;<span class="built_in"><span class="keyword">void</span></span>()&gt;&gt; m_queue; <span class="comment">// 执行函数安全队列，即任务队列</span></span><br><span class="line"></span><br><span class="line">    std::vector&lt;std::thread&gt; m_threads; <span class="comment">// 工作线程队列</span></span><br><span class="line"></span><br><span class="line">    std::mutex m_conditional_mutex; <span class="comment">// 线程休眠锁互斥变量</span></span><br><span class="line"></span><br><span class="line">    std::condition_variable m_conditional_lock; <span class="comment">// 线程环境锁，可以让线程处于休眠或者唤醒状态</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 线程池构造函数</span></span><br><span class="line">    <span class="built_in">ThreadPool</span>(<span class="keyword">const</span> <span class="keyword">int</span> n_threads = <span class="number">4</span>)</span><br><span class="line">        : <span class="built_in">m_threads</span>(std::vector&lt;std::thread&gt;(n_threads)), <span class="built_in">m_shutdown</span>(<span class="literal">false</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ThreadPool</span>(<span class="keyword">const</span> ThreadPool &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ThreadPool</span>(ThreadPool &amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    ThreadPool &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> ThreadPool &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    ThreadPool &amp;<span class="keyword">operator</span>=(ThreadPool &amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Inits thread pool</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m_threads.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            m_threads.<span class="built_in">at</span>(i) = std::<span class="built_in">thread</span>(<span class="built_in">ThreadWorker</span>(<span class="keyword">this</span>, i)); <span class="comment">// 分配工作线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Waits until threads finish their current task and shutdowns the pool</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_shutdown = <span class="literal">true</span>;</span><br><span class="line">        m_conditional_lock.<span class="built_in">notify_all</span>(); <span class="comment">// 通知，唤醒所有工作线程</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m_threads.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (m_threads.<span class="built_in">at</span>(i).<span class="built_in">joinable</span>()) <span class="comment">// 判断线程是否在等待</span></span><br><span class="line">            &#123;</span><br><span class="line">                m_threads.<span class="built_in">at</span>(i).<span class="built_in">join</span>(); <span class="comment">// 将线程加入到等待队列</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Submit a function to be executed asynchronously by the pool</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">submit</span><span class="params">(F &amp;&amp;f, Args &amp;&amp;...args)</span> -&gt; std::future&lt;<span class="title">decltype</span><span class="params">(f(args...))</span>&gt;</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// Create a function with bounded parameter ready to execute</span></span><br><span class="line">        std::function&lt;<span class="keyword">decltype</span>(<span class="built_in">f</span>(args...))()&gt; func = std::<span class="built_in">bind</span>(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...); <span class="comment">// 连接函数和参数定义，特殊函数类型，避免左右值错误</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Encapsulate it into a shared pointer in order to be able to copy construct</span></span><br><span class="line">        <span class="keyword">auto</span> task_ptr = std::make_shared&lt;std::packaged_task&lt;<span class="keyword">decltype</span>(<span class="built_in">f</span>(args...))()&gt;&gt;(func);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Warp packaged task into void function</span></span><br><span class="line">        std::function&lt;<span class="built_in"><span class="keyword">void</span></span>()&gt; warpper_func = [task_ptr]()</span><br><span class="line">        &#123;</span><br><span class="line">            (*task_ptr)();</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 队列通用安全封包函数，并压入安全队列</span></span><br><span class="line">        m_queue.<span class="built_in">enqueue</span>(warpper_func);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 唤醒一个等待中的线程</span></span><br><span class="line">        m_conditional_lock.<span class="built_in">notify_one</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回先前注册的任务指针</span></span><br><span class="line">        <span class="keyword">return</span> task_ptr-&gt;<span class="built_in">get_future</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>



<h3 id="测试样例代码"><a href="#测试样例代码" class="headerlink" title="测试样例代码"></a>测试样例代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;random&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;thread_pool.h&quot;</span></span></span><br><span class="line">std::random_device rd; <span class="comment">// 真实随机数产生器</span></span><br><span class="line"></span><br><span class="line"><span class="function">std::mt19937 <span class="title">mt</span><span class="params">(rd())</span></span>; <span class="comment">//生成计算随机数mt</span></span><br><span class="line"></span><br><span class="line"><span class="function">std::uniform_int_distribution&lt;<span class="keyword">int</span>&gt; <span class="title">dist</span><span class="params">(<span class="number">-1000</span>, <span class="number">1000</span>)</span></span>; <span class="comment">//生成-1000到1000之间的离散均匀分布数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> rnd = std::<span class="built_in">bind</span>(dist, mt);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置线程睡眠时间</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">simulate_hard_computation</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">2000</span> + <span class="built_in">rnd</span>()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加两个数字的简单函数并打印结果</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">multiply</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> a, <span class="keyword">const</span> <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">simulate_hard_computation</span>();</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> res = a * b;</span><br><span class="line">    std::cout &lt;&lt; a &lt;&lt; <span class="string">&quot; * &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; res &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加并输出结果</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">multiply_output</span><span class="params">(<span class="keyword">int</span> &amp;out, <span class="keyword">const</span> <span class="keyword">int</span> a, <span class="keyword">const</span> <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">simulate_hard_computation</span>();</span><br><span class="line">    out = a * b;</span><br><span class="line">    std::cout &lt;&lt; a &lt;&lt; <span class="string">&quot; * &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; out &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果返回</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">multiply_return</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> a, <span class="keyword">const</span> <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">simulate_hard_computation</span>();</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> res = a * b;</span><br><span class="line">    std::cout &lt;&lt; a &lt;&lt; <span class="string">&quot; * &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; res &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">example</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建3个线程的线程池</span></span><br><span class="line">    <span class="function">ThreadPool <span class="title">pool</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化线程池</span></span><br><span class="line">    pool.<span class="built_in">init</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提交乘法操作，总共30个</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">10</span>; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            pool.<span class="built_in">submit</span>(multiply, i, j);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用ref传递的输出参数提交函数</span></span><br><span class="line">    <span class="keyword">int</span> output_ref;</span><br><span class="line">    <span class="keyword">auto</span> future1 = pool.<span class="built_in">submit</span>(multiply_output, std::<span class="built_in">ref</span>(output_ref), <span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待乘法输出完成</span></span><br><span class="line">    future1.<span class="built_in">get</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Last operation result is equals to &quot;</span> &lt;&lt; output_ref &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用return参数提交函数</span></span><br><span class="line">    <span class="keyword">auto</span> future2 = pool.<span class="built_in">submit</span>(multiply_return, <span class="number">5</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待乘法输出完成</span></span><br><span class="line">    <span class="keyword">int</span> res = future2.<span class="built_in">get</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Last operation result is equals to &quot;</span> &lt;&lt; res &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭线程池</span></span><br><span class="line">    pool.<span class="built_in">shutdown</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">example</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="0x03-参考资料"><a href="#0x03-参考资料" class="headerlink" title="0x03 参考资料"></a>0x03 参考资料</h2><ol>
<li>《C++后端线程池》：<a href="https://wangpengcheng.github.io/2019/05/17/cplusplus_theadpool/">https://wangpengcheng.github.io/2019/05/17/cplusplus_theadpool/</a></li>
<li>《基于C++11的线程池（threadpool），简介且可以带任意多的参数》：<a href="https://www.cnblogs.com/lzpong/p/6397997.html">https://www.cnblogs.com/lzpong/p/6397997.html</a></li>
<li>《C++并发编程（从C++11到C++17）》：<a href="https://paul.pub/cpp-concurrency">https://paul.pub/cpp-concurrency</a></li>
<li>《从pthread转换到std::thread》：<a href="https://segmentfault.com/a/1190000002655852">https://segmentfault.com/a/1190000002655852</a></li>
<li>《货比三家：C++中的task based并发》：<a href="https://segmentfault.com/a/1190000002706259">https://segmentfault.com/a/1190000002706259</a></li>
<li>Github-99行线程池实现：<a href="https://github.com/progschj/ThreadPool">https://github.com/progschj/ThreadPool</a></li>
<li>《现代C++之万能引用、完美转发、引用折叠》：<a href="https://zhuanlan.zhihu.com/p/99524127">https://zhuanlan.zhihu.com/p/99524127</a></li>
<li>《C++11中的lambda，std::function以及std:bind》：<a href="https://paul.pub/cpp-lambda-function-bind/">https://paul.pub/cpp-lambda-function-bind/</a></li>
<li>《现代C++教程——告诉上手C++11/14/17/20》：<a href="https://changkun.de/modern-cpp/">https://changkun.de/modern-cpp/</a></li>
</ol>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++11</tag>
        <tag>C++高并发</tag>
        <tag>C++线程池</tag>
      </tags>
  </entry>
  <entry>
    <title>C++并发编程</title>
    <url>/2021/04/22/C++%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="C-Concurrency"><a href="#C-Concurrency" class="headerlink" title="C++ Concurrency"></a>C++ Concurrency</h1><h2 id="0x00-概念"><a href="#0x00-概念" class="headerlink" title="0x00 概念"></a>0x00 概念</h2><p>CPP11标准以来，C++语言开始支持多线程模型。借助多线程模型，可以开发出更好的并发系统。</p>
<span id="more"></span>

<h3 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h3><ul>
<li>并发(Concurrent)：如果多个队列可以交替使用某台咖啡机，则这一行为就是并发的。</li>
<li>并行(Parallel)：如果存在多台咖啡机可以被多个队列交替使用，则就是并行。</li>
</ul>
<img src="https://paul-pub.oss-cn-beijing.aliyuncs.com/2019/2019-11-26-cpp-concurrency/con_and_par.jpg" alt="img" style="zoom:80%;" />

<p>并发和并行都是在多任务的环境下的讨论。并行其实是并发的子集，他们的区别在于是否具有多个处理器。</p>
<p>进程与线程是操作系统的基本概念。</p>
<blockquote>
<ul>
<li><strong>进程</strong>(process)：计算机已运行的程序。进程是程序的基本执行实体；</li>
<li><strong>线程</strong>(thread)：操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。</li>
</ul>
</blockquote>
<p>绝大多数情况下，所写的程序在一个进程中运行。一个进程至少会包含一个线程。这个线程我们通常称之为==主线程==。</p>
<p>在默认情况下，代码都是在进程的主线程中运行，除非开发者在程序中创建了新的线程。</p>
<p>任务在何时占有处理器，通常是由操作系统的调度策略决定的。当开发跨平台软件时，不应对调度策略做任何假设，而应该抱有“系统可能以任意顺序来调度我的任务”这样的想法。</p>
<h3 id="并发系统的性能"><a href="#并发系统的性能" class="headerlink" title="并发系统的性能"></a>并发系统的性能</h3><p>开发并发系统最主要的动机就是提升系统性能（<em>事实上，这是以增加复杂度为代价的</em>）。</p>
<p><strong>阿姆达尔定律</strong>告诉我们将系统并行之后性能收益的上限。</p>
<h2 id="0x01-C-与并发编程"><a href="#0x01-C-与并发编程" class="headerlink" title="0x01 C++与并发编程"></a>0x01 C++与并发编程</h2><h3 id="C-标准特性的路线图"><a href="#C-标准特性的路线图" class="headerlink" title="C++标准特性的路线图"></a>C++标准特性的路线图</h3><p><img src="https://paul-pub.oss-cn-beijing.aliyuncs.com/2019/2019-11-26-cpp-concurrency/cpp_timeline.png" alt="img"></p>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><h4 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 01_hello_thread.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span> <span class="comment">// ①</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; <span class="comment">// ②</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123; <span class="comment">// ③</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Hello World from new thread.&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">thread <span class="title">t</span><span class="params">(hello)</span></span>; <span class="comment">// ④</span></span><br><span class="line">  t.<span class="built_in">join</span>(); <span class="comment">// ⑤</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li>为了使用多线程的接口，我们需要<code>#include &lt;thread&gt;</code>头文件。</li>
<li>为了简化声明，本文中的代码都将<code>using namespace std;</code>。</li>
<li>新建线程的入口是一个普通的函数，它并没有什么特别的地方。</li>
<li>创建线程的方式就是构造一个<code>thread</code>对象，并指定入口函数。与普通对象不一样的是，此时编译器便会为我们创建一个新的操作系统线程，并在新的线程中执行我们的入口函数。</li>
<li>关于<code>join</code>函数在下文中讲解。</li>
</ol>
</blockquote>
<p>==thread==可以和==callable==类型一起工作，因此也可以直接用<em>lambda</em>来写线程逻辑。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 02_lambda_thread.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">thread <span class="title">t</span><span class="params">([] &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    cout &lt;&lt; <span class="string">&quot;Hello World from lambda thread.&quot;</span> &lt;&lt; endl;</span></span></span><br><span class="line"><span class="params"><span class="function">  &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">  t.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以==传递参数==给入口函数，像下面这样：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 03_thread_argument.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">(string name)</span> </span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Welcome to &quot;</span> &lt;&lt; name &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">thread <span class="title">t</span><span class="params">(hello, <span class="string">&quot;https://paul.pub&quot;</span>)</span></span>;</span><br><span class="line">  t.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>甚至可以传递一个类成员函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 假设buy是一个可调用的函数对象，它即可能是函数指针，也可能是函数对象</span></span><br><span class="line"><span class="function">std::thread <span class="title">Annie</span><span class="params">(buy)</span></span>;</span><br><span class="line"><span class="comment">// Annie会去执行buy()</span></span><br><span class="line"><span class="function">std::thread <span class="title">Bob</span><span class="params">(buy, book, food)</span></span>;</span><br><span class="line"><span class="comment">// Bob会去执行buy(book, food)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设buy是Consumer的一个可调用的成员函数</span></span><br><span class="line">Consumer Clara;</span><br><span class="line"><span class="function">std::thread <span class="title">action</span><span class="params">(buy, std::ref(Clara), phone)</span></span>;</span><br><span class="line"><span class="comment">// Clara会去执行Consumer.buy(phone)</span></span><br></pre></td></tr></table></figure>



<p>应注意，<strong>参数以拷贝的形式传递</strong>。对于拷贝耗时的对象可能需要传递指针或者引用类型作为参数。但是传递指针和引用，还应考虑参数对象的生命周期。</p>
<p><strong>注意：</strong>当创建了一个（非空的）线程对象时，对应线程就会执行。</p>
<h4 id="join与detach"><a href="#join与detach" class="headerlink" title="join与detach"></a>join与detach</h4><ul>
<li>主要API</li>
</ul>
<table>
<thead>
<tr>
<th>API</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>join</td>
<td>等待线程完成其执行</td>
</tr>
<tr>
<td>detach</td>
<td>允许线程独立执行</td>
</tr>
</tbody></table>
<p>线程启动之后，必须决定等待直接它结束（==join==），还是让他独立运行（==detach==），必须二者选其一。若在==thread==对象<strong>销毁的时候</strong>还没有做决定，则==thread==对象在析构函数将调用==std::terminate()==从而导致进程异常退出。</p>
<ul>
<li><code>join</code>：调用此接口时，当前线程会一直阻塞，直到目标线程执行完成（当然，很可能目标线程在此处调用之前就已经执行完成了，不过这不要紧）。因此，如果目标线程的任务非常耗时，你就要考虑好是否需要在主线程上等待它了，因此这很可能会导致主线程卡住。</li>
<li><code>detach</code>：<code>detach</code>是让目标线程成为守护线程（daemon threads）。一旦<code>detach</code>之后，目标线程将独立执行，即便其对应的<code>thread</code>对象销毁也不影响线程的执行。并且，你无法再与之通信。</li>
</ul>
<h4 id="管理当前线程"><a href="#管理当前线程" class="headerlink" title="管理当前线程"></a>管理当前线程</h4><ul>
<li>主要API</li>
</ul>
<table>
<thead>
<tr>
<th align="left">API</th>
<th align="left">C++标准</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">yield</td>
<td align="left">C++11</td>
<td align="left">让出处理器，重新调度各执行线程</td>
</tr>
<tr>
<td align="left">get_id</td>
<td align="left">C++11</td>
<td align="left">返回当前线程的线程 id</td>
</tr>
<tr>
<td align="left">sleep_for</td>
<td align="left">C++11</td>
<td align="left">使当前线程的执行停止指定的时间段</td>
</tr>
<tr>
<td align="left">sleep_until</td>
<td align="left">C++11</td>
<td align="left">使当前线程的执行停止直到指定的时间点</td>
</tr>
</tbody></table>
<p>上面是一些在线程内部使用的API，它们用来对当前线程做一些控制。</p>
<ul>
<li><code>yield</code> 通常用在自己的主要任务已经完成的时候，此时希望让出处理器给其他任务使用。</li>
<li><code>get_id</code> 返回当前线程的id，可以以此来标识不同的线程。</li>
<li><code>sleep_for</code> 是让当前线程停止一段时间。</li>
<li><code>sleep_until</code> 和<code>sleep_for</code>类似，但是是以具体的时间点为参数。这两个API都以<a href="https://en.cppreference.com/w/cpp/header/chrono">chrono</a> API（由于篇幅所限，这里不展开这方面内容）为基础。</li>
</ul>
<p>代码示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 04_thread_self_manage.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_time</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> now = chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line">  <span class="keyword">auto</span> <span class="keyword">in_time_t</span> = chrono::system_clock::<span class="built_in">to_time_t</span>(now);</span><br><span class="line"></span><br><span class="line">  std::stringstream ss;</span><br><span class="line">  ss &lt;&lt; <span class="built_in">put_time</span>(<span class="built_in">localtime</span>(&amp;<span class="keyword">in_time_t</span>), <span class="string">&quot;%Y-%m-%d %X&quot;</span>);</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;now is: &quot;</span> &lt;&lt; ss.<span class="built_in">str</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sleep_thread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">seconds</span>(<span class="number">3</span>));</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;[thread-&quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot;] is waking up&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">loop_thread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;[thread-&quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot;] print: &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">print_time</span>();</span><br><span class="line"></span><br><span class="line">  <span class="function">thread <span class="title">t1</span><span class="params">(sleep_thread)</span></span>;</span><br><span class="line">  <span class="function">thread <span class="title">t2</span><span class="params">(loop_thread)</span></span>;</span><br><span class="line"></span><br><span class="line">  t1.<span class="built_in">join</span>();</span><br><span class="line">  t2.<span class="built_in">detach</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">print_time</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">now is: 2019-10-13 10:17:48</span><br><span class="line">[thread-0x70000cdda000] print: 0</span><br><span class="line">[thread-0x70000cdda000] print: 1</span><br><span class="line">[thread-0x70000cdda000] print: 2</span><br><span class="line">[thread-0x70000cdda000] print: 3</span><br><span class="line">[thread-0x70000cdda000] print: 4</span><br><span class="line">[thread-0x70000cdda000] print: 5</span><br><span class="line">[thread-0x70000cdda000] print: 6</span><br><span class="line">[thread-0x70000cdda000] print: 7</span><br><span class="line">[thread-0x70000cdda000] print: 8</span><br><span class="line">[thread-0x70000cdda000] print: 9</span><br><span class="line">[thread-0x70000cd57000] is waking up</span><br><span class="line">now is: 2019-10-13 10:17:51</span><br></pre></td></tr></table></figure>



<h4 id="一次调用"><a href="#一次调用" class="headerlink" title="一次调用"></a>一次调用</h4><ul>
<li>主要API</li>
</ul>
<table>
<thead>
<tr>
<th align="left">API</th>
<th align="left">C++标准</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">call_once</td>
<td align="left">C++11</td>
<td align="left">即便在多线程环境下，也能保证只调用某个函数一次</td>
</tr>
<tr>
<td align="left">once_flag</td>
<td align="left">C++11</td>
<td align="left">与<code>call_once</code>配合使用</td>
</tr>
</tbody></table>
<p>在一些情况下，我们有些任务需要执行一次，并且我们只希望它执行一次，例如资源的初始化任务。这个时候就可以用到上面的接口。这个接口会保证，即便在多线程的环境下，相应的函数也只会调用一次。</p>
<p>下面就是一个示例：有三个线程都会使用<code>init</code>函数，但是只会有一个线程真正执行它。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 05_call_once.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Initialing...&quot;</span> &lt;&lt; endl;</span><br><span class="line">  <span class="comment">// Do something...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">worker</span><span class="params">(once_flag* flag)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">call_once</span>(*flag, init);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  once_flag flag;</span><br><span class="line"></span><br><span class="line">  <span class="function">thread <span class="title">t1</span><span class="params">(worker, &amp;flag)</span></span>;</span><br><span class="line">  <span class="function">thread <span class="title">t2</span><span class="params">(worker, &amp;flag)</span></span>;</span><br><span class="line">  <span class="function">thread <span class="title">t3</span><span class="params">(worker, &amp;flag)</span></span>;</span><br><span class="line"></span><br><span class="line">  t1.<span class="built_in">join</span>();</span><br><span class="line">  t2.<span class="built_in">join</span>();</span><br><span class="line">  t3.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="并发任务"><a href="#并发任务" class="headerlink" title="并发任务"></a>并发任务</h4><p>下面以一个并发任务为示例讲解如何引入多线程。</p>
<p>任务示例：现在假设我们需要计算某个范围内所有自然数的平方根之和，例如<code>[1, 10e8]</code>。</p>
<p>在单线程模型下，我们的代码可能是这样的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 06_naive_multithread.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">10e8</span>; <span class="comment">// ①</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">double</span> sum = <span class="number">0</span>; <span class="comment">// ②</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">worker</span><span class="params">(<span class="keyword">int</span> min, <span class="keyword">int</span> max)</span> </span>&#123; <span class="comment">// ③</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = min; i &lt;= max; i++) &#123;</span><br><span class="line">    sum += <span class="built_in">sqrt</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">serial_task</span><span class="params">(<span class="keyword">int</span> min, <span class="keyword">int</span> max)</span> </span>&#123; <span class="comment">// ④</span></span><br><span class="line">  <span class="keyword">auto</span> start_time = chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line">  sum = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">worker</span>(<span class="number">0</span>, MAX);</span><br><span class="line">  <span class="keyword">auto</span> end_time = chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line">  <span class="keyword">auto</span> ms = chrono::duration_cast&lt;chrono::milliseconds&gt;(end_time - start_time).<span class="built_in">count</span>();</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Serail task finish, &quot;</span> &lt;&lt; ms &lt;&lt; <span class="string">&quot; ms consumed, Result: &quot;</span> &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码说明如下：</p>
<ol>
<li>通过一个常量指定数据范围，这个是为了方便调整。</li>
<li>通过一个全局变量来存储结果。</li>
<li>通过一个任务函数来计算值。</li>
<li>统计任务的执行时间。</li>
</ol>
<p>这段程序输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Serail task finish, 6406 ms consumed, Result: 2.10819e+13</span><br></pre></td></tr></table></figure>

<p>很显然，上面单线程的做法性能太差了。我们的任务完全是可以并发执行的。并且任务很容易划分。</p>
<p>下面我们就尝试以多线程的方式来改造原先的程序。</p>
<p>改造后的程序如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 06_naive_multithread.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">concurrent_task</span><span class="params">(<span class="keyword">int</span> min, <span class="keyword">int</span> max)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> start_time = chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">unsigned</span> concurrent_count = thread::<span class="built_in">hardware_concurrency</span>(); <span class="comment">// ①</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;hardware_concurrency: &quot;</span> &lt;&lt; concurrent_count &lt;&lt; endl;</span><br><span class="line">  vector&lt;thread&gt; threads;</span><br><span class="line">  min = <span class="number">0</span>;</span><br><span class="line">  sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t &lt; concurrent_count; t++) &#123; <span class="comment">// ②</span></span><br><span class="line">    <span class="keyword">int</span> range = max / concurrent_count * (t + <span class="number">1</span>);</span><br><span class="line">    threads.<span class="built_in">push_back</span>(<span class="built_in">thread</span>(worker, min, range)); <span class="comment">// ③</span></span><br><span class="line">    min = range + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; t : threads) &#123;</span><br><span class="line">    t.<span class="built_in">join</span>(); <span class="comment">// ④</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> end_time = chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line">  <span class="keyword">auto</span> ms = chrono::duration_cast&lt;chrono::milliseconds&gt;(end_time - start_time).<span class="built_in">count</span>();</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Concurrent task finish, &quot;</span> &lt;&lt; ms &lt;&lt; <span class="string">&quot; ms consumed, Result: &quot;</span> &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码说明如下：</p>
<ol>
<li><code>thread::hardware_concurrency()</code>可以获取到当前硬件支持多少个线程并行执行。</li>
<li>根据处理器的情况决定线程的数量。</li>
<li>对于每一个线程都通过<code>worker</code>函数来完成任务，并划分一部分数据给它处理。</li>
<li>等待每一个线程执行结束。</li>
</ol>
<p>很好，似乎很简单就完成了并发的改造。然后我们运行一下这个程序：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hardware_concurrency: 16</span><br><span class="line">Concurrent task finish, 6246 ms consumed, Result: 1.78162e+12</span><br></pre></td></tr></table></figure>

<p>很抱歉，我们会发现这里的性能并没有明显的提升。更严重的是，这里的结果是错误的。</p>
<p>要搞清楚为什么结果不正确我们需要更多的背景知识。</p>
<p>我们知道，对于现代的处理器来说，为了加速处理的速度，每个处理器都会有自己的高速缓存（Cache），这个高速缓存是与每个处理器相对应的，如下图所示：</p>
<blockquote>
<p>事实上，目前大部分CPU的缓存已经不只一层。</p>
</blockquote>
<img src="https://paul-pub.oss-cn-beijing.aliyuncs.com/2019/2019-11-26-cpp-concurrency/cpu.png" alt="img" style="zoom:80%;" />

<p>处理器在进行计算的时候，高速缓存会参与其中，例如数据的读和写。而高速缓存和系统主存（Memory）是有可能存在不一致的。即：某个结果计算后保存在处理器的高速缓存中了，但是没有同步到主存中，此时这个值对于其他处理器就是不可见的。</p>
<p>事情还远不止这么简单。我们对于全局变量值的修改：<code>sum += sqrt(i);</code>这条语句，它并非是原子的。它其实是很多条指令的组合才能完成。假设在某个设备上，这条语句通过下面这几个步骤来完成。它们的时序可能如下所示：</p>
<img src="https://paul-pub.oss-cn-beijing.aliyuncs.com/2019/2019-11-26-cpp-concurrency/multithread.png" alt="img" style="zoom:80%;" />

<p>在时间点a的时候，所有线程对于<code>sum</code>变量的值是一致的。</p>
<p>但是在时间点b之后，thread3上已经对<code>sum</code>进行了赋值。而这个时候其他几个线程也同时在其他处理器上使用了这个值，那么这个时候它们所使用的值就是旧的（错误的）。最后得到的结果也自然是错的。</p>
<h3 id="竞争条件与临界区"><a href="#竞争条件与临界区" class="headerlink" title="竞争条件与临界区"></a>竞争条件与临界区</h3><p>当多个进程或者线程同时访问共享数据时，只要有一个任务会修改数据，那么就可能会发生问题。此时结果依赖于这些任务执行的相对时间，这种场景称为<a href="https://en.wikipedia.org/wiki/Race_condition"><strong>竞争条件</strong>（race condition）</a>。</p>
<p>访问共享数据的代码片段称之为<strong>临界区</strong>（critical section）。具体到上面这个示例，临界区就是读写<code>sum</code>变量的地方。</p>
<p>要避免竞争条件，就需要对临界区进行数据保护。</p>
<p>很自然的，现在我们能够理解发生竞争条件是因为这些线程在同时访问共享数据，其中有些线程的改动没有让其他线程知道，导致其他线程在错误的基础上进行处理，结果自然也就是错误的。</p>
<p>那么，如果一次只让一个线程访问共享数据，访问完了再让其他线程接着访问，这样就可以避免问题的发生了。</p>
<p>接下来介绍的API提供的就是这样的功能。</p>
<h3 id="互斥体与锁"><a href="#互斥体与锁" class="headerlink" title="互斥体与锁"></a>互斥体与锁</h3><h4 id="mutex"><a href="#mutex" class="headerlink" title="mutex"></a>mutex</h4><p>开发并发系统的目的主要是为了提升性能：将任务分散到多个线程，然后在不同的处理器上同时执行。这些分散开来的线程通常会包含两类任务：</p>
<ol>
<li>独立的对于划分给自己的数据的处理</li>
<li>对于处理结果的汇总</li>
</ol>
<p>其中第1项任务因为每个线程是独立的，不存在竞争条件的问题。而第2项任务，由于所有线程都可能往总结果（例如上面的<code>sum</code>变量）汇总，这就需要做保护了。在某一个具体的时刻，只应当有一个线程更新总结果，即：保证每个线程对于共享数据的访问是“互斥”的。<code>mutex</code> 就提供了这样的功能。</p>
<p><code>mutex</code>是<strong>mut</strong>ual <strong>ex</strong>clusion（互斥）的简写。</p>
<ul>
<li>主要API</li>
</ul>
<table>
<thead>
<tr>
<th align="left">API</th>
<th align="left">C++标准</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">mutex</td>
<td align="left">C++11</td>
<td align="left">提供基本互斥设施</td>
</tr>
<tr>
<td align="left">timed_mutex</td>
<td align="left">C++11</td>
<td align="left">提供互斥设施，带有超时功能</td>
</tr>
<tr>
<td align="left">recursive_mutex</td>
<td align="left">C++11</td>
<td align="left">提供能被同一线程递归锁定的互斥设施</td>
</tr>
<tr>
<td align="left">recursive_timed_mutex</td>
<td align="left">C++11</td>
<td align="left">提供能被同一线程递归锁定的互斥设施，带有超时功能</td>
</tr>
<tr>
<td align="left">shared_timed_mutex</td>
<td align="left">C++14</td>
<td align="left">提供共享互斥设施并带有超时功能</td>
</tr>
<tr>
<td align="left">shared_mutex</td>
<td align="left">C++17</td>
<td align="left">提供共享互斥设施</td>
</tr>
</tbody></table>
<p>很明显，在这些类中，<code>mutex</code>是最基础的API。其他类都是在它的基础上的改进。所以这些类都提供了下面三个方法，并且它们的功能是一样的：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>lock</td>
<td>锁定互斥体，如果不可用，则阻塞</td>
</tr>
<tr>
<td>try_lock</td>
<td>尝试锁定互斥体，如果不可用，直接返回</td>
</tr>
<tr>
<td>unlock</td>
<td>解锁互斥体</td>
</tr>
</tbody></table>
<p>这三个方法提供了基础的锁定和解除锁定的功能。使用<code>lock</code>意味着你有很强的意愿一定要获取到互斥体，而使用<code>try_lock</code>则是进行一次尝试。这意味着如果失败了，你通常还有其他的路径可以走。</p>
<p>在这些基础功能之上，其他的类分别在下面三个方面进行了扩展：</p>
<ul>
<li><strong>超时</strong>：<code>timed_mutex</code>，<code>recursive_timed_mutex</code>，<code>shared_timed_mutex</code>的名称都带有<code>timed</code>，这意味着它们都支持超时功能。它们都提供了<code>try_lock_for</code>和<code>try_lock_until</code>方法，这两个方法分别可以指定超时的时间长度和时间点。如果在超时的时间范围内没有能获取到锁，则直接返回，不再继续等待。</li>
<li><strong>可重入</strong>：<code>recursive_mutex</code>和<code>recursive_timed_mutex</code>的名称都带有<code>recursive</code>。可重入或者叫做可递归，是指在同一个线程中，同一把锁可以锁定多次。这就避免了一些不必要的死锁。</li>
<li><strong>共享</strong>：<code>shared_timed_mutex</code>和<code>shared_mutex</code>提供了共享功能。对于这类互斥体，实际上是提供了两把锁：一把是共享锁，一把是互斥锁。一旦某个线程获取了互斥锁，任何其他线程都无法再获取互斥锁和共享锁；但是如果有某个线程获取到了共享锁，其他线程无法再获取到互斥锁，但是还有获取到共享锁。这里互斥锁的使用和其他的互斥体接口和功能一样。而共享锁可以同时被多个线程同时获取到（使用共享锁的接口见下面的表格）。共享锁通常用在<a href="https://en.wikipedia.org/wiki/Readers%E2%80%93writers_problem">读者写者模型</a>上。</li>
</ul>
<p>使用共享锁的接口如下：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>lock_shared</td>
<td>获取互斥体的共享锁，如果无法获取则阻塞</td>
</tr>
<tr>
<td>try_lock_shared</td>
<td>尝试获取共享锁，如果不可用，直接返回</td>
</tr>
<tr>
<td>unlock_shared</td>
<td>解锁共享锁</td>
</tr>
</tbody></table>
<p>接下来，我们就借助刚学到的<code>mutex</code>来改造我们的并发系统，改造后的程序如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 07_mutex_lock.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">10e8</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> mutex exclusive;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">concurrent_worker</span><span class="params">(<span class="keyword">int</span> min, <span class="keyword">int</span> max)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = min; i &lt;= max; i++) &#123;</span><br><span class="line">    exclusive.<span class="built_in">lock</span>(); <span class="comment">// ①</span></span><br><span class="line">    sum += <span class="built_in">sqrt</span>(i);</span><br><span class="line">    exclusive.<span class="built_in">unlock</span>(); <span class="comment">// ②</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">concurrent_task</span><span class="params">(<span class="keyword">int</span> min, <span class="keyword">int</span> max)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> start_time = chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">unsigned</span> concurrent_count = thread::<span class="built_in">hardware_concurrency</span>();</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;hardware_concurrency: &quot;</span> &lt;&lt; concurrent_count &lt;&lt; endl;</span><br><span class="line">  vector&lt;thread&gt; threads;</span><br><span class="line">  min = <span class="number">0</span>;</span><br><span class="line">  sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t &lt; concurrent_count; t++) &#123;</span><br><span class="line">    <span class="keyword">int</span> range = max / concurrent_count * (t + <span class="number">1</span>);</span><br><span class="line">    threads.<span class="built_in">push_back</span>(<span class="built_in">thread</span>(concurrent_worker, min, range)); <span class="comment">// ③</span></span><br><span class="line">    min = range + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threads.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    threads[i].<span class="built_in">join</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> end_time = chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line">  <span class="keyword">auto</span> ms = chrono::duration_cast&lt;chrono::milliseconds&gt;(end_time - start_time).<span class="built_in">count</span>();</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Concurrent task finish, &quot;</span> &lt;&lt; ms &lt;&lt; <span class="string">&quot; ms consumed, Result: &quot;</span> &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里只有三个地方需要关注：</p>
<ol>
<li>在访问共享数据之前加锁</li>
<li>访问完成之后解锁</li>
<li>在多线程中使用带锁的版本</li>
</ol>
<p>执行之后结果输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hardware_concurrency: 16</span><br><span class="line">Concurrent task finish, 74232 ms consumed, Result: 2.10819e+13</span><br></pre></td></tr></table></figure>

<p>这下结果是对了，但是我们却发现这个版本比原先单线程的版本性能还要差很多。这是为什么？</p>
<p>这是因为加锁和解锁是有代价的，这里计算最耗时的地方在锁里面，每次只能有一个线程串行执行，相比于单线程模型，它不但是串行的，还增加了锁的负担，因此就更慢了。</p>
<p>这就是为什么前面说多线程系统会增加系统的复杂度，而且并非多线程系统一定就有更好的性能。</p>
<p>不过，对于这里的问题是可以改进的。我们仔细思考一下：我们划分给每个线程的数据其实是独立的，对于数据的处理是耗时的，但其实这部分逻辑每个线程可以单独处理，没必要加锁。只有在最后汇总数据的时候进行一次锁保护就可以了。</p>
<p>于是我们改造<code>concurrent_worker</code>，像下面这样：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 08_improved_mutex_lock.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">concurrent_worker</span><span class="params">(<span class="keyword">int</span> min, <span class="keyword">int</span> max)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">double</span> tmp_sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = min; i &lt;= max; i++) &#123;</span><br><span class="line">    tmp_sum += <span class="built_in">sqrt</span>(i); <span class="comment">// ①</span></span><br><span class="line">  &#125;</span><br><span class="line">  exclusive.<span class="built_in">lock</span>(); <span class="comment">// ②</span></span><br><span class="line">  sum += tmp_sum;</span><br><span class="line">  exclusive.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码的改变在于两处：</p>
<ol>
<li>通过一个局部变量保存当前线程的处理结果</li>
<li>在汇总总结过的时候进行锁保护</li>
</ol>
<p>运行一下改进后的程序，其结果输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hardware_concurrency: 16</span><br><span class="line">Concurrent task finish, 451 ms consumed, Result: 2.10819e+13</span><br></pre></td></tr></table></figure>

<p>可以看到，性能一下就提升了好多倍。我们终于体验到多线程带来的好处了。</p>
<p>我们用锁的<strong>粒度</strong>（granularity）来描述锁的范围。<strong>细粒度</strong>（fine-grained）是指锁保护较小的范围，<strong>粗粒度</strong>（coarse-grained）是指锁保护较大的范围。出于性能的考虑，我们应该保证锁的粒度尽可能的细。并且，不应该在获取锁的范围内执行耗时的操作，例如执行IO。如果是耗时的运算，也应该尽可能的移到锁的外面。</p>
<blockquote>
<p>In general, a lock should be held for only the minimum possible time needed to perform the required operations.</p>
<p>–《C++ Concurrency in Action》</p>
</blockquote>
<h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>死锁是并发系统很常见的一类问题。</p>
<p>死锁是指：两个或以上的运算单元，每一方都在等待其他方释放资源，但是所有方都不愿意释放资源。结果是没有任何一方能继续推进下去，于是整个系统无法再继续运转。</p>
<p>死锁在现实中也很常见，例如：两个孩子分别拿着玩具的一半然后哭着要从对方手里得到另外一半玩具，但是谁都不肯让步。</p>
<p>下面我们来看一个编程示例。</p>
<p>现在假设我们在开发一个银行的系统，这个系统包含了转账的功能。</p>
<p>首先我们创建一个<code>Account</code>类来描述银行账号。由于这仅仅是一个演示使用的代码，所以我们希望代码足够的简单。<code>Account</code>类仅仅包含名称和金额两个字段。</p>
<p>另外，为了支持并发，这个类包含了一个<code>mutex</code>对象，用来保护账号金额，在读写账号金额时需要先加锁保护。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 09_deadlock_bank_transfer.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Account</span>(string name, <span class="keyword">double</span> money): <span class="built_in">mName</span>(name), <span class="built_in">mMoney</span>(money) &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">changeMoney</span><span class="params">(<span class="keyword">double</span> amount)</span> </span>&#123;</span><br><span class="line">    mMoney += amount;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">string <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mName;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">double</span> <span class="title">getMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mMoney;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">mutex* <span class="title">getLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;mMoneyLock;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  string mName;</span><br><span class="line">  <span class="keyword">double</span> mMoney;</span><br><span class="line">  mutex mMoneyLock;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>Account</code>类很简单，我想就不用多做说明了。</p>
<p>接下来，我们再创建一个描述银行的<code>Bank</code>类。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 09_deadlock_bank_transfer.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bank</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">addAccount</span><span class="params">(Account* account)</span> </span>&#123;</span><br><span class="line">    mAccounts.<span class="built_in">insert</span>(account);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">transferMoney</span><span class="params">(Account* accountA, Account* accountB, <span class="keyword">double</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="function">lock_guard <span class="title">guardA</span><span class="params">(*accountA-&gt;getLock())</span></span>; <span class="comment">// ①</span></span><br><span class="line">    <span class="function">lock_guard <span class="title">guardB</span><span class="params">(*accountB-&gt;getLock())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (amount &gt; accountA-&gt;<span class="built_in">getMoney</span>()) &#123; <span class="comment">// ②</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    accountA-&gt;<span class="built_in">changeMoney</span>(-amount); <span class="comment">// ③</span></span><br><span class="line">    accountB-&gt;<span class="built_in">changeMoney</span>(amount);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">double</span> <span class="title">totalMoney</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> a : mAccounts) &#123;</span><br><span class="line">      sum += a-&gt;<span class="built_in">getMoney</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  set&lt;Account*&gt; mAccounts;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>银行类中记录了所有的账号，并且提供了一个方法用来查询整个银行的总金额。</p>
<p>这其中，我们最主要要关注转账的实现：<code>transferMoney</code>。该方法的几个关键点如下：</p>
<ol>
<li>为了保证线程安全，在修改每个账号之前，需要获取相应的锁。</li>
<li>判断转出账户金额是否足够，如果不够此次转账失败。</li>
<li>进行转账。</li>
</ol>
<p>有了银行和账户结构之后就可以开发转账系统了，同样的，由于是为了演示所用，我们的转账系统也会尽可能的简单：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 09_deadlock_bank_transfer.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">randomTransfer</span><span class="params">(Bank* bank, Account* accountA, Account* accountB)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">double</span> randomMoney = ((<span class="keyword">double</span>)<span class="built_in">rand</span>() / RAND_MAX) * <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">if</span> (bank-&gt;<span class="built_in">transferMoney</span>(accountA, accountB, randomMoney)) &#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;Transfer &quot;</span> &lt;&lt; randomMoney &lt;&lt; <span class="string">&quot; from &quot;</span> &lt;&lt; accountA-&gt;<span class="built_in">getName</span>()</span><br><span class="line">           &lt;&lt; <span class="string">&quot; to &quot;</span> &lt;&lt; accountB-&gt;<span class="built_in">getName</span>()</span><br><span class="line">           &lt;&lt; <span class="string">&quot;, Bank totalMoney: &quot;</span> &lt;&lt; bank-&gt;<span class="built_in">totalMoney</span>() &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;Transfer failed, &quot;</span></span><br><span class="line">           &lt;&lt; accountA-&gt;<span class="built_in">getName</span>() &lt;&lt; <span class="string">&quot; has only $&quot;</span> &lt;&lt; accountA-&gt;<span class="built_in">getMoney</span>() &lt;&lt; <span class="string">&quot;, but &quot;</span></span><br><span class="line">           &lt;&lt; randomMoney &lt;&lt; <span class="string">&quot; required&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里每次生成一个随机数，然后通过银行进行转账。</p>
<p>最后我们在<code>main</code>函数中创建两个线程，互相在两个账号之间来回转账：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 09_deadlock_bank_transfer.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">Account <span class="title">a</span><span class="params">(<span class="string">&quot;Paul&quot;</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line">  <span class="function">Account <span class="title">b</span><span class="params">(<span class="string">&quot;Moira&quot;</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  Bank aBank;</span><br><span class="line">  aBank.<span class="built_in">addAccount</span>(&amp;a);</span><br><span class="line">  aBank.<span class="built_in">addAccount</span>(&amp;b);</span><br><span class="line"></span><br><span class="line">  <span class="function">thread <span class="title">t1</span><span class="params">(randomTransfer, &amp;aBank, &amp;a, &amp;b)</span></span>;</span><br><span class="line">  <span class="function">thread <span class="title">t2</span><span class="params">(randomTransfer, &amp;aBank, &amp;b, &amp;a)</span></span>;</span><br><span class="line"></span><br><span class="line">  t1.<span class="built_in">join</span>();</span><br><span class="line">  t2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，我们的银行转账系统就开发完成了。然后编译并运行，其结果可能像下面这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">Transfer 13.2901 from Paul to Moira, Bank totalMoney: 20042.6259 from Moira to Paul, Bank totalMoney: 200</span><br><span class="line">Transfer failed, Moira has only $34.7581, but 66.3208 required</span><br><span class="line">Transfer failed, Moira has only $34.7581, but </span><br><span class="line">Transfer 93.191 from 53.9176 required</span><br><span class="line">Transfer 60.6146 from Moira to Paul, Bank totalMoney: 200</span><br><span class="line">Transfer 49.7304 from Moira to Paul, Bank totalMoney: 200Paul to Moira, Bank totalMoney: </span><br><span class="line">Transfer failed, Moira has only $17.6041, but 18.1186 required</span><br><span class="line">Transfer failed, Moira has only $17.6041, but 18.893 required</span><br><span class="line">Transfer failed, Moira has only $17.6041, but 34.7078 required</span><br><span class="line">Transfer failed, Moira has only $17.6041, but 33.9569 required</span><br><span class="line">Transfer 12.7899 from 200</span><br><span class="line">Moira to Paul, Bank totalMoney: 200</span><br><span class="line">Transfer failed, Moira has only $63.9373, but 80.9038 required</span><br><span class="line">Transfer 50.933 from Moira to Paul, Bank totalMoney: 200</span><br><span class="line">Transfer failed, Moira has only $13.0043, but 30.2056 required</span><br><span class="line">Transfer failed, Moira has only $Transfer 59.123 from Paul to Moira, Bank totalMoney: 200</span><br><span class="line">Transfer 29.0486 from Paul to Moira, Bank totalMoney: 20013.0043, but 64.7307 required</span><br></pre></td></tr></table></figure>

<p>如果你运行了这个程序，你会发现很快它就卡住不动了。为什么？</p>
<p>因为发生了死锁。</p>
<p>我们仔细思考一下这两个线程的逻辑：这两个线程可能会同时获取其中一个账号的锁，然后又想获取另外一个账号的锁，此时就发生了死锁。如下图所示：</p>
<p><img src="https://paul-pub.oss-cn-beijing.aliyuncs.com/2019/2019-11-26-cpp-concurrency/deadlock.png" alt="img"></p>
<p>当然，发生死锁的原因远不止上面这一种情况。如果两个线程互相<code>join</code>就可能发生死锁。还有在一个线程中对一个不可重入的互斥体（例如<code>mutex</code>而非<code>recursive_mutex</code>）多次加锁也会死锁。</p>
<p>你可能会觉得，我可不会这么傻，写出这样的代码。但实际上，很多时候是由于代码的深层次嵌套导致了死锁的发生，由于调用关系的复杂导致发现这类问题并不容易。</p>
<p>如果仔细看一下上面的输出，我们会发现还有另外一个问题：这里的输出是乱的。两个线程的输出混杂在一起了。究其原因也很容易理解：两个线程可能会同时输出，没有做好隔离。</p>
<p>下面我们就来逐步解决上面的问题。</p>
<p>对于输出混乱的问题很好解决，专门用一把锁来保护输出逻辑即可：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 10_improved_bank_transfer.cpp</span></span><br><span class="line"></span><br><span class="line">mutex sCoutLock;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">randomTransfer</span><span class="params">(Bank* bank, Account* accountA, Account* accountB)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">double</span> randomMoney = ((<span class="keyword">double</span>)<span class="built_in">rand</span>() / RAND_MAX) * <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">if</span> (bank-&gt;<span class="built_in">transferMoney</span>(accountA, accountB, randomMoney)) &#123;</span><br><span class="line">      sCoutLock.<span class="built_in">lock</span>();</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;Transfer &quot;</span> &lt;&lt; randomMoney &lt;&lt; <span class="string">&quot; from &quot;</span> &lt;&lt; accountA-&gt;<span class="built_in">getName</span>()</span><br><span class="line">          &lt;&lt; <span class="string">&quot; to &quot;</span> &lt;&lt; accountB-&gt;<span class="built_in">getName</span>()</span><br><span class="line">          &lt;&lt; <span class="string">&quot;, Bank totalMoney: &quot;</span> &lt;&lt; bank-&gt;<span class="built_in">totalMoney</span>() &lt;&lt; endl;</span><br><span class="line">      sCoutLock.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      sCoutLock.<span class="built_in">lock</span>();</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;Transfer failed, &quot;</span></span><br><span class="line">           &lt;&lt; accountA-&gt;<span class="built_in">getName</span>() &lt;&lt; <span class="string">&quot; has only &quot;</span> &lt;&lt; accountA-&gt;<span class="built_in">getMoney</span>() &lt;&lt; <span class="string">&quot;, but &quot;</span></span><br><span class="line">           &lt;&lt; randomMoney &lt;&lt; <span class="string">&quot; required&quot;</span> &lt;&lt; endl;</span><br><span class="line">      sCoutLock.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="通用锁定算法"><a href="#通用锁定算法" class="headerlink" title="通用锁定算法"></a>通用锁定算法</h4><ul>
<li>主要API</li>
</ul>
<table>
<thead>
<tr>
<th align="left">API</th>
<th align="left">C++标准</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">lock</td>
<td align="left">C++11</td>
<td align="left">锁定指定的互斥体，若任何一个不可用则阻塞</td>
</tr>
<tr>
<td align="left">try_lock</td>
<td align="left">C++11</td>
<td align="left">试图通过重复调用 try_lock 获得互斥体的所有权</td>
</tr>
</tbody></table>
<p>要避免死锁，需要仔细的思考和设计业务逻辑。</p>
<p>有一个比较简单的原则可以避免死锁，即：对所有的锁进行排序，每次一定要按照顺序来获取锁，不允许乱序。例如：要获取某个玩具，一定要先拿到锁A，再拿到锁B，才能玩玩具。这样就不会死锁了。</p>
<p>这个原则虽然简单，但却不容易遵守。因为数据常常是分散在很多地方的。</p>
<p>不过好消息是，C++ 11标准中为我们提供了一些工具来避免因为多把锁而导致的死锁。我们只要直接调用这些接口就可以了。这个就是上面提到的两个函数。它们都支持传入多个<a href="https://en.cppreference.com/w/cpp/named_req/Lockable">Lockable</a>对象。</p>
<p>接下来我们用它来改造之前死锁的转账系统：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 10_improved_bank_transfer.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">transferMoney</span><span class="params">(Account* accountA, Account* accountB, <span class="keyword">double</span> amount)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">lock</span>(*accountA-&gt;<span class="built_in">getLock</span>(), *accountB-&gt;<span class="built_in">getLock</span>());    <span class="comment">// ①</span></span><br><span class="line">  <span class="function">lock_guard <span class="title">lockA</span><span class="params">(*accountA-&gt;getLock(), adopt_lock)</span></span>;  <span class="comment">// ②</span></span><br><span class="line">  <span class="function">lock_guard <span class="title">lockB</span><span class="params">(*accountB-&gt;getLock(), adopt_lock)</span></span>;  <span class="comment">// ③</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (amount &gt; accountA-&gt;<span class="built_in">getMoney</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  accountA-&gt;<span class="built_in">changeMoney</span>(-amount);</span><br><span class="line">  accountB-&gt;<span class="built_in">changeMoney</span>(amount);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里只改动了3行代码。</p>
<ol>
<li>这里通过<code>lock</code>函数来获取两把锁，标准库的实现会保证不会发生死锁。</li>
<li><code>lock_guard</code>在下面我们还会详细介绍。这里只要知道它会在自身对象生命周期的范围内锁定互斥体即可。创建<code>lock_guard</code>的目的是为了在<code>transferMoney</code>结束的时候释放锁，<code>lockB</code>也是一样。但需要注意的是，这里传递了 <code>adopt_lock</code>表示：现在是已经获取到互斥体了的状态了，不用再次加锁（如果不加<code>adopt_lock</code>就是二次锁定了）。</li>
</ol>
<p>运行一下这个改造后的程序，其输出如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">Transfer failed, Paul has only $1.76243, but 17.5974 required</span><br><span class="line">Transfer failed, Paul has only $1.76243, but 59.2104 required</span><br><span class="line">Transfer failed, Paul has only $1.76243, but 49.6379 required</span><br><span class="line">Transfer failed, Paul has only $1.76243, but 63.6373 required</span><br><span class="line">Transfer failed, Paul has only $1.76243, but 51.8742 required</span><br><span class="line">Transfer failed, Paul has only $1.76243, but 50.0081 required</span><br><span class="line">Transfer failed, Paul has only $1.76243, but 86.1041 required</span><br><span class="line">Transfer failed, Paul has only $1.76243, but 51.3278 required</span><br><span class="line">Transfer failed, Paul has only $1.76243, but 66.5754 required</span><br><span class="line">Transfer failed, Paul has only $1.76243, but 32.1867 required</span><br><span class="line">Transfer failed, Paul has only $1.76243, but 62.0039 required</span><br><span class="line">Transfer failed, Paul has only $1.76243, but 98.7819 required</span><br><span class="line">Transfer failed, Paul has only $1.76243, but 27.046 required</span><br><span class="line">Transfer failed, Paul has only $1.76243, but 62.9155 required</span><br><span class="line">Transfer 98.8478 from Moira to Paul, Bank totalMoney: 200</span><br><span class="line">Transfer 80.0722 from Moira to Paul, Bank totalMoney: 200</span><br><span class="line">Transfer 73.7035 from Moira to Paul, Bank totalMoney: 200</span><br><span class="line">Transfer 34.4476 from Moira to Paul, Bank totalMoney: 200</span><br><span class="line">Transfer failed, Moira has only $10.0142, but 61.3033 required</span><br><span class="line">Transfer failed, Moira has only $10.0142, but 24.5595 required</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>现在这个转账程序会一直运行下去，不会再死锁了。输出也是正常的了。</p>
<h4 id="通用互斥管理"><a href="#通用互斥管理" class="headerlink" title="通用互斥管理"></a>通用互斥管理</h4><ul>
<li>主要API</li>
</ul>
<table>
<thead>
<tr>
<th align="left">API</th>
<th align="left">C++标准</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">lock_guard</td>
<td align="left">C++11</td>
<td align="left">实现严格基于作用域的互斥体所有权包装器</td>
</tr>
<tr>
<td align="left">unique_lock</td>
<td align="left">C++11</td>
<td align="left">实现可移动的互斥体所有权包装器</td>
</tr>
<tr>
<td align="left">shared_lock</td>
<td align="left">C++14</td>
<td align="left">实现可移动的共享互斥体所有权封装器</td>
</tr>
<tr>
<td align="left">scoped_lock</td>
<td align="left">C++17</td>
<td align="left">用于多个互斥体的免死锁 RAII 封装器</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">锁定策略</th>
<th align="left">C++标准</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">defer_lock</td>
<td align="left">C++11</td>
<td align="left">类型为 <code>defer_lock_t</code>，不获得互斥的所有权</td>
</tr>
<tr>
<td align="left">try_to_lock</td>
<td align="left">C++11</td>
<td align="left">类型为<code>try_to_lock_t</code>，尝试获得互斥的所有权而不阻塞</td>
</tr>
<tr>
<td align="left">adopt_lock</td>
<td align="left">C++11</td>
<td align="left">类型为<code>adopt_lock_t</code>，假设调用方已拥有互斥的所有权</td>
</tr>
</tbody></table>
<p>互斥体（<code>mutex</code>相关类）提供了对于资源的保护功能，但是手动的锁定（调用<code>lock</code>或者<code>try_lock</code>）和解锁（调用<code>unlock</code>）互斥体是要耗费比较大的精力的，我们需要精心考虑和设计代码才行。因为我们需要保证，在任何情况下，解锁要和加锁配对，因为假设出现一条路径导致获取锁之后没有正常释放，就会影响整个系统。如果考虑方法还可以会抛出异常，这样的代码写起来会很费劲。</p>
<p>鉴于这个原因，标准库就提供了上面的这些API。它们都使用了叫做RAII的编程技巧，来简化我们手动加锁和解锁的“体力活”。</p>
<p>请看下面的例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// https://en.cppreference.com/w/cpp/thread/lock_guard</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> g_i = <span class="number">0</span>;</span><br><span class="line">std::mutex g_i_mutex;  <span class="comment">// ①</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">safe_increment</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(g_i_mutex)</span></span>;  <span class="comment">// ②</span></span><br><span class="line">  ++g_i;</span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; g_i &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  <span class="comment">// ③</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;main: &quot;</span> &lt;&lt; g_i &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="function">std::thread <span class="title">t1</span><span class="params">(safe_increment)</span></span>; <span class="comment">// ④</span></span><br><span class="line">  <span class="function">std::thread <span class="title">t2</span><span class="params">(safe_increment)</span></span>;</span><br><span class="line"> </span><br><span class="line">  t1.<span class="built_in">join</span>();</span><br><span class="line">  t2.<span class="built_in">join</span>();</span><br><span class="line"> </span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;main: &quot;</span> &lt;&lt; g_i &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码中：</p>
<ol>
<li>全局的互斥体<code>g_i_mutex</code>用来保护全局变量<code>g_i</code></li>
<li>这是一个设计为可以被多线程环境使用的方法。因此需要通过互斥体来进行保护。这里没有调用<code>lock</code>方法，而是直接使用<code>lock_guard</code>来锁定互斥体。</li>
<li>在方法结束的时候，局部变量<code>std::lock_guard&lt;std::mutex&gt; lock</code>会被销毁，它对互斥体的锁定也就解除了。</li>
<li>在多个线程中使用这个方法。</li>
</ol>
<h4 id="RAII"><a href="#RAII" class="headerlink" title="RAII"></a>RAII</h4><p>上面的几个类（<code>lock_guard</code>，<code>unique_lock</code>，<code>shared_lock</code>，<code>scoped_lock</code>）都使用了一个叫做RAII的编程技巧。</p>
<p>RAII全称是Resource Acquisition Is Initialization，直译过来就是：资源获取即初始化。</p>
<p>RAII是一种<a href="http://www.stroustrup.com/bs_faq2.html#finally">C++编程技术</a>，它将必须在使用前请求的资源（例如：分配的堆内存、执行线程、打开的套接字、打开的文件、锁定的互斥体、磁盘空间、数据库连接等——任何存在受限供给中的事物）的生命周期与一个对象的生存周期相绑定。 RAII保证资源可用于任何会访问该对象的函数。它亦保证所有资源在其控制对象的生存期结束时，以获取顺序的逆序释放。类似地，若资源获取失败（构造函数以异常退出），则为已构造完成的对象和基类子对象所获取的所有资源，会以初始化顺序的逆序释放。这有效地利用了语言特性以消除内存泄漏并保证异常安全。</p>
<p>RAII 可总结如下:</p>
<ul>
<li>将每个资源封装入一个类，其中：<ul>
<li>构造函数请求资源，并建立所有类不变式，或在它无法完成时抛出异常，</li>
<li>析构函数释放资源并决不抛出异常；</li>
</ul>
</li>
<li>始终经由 RAII 类的实例使用满足要求的资源，该资源<ul>
<li>自身拥有自动存储期或临时生存期，或</li>
<li>具有与自动或临时对象的生存期绑定的生存期</li>
</ul>
</li>
</ul>
<p>回想一下上文中的<code>transferMoney</code>方法中的三行代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">lock</span>(*accountA-&gt;<span class="built_in">getLock</span>(), *accountB-&gt;<span class="built_in">getLock</span>());</span><br><span class="line"><span class="function">lock_guard <span class="title">lockA</span><span class="params">(*accountA-&gt;getLock(), adopt_lock)</span></span>;</span><br><span class="line"><span class="function">lock_guard <span class="title">lockB</span><span class="params">(*accountB-&gt;getLock(), adopt_lock)</span></span>;</span><br></pre></td></tr></table></figure>

<p>如果使用<code>unique_lock</code>这三行代码还有一种等价的写法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">unique_lock <span class="title">lockA</span><span class="params">(*accountA-&gt;getLock(), defer_lock)</span></span>;</span><br><span class="line"><span class="function">unique_lock <span class="title">lockB</span><span class="params">(*accountB-&gt;getLock(), defer_lock)</span></span>;</span><br><span class="line"><span class="built_in">lock</span>(*accountA-&gt;<span class="built_in">getLock</span>(), *accountB-&gt;<span class="built_in">getLock</span>());</span><br></pre></td></tr></table></figure>

<p>请注意这里<code>lock</code>方法的调用位置。这里先定义<code>unique_lock</code>指定了<code>defer_lock</code>，因此实际没有锁定互斥体，而是到第三行才进行锁定。</p>
<p>最后，借助<code>scoped_lock</code>，我们可以将三行代码合成一行，这种写法也是等价的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">scoped_lock <span class="title">lockAll</span><span class="params">(*accountA-&gt;getLock(), *accountB-&gt;getLock())</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>scoped_lock</code>会在其生命周期范围内锁定互斥体，销毁的时候解锁。同时，它可以锁定多个互斥体，并且避免死锁。</p>
<p>目前，只还有<code>shared_lock</code>我们没有提到。它与其他几个类的区别在于：它是以共享的方式锁定互斥体。</p>
<h4 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h4><table>
<thead>
<tr>
<th align="left">API</th>
<th align="left">C++标准</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">condition_variable</td>
<td align="left">C++ 11</td>
<td align="left">提供与 std::unique_lock 关联的条件变量</td>
</tr>
<tr>
<td align="left">condition_variable_any</td>
<td align="left">C++ 11</td>
<td align="left">提供与任何锁类型关联的条件变量</td>
</tr>
<tr>
<td align="left">notify_all_at_thread_exit</td>
<td align="left">C++ 11</td>
<td align="left">安排到在此线程完全结束时对 notify_all 的调用</td>
</tr>
<tr>
<td align="left">cv_status</td>
<td align="left">C++ 11</td>
<td align="left">列出条件变量上定时等待的可能结果</td>
</tr>
</tbody></table>
<p>至此，我们还有一个地方可以改进。那就是：转账金额不足的时候，程序直接返回了<code>false</code>。这很难说是一个好的策略。因为，即便虽然当前账号金额不足以转账，但只要别的账号又转账进来之后，当前这个转账操作也许就可以继续执行了。</p>
<p>这在很多业务中是很常见的一个需求：每一次操作都要正确执行，如果条件不满足就停下来等待，直到条件满足之后再继续。而不是直接返回。</p>
<p>条件变量提供了一个可以让多个线程间同步协作的功能。这对于<a href="https://en.wikipedia.org/wiki/Producer%E2%80%93consumer_problem">生产者-消费者模型</a>很有意义。在这个模型下：</p>
<ul>
<li>生产者和消费者共享一个工作区。这个区间的大小是有限的。</li>
<li>生产者总是产生数据放入工作区中，当工作区满了。它就停下来等消费者消费一部分数据，然后继续工作。</li>
<li>消费者总是从工作区中拿出数据使用。当工作区中的数据全部被消费空了之后，它也会停下来等待生产者往工作区中放入新的数据。</li>
</ul>
<p>从上面可以看到，无论是生产者还是消费者，当它们工作的条件不满足时，它们并不是直接报错返回，而是停下来等待，直到条件满足。</p>
<p>下面我们就借助于条件变量，再次改造之前的银行转账系统。</p>
<p>这个改造主要在于账号类。我们重点是要调整<code>changeMoney</code>方法。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 11_bank_transfer_wait_notify.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Account</span>(string name, <span class="keyword">double</span> money): <span class="built_in">mName</span>(name), <span class="built_in">mMoney</span>(money) &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">changeMoney</span><span class="params">(<span class="keyword">double</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="function">unique_lock <span class="title">lock</span><span class="params">(mMoneyLock)</span></span>; <span class="comment">// ②</span></span><br><span class="line">    mConditionVar.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>, amount] &#123; <span class="comment">// ③</span></span><br><span class="line">      <span class="keyword">return</span> mMoney + amount &gt; <span class="number">0</span>; <span class="comment">// ④</span></span><br><span class="line">    &#125;);</span><br><span class="line">    mMoney += amount;</span><br><span class="line">    mConditionVar.<span class="built_in">notify_all</span>(); <span class="comment">// ⑤</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">string <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mName;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">double</span> <span class="title">getMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mMoney;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  string mName;</span><br><span class="line">  <span class="keyword">double</span> mMoney;</span><br><span class="line">  mutex mMoneyLock;</span><br><span class="line">  condition_variable mConditionVar; <span class="comment">// ①</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这几处改动说明如下：</p>
<ol>
<li>这里声明了一个条件变量，用来在多个线程之间协作。</li>
<li>这里使用的是<code>unique_lock</code>，这是为了与条件变量相配合。因为条件变量会解锁和重新锁定互斥体。</li>
<li>这里是比较重要的一个地方：通过条件变量进行等待。此时：会通过后面的lambda表达式判断条件是否满足。如果满足则继续；如果不满足，则<strong>此处会解锁互斥体，并让当前线程等待</strong>。<strong>解锁</strong>这一点非常重要，因为只有这样，才能让其他线程获取互斥体。</li>
<li>这里是条件变量等待的条件。如果你不熟悉lambda表达式，请自行网上学习，或者阅读<a href="https://paul.pub/cpp-lambda-function-bind/">我之前写的文章</a>。</li>
<li>此处也很重要。当金额发生变动之后，我们需要通知所有在条件变量上等待的其他线程。此时所有调用<code>wait</code>线程都会再次唤醒，然后尝试获取锁（当然，只有一个能获取到）并再次判断条件是否满足。除了<code>notify_all</code>还有<code>notify_one</code>，它只通知一个等待的线程。<code>wait</code>和<code>notify</code>就构成了线程间互相协作的工具。</li>
</ol>
<p>请注意：<code>wait</code>和<code>notify_all</code>虽然是写在一个函数中的，但是在运行时它们是在多线程环境中执行的，因此对于这段代码，需要能够从不同线程的角度去思考代码的逻辑。这也是开发并发系统比较难的地方。</p>
<p>有了上面的改动之后，银行的转账方法实现起来就很简单了，不用再考虑数据保护的问题了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 11_bank_transfer_wait_notify.cpp</span><br><span class="line"></span><br><span class="line">void Bank::transferMoney(Account* accountA, Account* accountB, double amount) &#123;</span><br><span class="line">    accountA-&gt;changeMoney(-amount);</span><br><span class="line">    accountB-&gt;changeMoney(amount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，转账逻辑也会变得简单，不用再管转账失败的情况发生。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 11_bank_transfer_wait_notify.cpp</span></span><br><span class="line"></span><br><span class="line">mutex sCoutLock;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">randomTransfer</span><span class="params">(Bank* bank, Account* accountA, Account* accountB)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">double</span> randomMoney = ((<span class="keyword">double</span>)<span class="built_in">rand</span>() / RAND_MAX) * <span class="number">100</span>;</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="function">lock_guard <span class="title">guard</span><span class="params">(sCoutLock)</span></span>;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;Try to Transfer &quot;</span> &lt;&lt; randomMoney</span><br><span class="line">           &lt;&lt; <span class="string">&quot; from &quot;</span> &lt;&lt; accountA-&gt;<span class="built_in">getName</span>() &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; accountA-&gt;<span class="built_in">getMoney</span>()</span><br><span class="line">           &lt;&lt; <span class="string">&quot;) to &quot;</span> &lt;&lt; accountB-&gt;<span class="built_in">getName</span>() &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; accountB-&gt;<span class="built_in">getMoney</span>()</span><br><span class="line">           &lt;&lt; <span class="string">&quot;), Bank totalMoney: &quot;</span> &lt;&lt; bank-&gt;<span class="built_in">totalMoney</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    bank-&gt;<span class="built_in">transferMoney</span>(accountA, accountB, randomMoney);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改完之后的程序运行输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">Try to Transfer 13.72 from Moira(10.9287) to Paul(189.071), Bank totalMoney: 200</span><br><span class="line">Try to Transfer 28.6579 from Paul(189.071) to Moira(10.9287), Bank totalMoney: 200</span><br><span class="line">Try to Transfer 91.8049 from Paul(160.413) to Moira(39.5866), Bank totalMoney: 200</span><br><span class="line">Try to Transfer 5.56383 from Paul(82.3285) to Moira(117.672), Bank totalMoney: 200</span><br><span class="line">Try to Transfer 11.3594 from Paul(76.7646) to Moira(123.235), Bank totalMoney: 200</span><br><span class="line">Try to Transfer 16.9557 from Paul(65.4053) to Moira(134.595), Bank totalMoney: 200</span><br><span class="line">Try to Transfer 74.998 from Paul(48.4495) to Moira(151.55), Bank totalMoney: 200</span><br><span class="line">Try to Transfer 65.3005 from Moira(151.55) to Paul(48.4495), Bank totalMoney: 200</span><br><span class="line">Try to Transfer 90.6084 from Moira(86.25) to Paul(113.75), Bank totalMoney: 125.002</span><br><span class="line">Try to Transfer 99.6425 from Moira(70.6395) to Paul(129.36), Bank totalMoney: 200</span><br><span class="line">Try to Transfer 55.2091 from Paul(129.36) to Moira(70.6395), Bank totalMoney: 200</span><br><span class="line">Try to Transfer 92.259 from Paul(74.1513) to Moira(125.849), Bank totalMoney: 200</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>这下比之前都要好了。</p>
<h3 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h3><table>
<thead>
<tr>
<th align="left">API</th>
<th align="left">C++标准</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">async</td>
<td align="left">C++11</td>
<td align="left">异步运行一个函数，并返回保有其结果的<code>std::future</code></td>
</tr>
<tr>
<td align="left">future</td>
<td align="left">C++11</td>
<td align="left">等待被异步设置的值</td>
</tr>
<tr>
<td align="left">packaged_task</td>
<td align="left">C++11</td>
<td align="left">打包一个函数，存储其返回值以进行异步获取</td>
</tr>
<tr>
<td align="left">promise</td>
<td align="left">C++11</td>
<td align="left">存储一个值以进行异步获取</td>
</tr>
<tr>
<td align="left">shared_future</td>
<td align="left">C++11</td>
<td align="left">等待被异步设置的值（可能为其他 future 所引用）</td>
</tr>
</tbody></table>
<p>这一小节中，我们来熟悉更多的可以在并发环境中使用的工具，它们都位于<code>&lt;future&gt;</code>头文件中。</p>
<h4 id="async"><a href="#async" class="headerlink" title="async"></a>async</h4><p>很多语言都提供了异步的机制。异步使得耗时的操作不影响当前主线程的执行流。</p>
<p>在C++11中，<code>async</code>便是完成这样的功能的。下面是一个代码示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 12_async_task.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">10e8</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">worker</span><span class="params">(<span class="keyword">int</span> min, <span class="keyword">int</span> max)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = min; i &lt;= max; i++) &#123;</span><br><span class="line">    sum += <span class="built_in">sqrt</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">auto</span> f1 = <span class="built_in">async</span>(worker, <span class="number">0</span>, MAX);</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Async task triggered&quot;</span> &lt;&lt; endl;</span><br><span class="line">  f1.<span class="built_in">wait</span>();</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Async task finish, result: &quot;</span> &lt;&lt; sum &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这仍然是我们之前熟悉的例子。这里有两个地方需要说明：</p>
<ol>
<li>这里以异步的方式启动了任务。它会返回一个<code>future</code>对象。<code>future</code>用来存储异步任务的执行结果，关于<code>future</code>我们在后面<code>packaged_task</code>的例子中再详细说明。在这个例子中我们仅仅用它来等待任务执行完成。</li>
<li>此处是等待异步任务执行完成。</li>
</ol>
<p>需要注意的是，默认情况下，<code>async</code>是启动一个新的线程，还是以同步的方式（不启动新的线程）运行任务，这一点标准是没有指定的，由具体的编译器决定。如果希望一定要以新的线程来异步执行任务，可以通过<code>launch::async</code>来明确说明。<code>launch</code>中有两个常量：</p>
<ul>
<li><code>async</code>：运行新线程，以异步执行任务。</li>
<li><code>deferred</code>：调用方线程上第一次请求其结果时才执行任务，即惰性求值。</li>
</ul>
<p>除了通过函数来指定异步任务，还可以lambda表达式的方式来指定。如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 12_async_task.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">double</span> result = <span class="number">0</span>;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Async task with lambda triggered, thread: &quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">auto</span> f2 = <span class="built_in">async</span>(launch::async, [&amp;result]() &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Lambda task in thread: &quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= MAX; i++) &#123;</span><br><span class="line">      result += <span class="built_in">sqrt</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  f2.<span class="built_in">wait</span>();</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Async task with lambda finish, result: &quot;</span> &lt;&lt; result &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面这段代码中，我们使用一个lambda表达式来编写异步任务的逻辑，并通过<code>launch::async</code>明确指定要通过独立的线程来执行任务，同时我们打印出了线程的id。</p>
<p>这段代码输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Async task with lambda triggered, thread: 0x11290d5c0</span><br><span class="line">Lambda task in thread: 0x700007aa1000</span><br><span class="line">Async task with lambda finish, result: 2.10819e+13</span><br></pre></td></tr></table></figure>

<p>对于面向对象编程来说，很多时候肯定希望以对象的方法来指定异步任务。下面是一个示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 12_async_task.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Worker</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Worker</span>(<span class="keyword">int</span> min, <span class="keyword">int</span> max): <span class="built_in">mMin</span>(min), <span class="built_in">mMax</span>(max) &#123;&#125; <span class="comment">// ①</span></span><br><span class="line">  <span class="function"><span class="keyword">double</span> <span class="title">work</span><span class="params">()</span> </span>&#123; <span class="comment">// ②</span></span><br><span class="line">    mResult = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = mMin; i &lt;= mMax; i++) &#123;</span><br><span class="line">      mResult += <span class="built_in">sqrt</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mResult;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">double</span> <span class="title">getResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mResult;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> mMin;</span><br><span class="line">  <span class="keyword">int</span> mMax;</span><br><span class="line">  <span class="keyword">double</span> mResult;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">Worker <span class="title">w</span><span class="params">(<span class="number">0</span>, MAX)</span></span>;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Task in class triggered&quot;</span> &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">auto</span> f3 = <span class="built_in">async</span>(&amp;Worker::work, &amp;w); <span class="comment">// ③</span></span><br><span class="line">  f3.<span class="built_in">wait</span>();</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Task in class finish, result: &quot;</span> &lt;&lt; w.<span class="built_in">getResult</span>() &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码有三处需要说明：</p>
<ol>
<li>这里通过一个类来描述任务。这个类是对前面提到的任务的封装。它包含了任务的输入参数，和输出结果。</li>
<li><code>work</code>函数是任务的主体逻辑。</li>
<li>通过<code>async</code>执行任务：这里指定了具体的任务函数以及相应的对象。请注意这里是<code>&amp;w</code>，因此传递的是对象的指针。如果不写<code>&amp;</code>将传入<code>w</code>对象的临时复制。</li>
</ol>
<h4 id="packaged-task"><a href="#packaged-task" class="headerlink" title="packaged_task"></a>packaged_task</h4><p>在一些业务中，我们可能会有很多的任务需要调度。这时我们常常会设计出任务队列和线程池的结构。此时，就可以使用<code>packaged_task</code>来包装任务。</p>
<p><code>packaged_task</code>绑定到一个函数或者可调用对象上。当它被调用时，它就会调用其绑定的函数或者可调用对象。并且，可以通过与之相关联的<code>future</code>来获取任务的结果。调度程序只需要处理<code>packaged_task</code>，而非各个函数。</p>
<p><code>packaged_task</code>对象是一个可调用对象，它可以被封装成一个<code>std::fucntion</code>，或者作为线程函数传递给<code>std::thread</code>，或者直接调用。</p>
<p>下面是一个代码示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 13_packaged_task.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">concurrent_worker</span><span class="params">(<span class="keyword">int</span> min, <span class="keyword">int</span> max)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = min; i &lt;= max; i++) &#123;</span><br><span class="line">    sum += <span class="built_in">sqrt</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">concurrent_task</span><span class="params">(<span class="keyword">int</span> min, <span class="keyword">int</span> max)</span> </span>&#123;</span><br><span class="line">  vector&lt;future&lt;<span class="keyword">double</span>&gt;&gt; results; <span class="comment">// ①</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">unsigned</span> concurrent_count = thread::<span class="built_in">hardware_concurrency</span>();</span><br><span class="line">  min = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; concurrent_count; i++) &#123; <span class="comment">// ②</span></span><br><span class="line">    <span class="function">packaged_task&lt;<span class="title">double</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span>&gt; <span class="title">task</span><span class="params">(concurrent_worker)</span></span>; <span class="comment">// ③</span></span><br><span class="line">    results.<span class="built_in">push_back</span>(task.<span class="built_in">get_future</span>()); <span class="comment">// ④</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> range = max / concurrent_count * (i + <span class="number">1</span>);</span><br><span class="line">    <span class="function">thread <span class="title">t</span><span class="params">(std::move(task), min, range)</span></span>; <span class="comment">// ⑤</span></span><br><span class="line">    t.<span class="built_in">detach</span>();</span><br><span class="line"></span><br><span class="line">    min = range + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;threads create finish&quot;</span> &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; r : results) &#123;</span><br><span class="line">    sum += r.<span class="built_in">get</span>(); <span class="comment">// ⑥</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> start_time = chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">double</span> r = <span class="built_in">concurrent_task</span>(<span class="number">0</span>, MAX);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> end_time = chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line">  <span class="keyword">auto</span> ms = chrono::duration_cast&lt;chrono::milliseconds&gt;(end_time - start_time).<span class="built_in">count</span>();</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Concurrent task finish, &quot;</span> &lt;&lt; ms &lt;&lt; <span class="string">&quot; ms consumed, Result: &quot;</span> &lt;&lt; r &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这段代码中：</p>
<ol>
<li>首先创建一个集合来存储<code>future</code>对象。我们将用它来获取任务的结果。</li>
<li>同样的，根据CPU的情况来创建线程的数量。</li>
<li>将任务包装成<code>packaged_task</code>。请注意，由于<code>concurrent_worker</code>被包装成了任务，我们无法直接获取它的<code>return</code>值。而是要通过<code>future</code>对象来获取。</li>
<li>获取任务关联的<code>future</code>对象，并将其存入集合中。</li>
<li>通过一个新的线程来执行任务，并传入需要的参数。</li>
<li>通过<code>future</code>集合，逐个获取每个任务的计算结果，将其累加。这里<code>r.get()</code>获取到的就是每个任务中<code>concurrent_worker</code>的返回值。</li>
</ol>
<p>为了简单起见，这里的示例只使用了我们熟悉的例子和结构。但在实际上的工程中，调用关系通常更复杂，你可以借助于<code>packaged_task</code>将任务组装成队列，然后通过<a href="https://en.wikipedia.org/wiki/Thread_pool">线程池</a>的方式进行调度：</p>
<p><img src="https://paul-pub.oss-cn-beijing.aliyuncs.com/2019/2019-11-26-cpp-concurrency/Thread_pool.svg" alt="img"></p>
<h4 id="promise与future"><a href="#promise与future" class="headerlink" title="promise与future"></a>promise与future</h4><p>在上面的例子中，<code>concurrent_task</code>的结果是通过<code>return</code>返回的。但在一些时候，我们可能不能这么做：在得到任务结果之后，可能还有一些事情需要继续处理，例如清理工作。</p>
<p>这个时候，就可以将<code>promise</code>与<code>future</code>配对使用。这样就可以将返回结果和任务结束两个事情分开。</p>
<p>下面是对上面代码示例的改写：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 14_promise_future.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">concurrent_worker</span><span class="params">(<span class="keyword">int</span> min, <span class="keyword">int</span> max)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = min; i &lt;= max; i++) &#123;</span><br><span class="line">    sum += <span class="built_in">sqrt</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">concurrent_task</span><span class="params">(<span class="keyword">int</span> min, <span class="keyword">int</span> max, promise&lt;<span class="keyword">double</span>&gt;* result)</span> </span>&#123; <span class="comment">// ①</span></span><br><span class="line">  vector&lt;future&lt;<span class="keyword">double</span>&gt;&gt; results;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">unsigned</span> concurrent_count = thread::<span class="built_in">hardware_concurrency</span>();</span><br><span class="line">  min = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; concurrent_count; i++) &#123;</span><br><span class="line">    <span class="function">packaged_task&lt;<span class="title">double</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span>&gt; <span class="title">task</span><span class="params">(concurrent_worker)</span></span>;</span><br><span class="line">    results.<span class="built_in">push_back</span>(task.<span class="built_in">get_future</span>()); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> range = max / concurrent_count * (i + <span class="number">1</span>);</span><br><span class="line">    <span class="function">thread <span class="title">t</span><span class="params">(std::move(task), min, range)</span></span>;</span><br><span class="line">    t.<span class="built_in">detach</span>();</span><br><span class="line"></span><br><span class="line">    min = range + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;threads create finish&quot;</span> &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; r : results) &#123;</span><br><span class="line">    sum += r.<span class="built_in">get</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  result-&gt;<span class="built_in">set_value</span>(sum); <span class="comment">// ②</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;concurrent_task finish&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> start_time = chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">  promise&lt;<span class="keyword">double</span>&gt; sum; <span class="comment">// ③</span></span><br><span class="line">  <span class="built_in">concurrent_task</span>(<span class="number">0</span>, MAX, &amp;sum);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> end_time = chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line">  <span class="keyword">auto</span> ms = chrono::duration_cast&lt;chrono::milliseconds&gt;(end_time - start_time).<span class="built_in">count</span>();</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Concurrent task finish, &quot;</span> &lt;&lt; ms &lt;&lt; <span class="string">&quot; ms consumed.&quot;</span> &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Result: &quot;</span> &lt;&lt; sum.<span class="built_in">get_future</span>().<span class="built_in">get</span>() &lt;&lt; endl; <span class="comment">// ④</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码和上面的示例在很大程度上是一样的。只有小部分内容做了改动：</p>
<ol>
<li><code>concurrent_task</code>不再直接返回计算结果，而是增加了一个<code>promise</code>对象来存放结果。</li>
<li>在任务计算完成之后，将总结过设置到<code>promise</code>对象上。一旦这里调用了<code>set_value</code>，其相关联的<code>future</code>对象就会就绪。</li>
<li>这里是在<code>main</code>中创建一个<code>promoise</code>来存放结果，并以指针的形式传递进<code>concurrent_task</code>中。</li>
<li>通过<code>sum.get_future().get()</code>来获取结果。第2点中已经说了：一旦调用了<code>set_value</code>，其相关联的<code>future</code>对象就会就绪。</li>
</ol>
<p>需要注意的是，<code>future</code>对象只有被一个线程获取值。并且在调用<code>get()</code>之后，就没有可以获取的值了。如果从多个线程调用<code>get()</code>会出现数据竞争，其结果是未定义的。</p>
<p>如果真的需要在多个线程中获取<code>future</code>的结果，可以使用<code>shared_future</code>。</p>
<h3 id="task-based并发：async-packaged-task-promise"><a href="#task-based并发：async-packaged-task-promise" class="headerlink" title="task based并发：async, packaged_task, promise"></a>task based并发：async, packaged_task, promise</h3><h4 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL; DR"></a>TL; DR</h4><ul>
<li><strong>async</strong>：提供最高层次的抽象。如果你不需要控制线程的运行时机，就选这个。</li>
<li><strong>packaged_task</strong>：抽象层次比<code>async</code>低。如果你需要控制线程的运行时机，且线程执行的结果即目标结果时，选这个。</li>
<li><strong>promise</strong>：抽象层次最低。当你想在线程中设置目标结果的值，选这个。</li>
</ul>
<h4 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h4><p><code>async</code>、<code>packaged_task</code>和<code>promise</code>三者有一个共同点：它们都可以返回一个<code>future</code>对象，用户可以通过这个<code>future</code>的<code>get</code>方法获取最终的结果。</p>
<p>在下面的代码中，分别用这三者实现同样的功能：延时2秒后返回0：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::packaged_task&lt;<span class="title">int</span><span class="params">()</span>&gt; <span class="title">task</span><span class="params">([]()&#123; </span></span></span><br><span class="line"><span class="params"><span class="function">            std::chrono::milliseconds dura( <span class="number">2000</span>  );</span></span></span><br><span class="line"><span class="params"><span class="function">            std::this_thread::sleep_for( dura  );</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">return</span> <span class="number">0</span>; </span></span></span><br><span class="line"><span class="params"><span class="function">            &#125;)</span></span>;</span><br><span class="line">    std::future&lt;<span class="keyword">int</span>&gt; f1 = task.<span class="built_in">get_future</span>();</span><br><span class="line">    std::<span class="built_in">thread</span>(std::<span class="built_in">move</span>(task)).<span class="built_in">detach</span>();</span><br><span class="line"></span><br><span class="line">    std::future&lt;<span class="keyword">int</span>&gt; f2 = std::<span class="built_in">async</span>(std::launch::async, []()&#123; </span><br><span class="line">            std::chrono::milliseconds <span class="built_in">dura</span>( <span class="number">2000</span>  );</span><br><span class="line">            std::this_thread::<span class="built_in">sleep_for</span>( dura  );</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">    std::promise&lt;<span class="keyword">int</span>&gt; p;</span><br><span class="line">    std::future&lt;<span class="keyword">int</span>&gt; f3 = p.<span class="built_in">get_future</span>();</span><br><span class="line">    std::<span class="built_in">thread</span>([](std::promise&lt;<span class="keyword">int</span>&gt; p)&#123; </span><br><span class="line">            std::chrono::milliseconds <span class="built_in">dura</span>( <span class="number">2000</span>  );</span><br><span class="line">            std::this_thread::<span class="built_in">sleep_for</span>( dura  );</span><br><span class="line">            p.<span class="built_in">set_value</span>(<span class="number">0</span>); </span><br><span class="line">            &#125;,</span><br><span class="line">            std::<span class="built_in">move</span>(p)).<span class="built_in">detach</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Waiting...&quot;</span> &lt;&lt; std::flush;</span><br><span class="line">    f1.<span class="built_in">wait</span>();</span><br><span class="line">    f2.<span class="built_in">wait</span>();</span><br><span class="line">    f3.<span class="built_in">wait</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Done!\nResults are: &quot;</span></span><br><span class="line">        &lt;&lt; f1.<span class="built_in">get</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; f2.<span class="built_in">get</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; f3.<span class="built_in">get</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面这段代码可以看到，这三者分别工作在不同的抽象层次上。</p>
<ol>
<li><code>async</code>层次最高，你只需要给它提供一个函数，它就会返回一个<code>future</code>对象。接下来就只需等待结果了。</li>
<li><code>packaged_task</code>次之，你在创建了<code>packaged_task</code>后，还要创建一个<code>thread</code>，并把<code>packaged_task</code>交给它执行。</li>
<li><code>promise</code>就最低了。在创建了<code>thread</code>之后，你还要把对应的<code>promise</code>作为参数传入。这还没完，别忘了在函数中<strong>手动</strong>设置<code>promise</code>的值。</li>
</ol>
<p>那么我们的第一个结论就很清晰了：<code>async</code>抽象层次最高，所以除非你需要对并发过程进行细粒度的控制（比如在一些场合下），优先使用<code>async</code>来执行异步任务。</p>
<p>那么什么属于是“一些场合”呢？</p>
<h4 id="async-VS-packaged-task-and-promise"><a href="#async-VS-packaged-task-and-promise" class="headerlink" title="async VS. packaged_task and promise"></a>async VS. packaged_task and promise</h4><p>前面已经看到，<code>async</code>会接收一个函数，并返回一个<code>future</code>。在默认情况下，该函数会被就地执行。这也许不是你想要的。通过传递<code>std::launch::defer</code>，可以修改为直到调用<code>future.get</code>才开始执行<code>async</code>中的函数。</p>
<p>即使这样，如果你想把执行函数的时机和获取future对象的时机分离，最好还是放弃用<code>async</code>，而是使用更为底层的<code>packaged_task</code>和<code>promise</code>。</p>
<p>BTW，<code>async</code>有一个古怪的特性，如果你把<code>async</code>返回的<code>future</code>赋值给一个临时变量（或者没管它的返回值），当该变量生命周期结束时，程序会一直阻塞直到<code>async</code>中的函数执行完毕。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    std::future&lt;<span class="keyword">int</span>&gt; tmp = std::<span class="built_in">async</span>(std::launch::async, []()&#123; </span><br><span class="line">            std::chrono::milliseconds <span class="built_in">dura</span>(VERY_LONG_TIME);</span><br><span class="line">            std::this_thread::<span class="built_in">sleep_for</span>(dura);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// block here for VERY_LONG_TIME</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种意料之外的行为会在C++14中被取消掉。所以你用的编译器可能不会遇到这问题。</p>
<h4 id="packaged-task-VS-promise"><a href="#packaged-task-VS-promise" class="headerlink" title="packaged_task VS. promise"></a>packaged_task VS. promise</h4><p>剩下的两个之中怎么选呢？</p>
<p><code>promise</code>的层次比<code>packaged_task</code>低，所以<code>promise</code>提供给用户的控制粒度也比<code>packaged_task</code>要细。因此，如果你想要更彻底的控制，就选择<code>promise</code>吧。</p>
<p><code>promise</code>几乎就是<code>future</code>的另一半。对<code>promise</code>调用<code>set_value</code>，就如同对<code>future</code>调用<code>set_value</code>。比起<code>packaged_task</code>，<code>promise</code>并不在意函数的返回值——毕竟它的值需要手动调用<code>set_value</code>进行设置。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>C++11</tag>
        <tag>C++14</tag>
        <tag>C++17</tag>
        <tag>C++并发</tag>
        <tag>学习心得</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL on Qt (3):SQL的MVC结构基础知识总结</title>
    <url>/2020/07/24/mysqlonqt3/</url>
    <content><![CDATA[<h1 id="MySQL-on-Qt-3-SQL的MVC结构基础知识总结"><a href="#MySQL-on-Qt-3-SQL的MVC结构基础知识总结" class="headerlink" title="MySQL on Qt (3): SQL的MVC结构基础知识总结"></a>MySQL on Qt (3): SQL的MVC结构基础知识总结</h1><blockquote>
<p> 写在前面： </p>
<p>大一下学期的 CPP 大作业“自主订餐系统”可真是颇费了一些力气，每天晚睡早起撸代码，课都没听，很多知识都是现学现用。</p>
<p>为了避免当时学到的东西给全部忘光光（`_&gt;`，我这脑子啊。。。），所以我把当时大作业的一些核心部分（一些零碎的小细节，能记就记）给记录一下，一方面是复习，一方面也方便以后用到的时候查阅。</p>
</blockquote>
<p>这篇文章是大作业 MySQL + SQLite 操作相关部分的第三章，主要讲一下 Qt 中 SQL 的 MVC 结构的基础知识，包括一部分的 MVC 原理介绍和基础使用。</p>
<span id="more"></span>

<h2 id="什么是-MVC-结构"><a href="#什么是-MVC-结构" class="headerlink" title="什么是 MVC 结构"></a>什么是 MVC 结构</h2><p>关于 MVC 结构的具体介绍，可以看一个名为《Qt中文文档》的 Github 项目中 Qt 关于 MVC 的官方文档的中文翻译版（这里打个广告=。=）：</p>
<blockquote>
<p>模型/视图 编程</p>
<p><a href="https://www.cryfeifei.cn/2020/08/08/qt-zhong-wen-wen-dang-mo-xing-shi-tu-jian-jie/">https://www.cryfeifei.cn/2020/08/08/qt-zhong-wen-wen-dang-mo-xing-shi-tu-jian-jie/</a></p>
</blockquote>
<p>也可以看上一篇我转载自网络的文章：</p>
<blockquote>
<p>Qt Model/View（模型/视图）结构（无师自通）</p>
<p><a href="http://www.skykeyjoker.com/2020/07/23/model-view/">http://www.skykeyjoker.com/2020/07/23/model-view/</a></p>
</blockquote>
<p>以上两篇网络文章我都转载到了我的博客中。</p>
<p>这里我就不再讲太多太细的知识和原理，只是简单概括一下。</p>
<p>GUI 应用程序的一个很重要的功能是由用户在界面上编辑和修改数据，典型的如数据库应用程序。数据库应用程序中，用户在界面上执行各种操作，实际上是修改了界面组件所关联的数据库内的数据。</p>
<p>Model/View（模型/视图）结构是 Qt 中用界面组件显示与编辑数据的一种结构，视图（View）是显示和编辑数据的界面组件，模型（Model）是视图与原始数据之间的接口。</p>
<p>将界面组件与所编辑的数据分离开来，又通过数据源的方式连接起来，是处理界面与数据的一种较好的方式。Qt 使用 Model/View 结构来处理这种关系，Model/View 的基本结构如图 1 所示。</p>
<p><a href="http://c.biancheng.net/uploads/allimg/190103/2-1Z10316062G22.gif"><img src="http://c.biancheng.net/uploads/allimg/190103/2-1Z10316062G22.gif" alt="Model/View基本结构"></a></p>
<p>其中各部分的功能如下：</p>
<ul>
<li>数据（Data）是实际的数据，如数据库的一个数据表或SQL查询结果，内存中的一个 StringList，或磁盘文件结构等。</li>
<li>视图或视图组件（View）是屏幕上的界面组件，视图从数据模型获得每个数据项的模型索引（model index），通过模型索引获取数据，然后为界面组件提供显示数据。Qt 提供一些现成的数据视图组件，如 QListView、QTreeView 和 QTableView 等。</li>
<li>模型或数据模型（Model）与实际数据通信，并为视图组件提供数据接口。它从原始数据提取需要的内容，用于视图组件进行显示和编辑。Qt 中有一些预定义的数据模型，如 QStringListModel 可作为 StringList 的数据模型，QSqlTableModel 可以作为数据库中一个数据表的数据模型。</li>
</ul>
<h2 id="开启-MVC-之旅"><a href="#开启-MVC-之旅" class="headerlink" title="开启 MVC 之旅"></a>开启 MVC 之旅</h2><p>讲完又臭又长的理论，我们就要进入令人激动的实践啦。</p>
<p>外甥打灯笼，这次我也是写了一个 Demo 来演示具体的应用。</p>
<p><img src="https://gitee.com/skykeyjoker/PicCloud/raw/master/img/QQ%E5%9B%BE%E7%89%8720200724132133.png" alt="demo"></p>
<p>与以往不同，这次会先把全部工程代码贴出来再分块讲。</p>
<p><code>sqlmvcdemo.h</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SQLMVCDEMO_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SQLMVCDEMO_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QHBoxLayout&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QVBoxLayout&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QPushButton&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QLineEdit&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QLabel&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QTableView&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QHeaderView&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QSqlTableModel&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QSqlDatabase&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QSqlError&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QSqlRecord&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">QT_BEGIN_NAMESPACE</span><br><span class="line"><span class="keyword">namespace</span> Ui &#123; <span class="class"><span class="keyword">class</span> <span class="title">SQLMVCDemo</span>;</span> &#125;</span><br><span class="line">QT_END_NAMESPACE</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SQLMVCDemo</span> :</span> <span class="keyword">public</span> QWidget</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SQLMVCDemo</span>(QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line">    ~<span class="built_in">SQLMVCDemo</span>();</span><br><span class="line"></span><br><span class="line">    QVBoxLayout *mainLay;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Sql model/view</span></span><br><span class="line">    QSqlTableModel *_tableModel;</span><br><span class="line">    QTableView *_tableView;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">connectToDb</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::SQLMVCDemo *ui;</span><br><span class="line"></span><br><span class="line">    QSqlDatabase _db = QSqlDatabase::<span class="built_in">addDatabase</span>(<span class="string">&quot;QMYSQL&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// SQLMVCDEMO_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<p><code>sqlmvcdemo.cpp</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;sqlmvcdemo.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ui_sqlmvcdemo.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">SQLMVCDemo::<span class="built_in">SQLMVCDemo</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QWidget</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::SQLMVCDemo)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Instance</span></span><br><span class="line">    mainLay = <span class="keyword">new</span> <span class="built_in">QVBoxLayout</span>(<span class="keyword">this</span>);</span><br><span class="line">    _tableView = <span class="keyword">new</span> QTableView;</span><br><span class="line">    _tableModel = <span class="keyword">new</span> <span class="built_in">QSqlTableModel</span>(<span class="literal">nullptr</span>,_db); <span class="comment">// Construct from allocated Database</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// UI</span></span><br><span class="line">    mainLay-&gt;<span class="built_in">addWidget</span>(_tableView);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Connect to Db</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">connectToDb</span>())</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;Connected sucessfully.&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        QSqlError error = _db.<span class="built_in">lastError</span>();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;Connected failed.&quot;</span>;</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;error.<span class="built_in">text</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Model</span></span><br><span class="line">    _tableModel-&gt;<span class="built_in">setTable</span>(<span class="string">&quot;user&quot;</span>); <span class="comment">// Set table</span></span><br><span class="line">    _tableModel-&gt;<span class="built_in">select</span>();  <span class="comment">// Must ** SELECT ** first!</span></span><br><span class="line">    <span class="comment">//_tableModel-&gt;setEditStrategy(QSqlTableModel::OnManualSubmit);  // Manual submit</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//View</span></span><br><span class="line">    _tableView-&gt;<span class="built_in">setModel</span>(_tableModel);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Init Hearders</span></span><br><span class="line"><span class="comment">    _tableView-&gt;setColumnCount(5);</span></span><br><span class="line"><span class="comment">    _tableView-&gt;setHorizontalHeader(QStringList()&lt;&lt;&quot;ID&quot;&lt;&lt;&quot;Name&quot;);</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set width of cols</span></span><br><span class="line">    _tableView-&gt;<span class="built_in">setColumnWidth</span>(<span class="number">0</span>,<span class="number">100</span>);</span><br><span class="line">    _tableView-&gt;<span class="built_in">setColumnWidth</span>(<span class="number">1</span>,<span class="number">180</span>);</span><br><span class="line">    _tableView-&gt;<span class="built_in">setColumnWidth</span>(<span class="number">2</span>,<span class="number">100</span>);</span><br><span class="line">    _tableView-&gt;<span class="built_in">setColumnWidth</span>(<span class="number">3</span>,<span class="number">220</span>);</span><br><span class="line">    _tableView-&gt;<span class="built_in">setColumnWidth</span>(<span class="number">4</span>,<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Resize with stretch</span></span><br><span class="line">    _tableView-&gt;<span class="built_in">horizontalHeader</span>()-&gt;<span class="built_in">setSectionResizeMode</span>(<span class="number">3</span>,QHeaderView::Stretch);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Color varies in rows</span></span><br><span class="line">    _tableView-&gt;<span class="built_in">setAlternatingRowColors</span>(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Some propertis of view</span></span><br><span class="line"><span class="comment">    _tableView-&gt;setSelectionBehavior(QAbstractItemView::SelectRows);  // SelectRows</span></span><br><span class="line"><span class="comment">    _tableView-&gt;setSelectionMode(QAbstractItemView::SingleSelection); // SingleSelection</span></span><br><span class="line"><span class="comment">    _tableView-&gt;setEditTriggers(QAbstractItemView::NoEditTriggers);  // NoEditTriggers</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SQLMVCDemo::~<span class="built_in">SQLMVCDemo</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SQLMVCDemo::connectToDb</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    _db.<span class="built_in">setHostName</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    _db.<span class="built_in">setPort</span>(<span class="number">3306</span>);</span><br><span class="line">    _db.<span class="built_in">setDatabaseName</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    _db.<span class="built_in">setUserName</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    _db.<span class="built_in">setPassword</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> ret = _db.<span class="built_in">open</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Model-View-相关的类"><a href="#Model-View-相关的类" class="headerlink" title="Model/View 相关的类"></a>Model/View 相关的类</h3><p>demo 头文件<code>sqlmvcdemo.h</code>比较重要的部分是头文件<code>include</code>部分，这涉及了 Qt 中 MVC 相关的类。</p>
<p>Qt 中 MVC 结构相关类列表如下：</p>
<p><img src="http://c.biancheng.net/uploads/allimg/190103/2-1Z103160KBJ.gif" alt="Qt中模型类的层次结构"></p>
<p><img src="http://c.biancheng.net/uploads/allimg/190103/2-1Z103160934132.gif" alt="视图相关类的层次结构图"></p>
<p>从图里列出的类名基本上就能推测出我们要用到哪些类：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QTableView&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QHeaderView&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QSqlTableModel&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>其中 <code>QHeaderView</code> 类比较特殊，看起来与我们要使用的 SQL 毫不相关对不对。但其实它作用很大，到后面用到的时候再来说一说。</p>
<hr>
<h3 id="SQL-Model-View-绑定"><a href="#SQL-Model-View-绑定" class="headerlink" title="SQL Model/View 绑定"></a>SQL Model/View 绑定</h3><p>正如前面所说，Model 作为数据模型为操作数据提供了相关接口，因而在使相关 Model 时我们要绑定到具体的数据上。在我们这次使用的 SQL MVC 模型中，就是要把 <code>QSqlTableModel</code> 与 <code>QSqlDatabase</code> 对象绑定。所以便有了如下实例化代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">_tableModel = <span class="keyword">new</span> <span class="built_in">QSqlTableModel</span>(<span class="literal">nullptr</span>,_db); <span class="comment">// Construct from allocated Database</span></span><br></pre></td></tr></table></figure>

<p>这样待绑定的数据库连接后，<code>QSqlTableModel</code>对象就可以对数据库进行相关操作了。</p>
<p>这里要注意一下<code>QSqlTableModel</code>模型指定一个表后，还要执行一下<code>QSqlTableModel::select()</code>函数才能选中表中的数据。 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Model</span></span><br><span class="line">_tableModel-&gt;<span class="built_in">setTable</span>(<span class="string">&quot;user&quot;</span>); <span class="comment">// Set table</span></span><br><span class="line">_tableModel-&gt;<span class="built_in">select</span>();  <span class="comment">// Must ** SELECT ** first!</span></span><br></pre></td></tr></table></figure>

<p>关于数据模型我们还要考虑一个小细节：<strong>用户提交策略</strong></p>
<p>一般情况下，用户完成数据编辑后，会有两种提交策略：</p>
<ul>
<li>自动提交（默认），即编辑完数据（ dataChanged() ）后，数据模型自动提交。</li>
<li>手动提交，即编辑完数据后，需手动调用提交函数方能提交用户数据修改。</li>
</ul>
<p>若要设置为手动模式，我们需要对 Model 进行如下设置：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">_tableModel-&gt;<span class="built_in">setEditStrategy</span>(QSqlTableModel::OnManualSubmit); <span class="comment">// Manual submit</span></span><br></pre></td></tr></table></figure>

<p>并在相应位置手动调用该函数提交：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">_tableModel-&gt;<span class="built_in">submitAll</span>()</span><br></pre></td></tr></table></figure>

<hr>
<p>前面也说过，View 是视图结构，与数据模型绑定，为用户操作提供相应的接口，并将用户操作具体应用到数据模型，数据模型再将操作实际应用到数据中。在我们这次使用的 SQL MVC 模型中，就是要把 <code>QTableView</code> 与 <code>QSqlTableModel</code>绑定。所以便有以下代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">_tableView-&gt;<span class="built_in">setModel</span>(_tableModel);</span><br></pre></td></tr></table></figure>

<p>对 View 控件的设置，主要包括以下方面：</p>
<ul>
<li>表头设置</li>
<li>编辑策略</li>
<li>代理</li>
</ul>
<h4 id="View-表头设置"><a href="#View-表头设置" class="headerlink" title="View 表头设置"></a>View 表头设置</h4><p>先来讲一下 View 控件表头的设置。</p>
<p>还记得前面提到的<code>QHeaderView</code>类嘛？这里对表头的各种设置，就必须引用该类。</p>
<p>首先是设置表头，这里以水平表头为例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Init Hearders</span></span><br><span class="line">_tableView-&gt;<span class="built_in">setColumnCount</span>(<span class="number">5</span>);</span><br><span class="line">_tableView-&gt;<span class="built_in">setHorizontalHeader</span>(<span class="built_in">QStringList</span>()&lt;&lt;<span class="string">&quot;ID&quot;</span>&lt;&lt;<span class="string">&quot;Name&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>然后我们肯定会遇到要设置某一列宽度的情况：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Set width of cols</span></span><br><span class="line">_tableView-&gt;<span class="built_in">setColumnWidth</span>(<span class="number">0</span>,<span class="number">100</span>);</span><br><span class="line">_tableView-&gt;<span class="built_in">setColumnWidth</span>(<span class="number">1</span>,<span class="number">180</span>);</span><br><span class="line">_tableView-&gt;<span class="built_in">setColumnWidth</span>(<span class="number">2</span>,<span class="number">100</span>);</span><br><span class="line">_tableView-&gt;<span class="built_in">setColumnWidth</span>(<span class="number">3</span>,<span class="number">220</span>);</span><br><span class="line">_tableView-&gt;<span class="built_in">setColumnWidth</span>(<span class="number">4</span>,<span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<p>当然，我们还能设置某一列的宽度随着界面缩放比例而改变（建议开启该选项，这样才能让表格占满 View 控件，美观度++）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Resize with stretch</span></span><br><span class="line">_tableView-&gt;<span class="built_in">horizontalHeader</span>()-&gt;<span class="built_in">setSectionResizeMode</span>(<span class="number">3</span>,QHeaderView::Stretch);</span><br></pre></td></tr></table></figure>

<p>再来设置一下让数据按行交替现实不同的颜色：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Color varies in rows</span></span><br><span class="line">_tableView-&gt;<span class="built_in">setAlternatingRowColors</span>(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="编辑策略"><a href="#编辑策略" class="headerlink" title="编辑策略"></a>编辑策略</h4><p>按行选中而不是按单元格选中：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">_tableView-&gt;<span class="built_in">setSelectionBehavior</span>(QAbstractItemView::SelectRows);  <span class="comment">// SelectRows</span></span><br></pre></td></tr></table></figure>

<p>单选：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">_tableView-&gt;<span class="built_in">setSelectionMode</span>(QAbstractItemView::SingleSelection); <span class="comment">// SingleSelection</span></span><br></pre></td></tr></table></figure>

<p>只读：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">_tableView-&gt;<span class="built_in">setEditTriggers</span>(QAbstractItemView::NoEditTriggers);  <span class="comment">// NoEditTriggers</span></span><br></pre></td></tr></table></figure>

<h4 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h4><p>例如本 Demo 中的 Gender 项，我想编辑的时候出现一个“男生|女生”的下拉框而不是仅仅出现一个0或1的编辑框，这个时候我们就需要使用代理。</p>
<p>代理这里先卖一个关子。</p>
<p>好吧其实不是卖关子，而是太长了实在是不想在这一章讲了。。。</p>
<p>代理是一个很庞大的部分，我打算在下一章讲一些皮毛的东西。</p>
<hr>
<p>到这里本章的内容基本上就结束了，下一章我会讲一下代理最为皮毛的一些原理和应用。</p>
<blockquote>
<p>Qt Model/View（模型/视图）结构（无师自通）</p>
<p><a href="http://www.skykeyjoker.com/2020/07/23/model-view/">http://www.skykeyjoker.com/2020/07/23/model-view/</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>Qt</tag>
        <tag>Model/View</tag>
        <tag>Sql</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt Model/View（模型/视图）结构（无师自通）</title>
    <url>/2020/07/23/model-view/</url>
    <content><![CDATA[<h1 id="Qt-Model-View（模型-视图）结构（无师自通）"><a href="#Qt-Model-View（模型-视图）结构（无师自通）" class="headerlink" title="Qt Model/View（模型/视图）结构（无师自通）"></a>Qt Model/View（模型/视图）结构（无师自通）</h1><blockquote>
<p>本文转载自：</p>
<p><a href="http://c.biancheng.net/view/1864.html">http://c.biancheng.net/view/1864.html</a></p>
</blockquote>
<p>Model/View（模型/视图）结构是 <a href="http://c.biancheng.net/qt/">Qt</a> 中用界面组件显示与编辑数据的一种结构，视图（View）是显示和编辑数据的界面组件，模型（Model）是视图与原始数据之间的接口。</p>
<p>GUI 应用程序的一个很重要的功能是由用户在界面上编辑和修改数据，典型的如数据库应用程序。数据库应用程序中，用户在界面上执行各种操作，实际上是修改了界面组件所关联的数据库内的数据。</p>
<p>将界面组件与所编辑的数据分离开来，又通过数据源的方式连接起来，是处理界面与数据的一种较好的方式。Qt 使用 Model/View 结构来处理这种关系，Model/View 的基本结构如图 1 所示。</p>
<p><img src="http://c.biancheng.net/uploads/allimg/190103/2-1Z10316062G22.gif" alt="Model/View基本结构"></p>
<span id="more"></span>

<p>其中各部分的功能如下：</p>
<ul>
<li>数据（Data）是实际的数据，如数据库的一个数据表或SQL查询结果，内存中的一个 StringList，或磁盘文件结构等。</li>
<li>视图或视图组件（View）是屏幕上的界面组件，视图从数据模型获得每个数据项的模型索引（model index），通过模型索引获取数据，然后为界面组件提供显示数据。Qt 提供一些现成的数据视图组件，如 QListView、QTreeView 和 QTableView 等。</li>
<li>模型或数据模型（Model）与实际数据通信，并为视图组件提供数据接口。它从原始数据提取需要的内容，用于视图组件进行显示和编辑。Qt 中有一些预定义的数据模型，如 QStringListModel 可作为 StringList 的数据模型，QSqlTableModel 可以作为数据库中一个数据表的数据模型。</li>
</ul>
<p>由于数据源与显示界面通过 Model/View 结构分离开来，因此可以将一个数据模型在不同的视图中显示，也可以在不修改数据模型的情况下，设计特殊的视图组件。</p>
<p>在 Model/View 结构中，还提供了代理（Delegate）功能，代理功能可以让用户定制数据的界面显示和编辑方式。在标准的视图组件中，代理功能显示一个数据，当数据被编辑时，代理通过模型索引与数据模型通信，并为编辑数据提供一个编辑器，一般是一个 QLineEdit 组件。</p>
<p>模型、视图和代理之间使用信号和槽通信。当源数据发生变化时，数据模型发射信号通知视图组件；当用户在界面上操作数据时，视图组件发射信号表示这些操作信息；当编辑数据时，代理发射信号告知数据模型和视图组件编辑器的状态。</p>
<h2 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h2><p>所有的基于项数据的数据模型（Model）都是基于 QAbstractltemModel 类的，这个类定义了视图组件和代理存取数据的接口。数据无需存储在数据模型里，数据可以是其他类、文件、数据库或任何数据源。</p>
<p>Qt 中与数据模型相关的几个主要的类的层次结构如图 2 所示：</p>
<p><img src="http://c.biancheng.net/uploads/allimg/190103/2-1Z103160KBJ.gif" alt="Qt中模型类的层次结构"></p>
<p>图 2 中的抽象类是不能直接使用的，需要由子类继承来实现一些纯虚函数。Qt 提供了一些模型类用于项数据处理，常见的几个见表 3。</p>
<table>
<thead>
<tr>
<th>Model 类</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>QStringListModel</td>
<td>用于处理字符串列表数据的数据模型类</td>
</tr>
<tr>
<td>QStandardltemModel</td>
<td>标准的基于项数据的数据模型类，每个项数据可以是任何数据类型</td>
</tr>
<tr>
<td>QFileSy stemModel</td>
<td>计算机上文件系统的数据模型类</td>
</tr>
<tr>
<td>QSortFilterProxyModel</td>
<td>与其他数据模型结合，提供排序和过滤功能的数据模型类</td>
</tr>
<tr>
<td>QSqlQueryModel</td>
<td>用于数据库SQL查询结果的数据模型类</td>
</tr>
<tr>
<td>QSqlTableModel</td>
<td>用于数据库的一个数据表的数据模型类</td>
</tr>
<tr>
<td>QSqlRelationalTableModel</td>
<td>用于关系型数据表的数据模型类</td>
</tr>
</tbody></table>
<p>数据库相关的 3 个模型类将在介绍数据库编程时专门说明。如果这些现有的模型类无法满足需求，用户可以从 QAbstractltemModel、QAbstractListModel 或 QAbstractTableModel 继承，生成自己定制的数据模型类。</p>
<h2 id="视图组件"><a href="#视图组件" class="headerlink" title="视图组件"></a>视图组件</h2><p>视图组件（View）就是显示数据模型的数据的界面组件，Qt 提供的视图组件如下：</p>
<ul>
<li>QListView：用于显示单列的列表数据，适用于一维数据的操作。</li>
<li>QTreeView：用于显示树状结构数据，适用于树状结构数据的操作。</li>
<li>QTableView：用于显示表格状数据，适用于二维表格型数据的操作。</li>
<li>QColumnView：用多个QListView显示树状层次结构，树状结构的一层用一个QListView显示。</li>
<li>QHeaderView：提供行表头或列表头的视图组件，如QTableView的行表头和列表头。</li>
</ul>
<p>视图组件在显示数据时，只需调用视图类的 setModel() 函数，为视图组件设置一个数据模型就可以实现视图组件与数据模型之间的关联，在视图组件上的修改将自动保存到关联的数据模型里，一个数据模型可以同时在多个视图组件里显示数据。</p>
<p>前面介绍了 QListWidget、QTreeWidget 和 QtableWidget 3个可用于数据编辑的组件。这 3 个类称为便利类（convenience classes），它们分别是 3 个视图类的子类，其层次关系如图 4 所示。</p>
<p><img src="http://c.biancheng.net/uploads/allimg/190103/2-1Z103160934132.gif" alt="视图相关类的层次结构图"></p>
<p>用于 Model/View 结构的几个视图类直接从 QAbstract ItemView 继承而来，而便利类则从相应的视图类继承而来。</p>
<p>视图组件类的数据采用单独的数据模型，视图组件不存储数据。便利类则为组件的每个节点或单元格创建一个项（item），用项存储数据、格式设置等。所以，便利类没有数据模型，它实际上是用项的方式集成了数据模型的功能，这样就将界面与数据绑定了。</p>
<p>所以，便利类缺乏对大型数据源进行灵活处理的能力，适用于小型数据的显示和编辑。</p>
<h2 id="代理（Delegate）"><a href="#代理（Delegate）" class="headerlink" title="代理（Delegate）"></a>代理（Delegate）</h2><p>代理就是在视图组件上为编辑数据提供编辑器，如在表格组件中编辑一个单元格的数据时，缺省是使用一个 QLineEdit 编辑框。代理负责从数据模型获取相应的数据，然后显示在编辑器里，修改数据后，又将其保存到数据模型中。</p>
<p>QAbstractltemDelegate 是所有代理类的基类，作为抽象类，它不能直接使用。它的一个子类 QStyledltemDelegate，是 Qt 的视图组件缺省使用的代理类。</p>
<p>对于一些特殊的数据编辑需求，例如只允许输入整型数，使用一个 QSpinBox 作为代理组件更恰当，从列表中选择数据时使用一个 QComboBox 作为代理组件更好。这时，就可以从 QStyledltemDelegate 继承创建自定义代理类。</p>
<h2 id="Model-View结构的一些概念"><a href="#Model-View结构的一些概念" class="headerlink" title="Model/View结构的一些概念"></a>Model/View结构的一些概念</h2><p>在 Model/View 结构中，数据模型为视图组件和代理提供存取数据的标准接口。在 Qt 中，所有的数据模型类都从 QAbstractltemModel 继承而来，不管底层的<a href="http://c.biancheng.net/data_structure/">数据结构</a>是如何组织数据的，QAbstractltemModel 的子类都以表格的层次结构表示数据，视图组件通过这种规则来存取模型中的数据，但是表现给用户的形式不一样。</p>
<p><img src="http://c.biancheng.net/uploads/allimg/190103/2-1Z1031610455L.gif" alt="数据模型的几种表现形式"></p>
<p>图 5 是数据模型的 3 种常见表现形式。不管数据模型的表现形式是怎么样的，数据模型中存储数据的基本单元都是项（item），每个项有一个行号、一个列号，还有一个父项。在列表和表格模式下，所有的项都有一个相同的顶层项；在树状结构中，行号、列号、父项稍微复杂一点，但是由这 3 个参数完全可以定义一个项的位置，从而存取项的数据。</p>
<h4 id="模型索引（model-index）"><a href="#模型索引（model-index）" class="headerlink" title="模型索引（model index）"></a>模型索引（model index）</h4><p>为了保证数据的表示与数据存取方式隔离，数据模型中引入了模型索引的概念。通过数据模型存取的每个数据都有一个模型索引，视图组件和代理都通过模型索引来获取数据。</p>
<p>QModelIndex 表示模型索引的类。模型索引提供数据存取的一个临时指针，用于通过数据模型提取或修改数据。因为模型内部组织数据的结构随时可能改变，所以模型索引是临时的。如果需要使用持久性的模型索引，则要使用 QPersistentModelIndex 类。</p>
<h4 id="行号和列号"><a href="#行号和列号" class="headerlink" title="行号和列号"></a>行号和列号</h4><p>数据模型的基本形式是用行和列定义的表格数据，但这并不意味着底层的数据是用二维数组存储的，使用行和列只是为了组件之间交互方便的一种规定。通过模型索引的行号和列号就可以存取数据。</p>
<p>要获得一个模型索引，必须提供 3 个参数：行号、列号、父项的模型索引。例如，对于如图 5 中的表格数据模型中的 3 个数据项 A、B、C，获取其模型索引的代码是：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QModelIndex indexA = model-&gt;<span class="built_in">index</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="built_in">QModelIndex</span>());</span><br><span class="line">QModelIndex indexB = model-&gt;<span class="built_in">index</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="built_in">QModelIndex</span>());</span><br><span class="line">QModelIndex indexC = model-&gt;<span class="built_in">index</span>(<span class="number">2</span>, <span class="number">1</span>, <span class="built_in">QModelIndex</span>());</span><br></pre></td></tr></table></figure>

<p>在创建模型索引的函数中需要传递行号、列号和父项的模型索引。对于列表和表格模式的数据模型，顶层节点总是用 QModelIndex() 表示。</p>
<h4 id="父项"><a href="#父项" class="headerlink" title="父项"></a>父项</h4><p>当数据模型是列表或表格时，使用行号、列号存储数据比较直观，所有数据项的父项就是顶层项；当数据模型是树状结构时，情况比较复杂（树状结构中，项一般习惯于称为节点），一个节点可以有父节点，也可以是其他节点的父节点，在构造数据项的模型索引时，必须指定正确的行号、列号和父节点。</p>
<p>对于图 5 中的树状数据模型，节点 A 和节点 C 的父节点是顶层节点，获取模型索引的代码是：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QModelIndex indexA = model-&gt;<span class="built_in">index</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="built_in">QModelIndex</span>());</span><br><span class="line">QModelIndex indexC = model-&gt;<span class="built_in">index</span>(<span class="number">2</span>, <span class="number">1</span>, <span class="built_in">QModelIndex</span>());</span><br></pre></td></tr></table></figure>

<p>但是，节点 B 的父节点是节点 A，节点 B 的模型索引由下面的代码生成：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QModelIndex indexB = model-&gt;<span class="built_in">index</span>(<span class="number">1</span>, <span class="number">0</span>, indexA);</span><br></pre></td></tr></table></figure>



<h4 id="项的角色"><a href="#项的角色" class="headerlink" title="项的角色"></a>项的角色</h4><p>在为数据模型的一个项设置数据时，可以赋予其不同项的角色的数据。例如，数据模型类 QStandardItemModel 的项数据类是 QStandardItem，其设置数据的函数是：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QStandardItem::setData</span><span class="params">(<span class="keyword">const</span> QVariant &amp;value, <span class="keyword">int</span> role= Qt::UserRole + <span class="number">1</span>)</span></span></span><br></pre></td></tr></table></figure>

<p>其中，value 是需要设置的数据，role 是设置数据的角色。一个项可以有不同角色的数据，用于不同的场合。</p>
<p>role 是 <code>Qt::ItemDataRole</code> 枚举类型，有多种取值，如 <code>Qt::DisplayRole</code> 角色是在视图组件中显示的字符串，<code>Qt::ToolTipRole</code> 是鼠标提示消息，<code>Qt::UserRole</code> 可以自定义数据。项的标准角色是 <code>Qt::DisplayRole</code>。</p>
<p>在获取一个项的数据时也需要指定角色，以获取不同角色的数据：</p>
<p><code>QVariant QStandardItem::data(int role = Qt::UserRole + 1) const</code></p>
<p>为一个项的不同角色定义数据，可以告知视图组件和代理组件如何显示数据。例如，在图 6 中，项的 DisplayRole 数据是显示的字符串，DecorationRole 是用于装饰显示的属性，ToolTipRole 定义了鼠标提示信息。不同的视图组件对各种角色数据的解释和显示可能不一样，也可能忽略某些角色的数据。</p>
<p><img src="http://c.biancheng.net/uploads/allimg/190103/2-1Z103161340927.gif" alt="不同角色数据的表现形式"></p>
]]></content>
      <categories>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>转载</tag>
        <tag>Qt</tag>
        <tag>Model/View</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL on Qt (2):SQL的连接、断开与增删查改基本操作</title>
    <url>/2020/07/23/mysqlonqt2/</url>
    <content><![CDATA[<h1 id="MySQL-on-Qt-2-SQL的连接、断开与增删查改基本操作"><a href="#MySQL-on-Qt-2-SQL的连接、断开与增删查改基本操作" class="headerlink" title="MySQL on Qt (2): SQL的连接、断开与增删查改基本操作"></a>MySQL on Qt (2): SQL的连接、断开与增删查改基本操作</h1><blockquote>
<p>写在前面： </p>
<p>大一下学期的 CPP 大作业“自主订餐系统”可真是颇费了一些力气，每天晚睡早起撸代码，课都没听，很多知识都是现学现用。</p>
<p>为了避免当时学到的东西给全部忘光光（`_&gt;`，我这脑子啊。。。），所以我把当时大作业的一些核心部分（一些零碎的小细节，能记就记）给记录一下，一方面是复习，一方面也方便以后用到的时候查阅。</p>
</blockquote>
<p>这篇文章是大作业 MySQL + SQLite 操作相关部分的第二章，主要讲一下 Qt 中 MySQL 和 SQLite 连接、断开与增删查改的基本操作。</p>
<span id="more"></span>

<h2 id="Qt-SQL-类"><a href="#Qt-SQL-类" class="headerlink" title="Qt SQL 类"></a>Qt SQL 类</h2><p><img src="https://gitee.com/skykeyjoker/PicCloud/raw/master/img/sqlmoudles.png" alt="Qt 中 SQl 相关类"></p>
<ul>
<li>用户接口层：实现将数据库中的数据链接到窗口部件上</li>
<li>SQL接口层：提供对数据库的访问</li>
<li>驱动层：为具体的数据库和SQL接口层之间提供了底层的桥梁</li>
</ul>
<p>要使用Qt SQL的类，需要在项目文件（.pro文件）中添加：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">QT += sql</span><br></pre></td></tr></table></figure>



<h2 id="Qt-SQL-的连接、断开与增删查改操作"><a href="#Qt-SQL-的连接、断开与增删查改操作" class="headerlink" title="Qt SQL 的连接、断开与增删查改操作"></a>Qt SQL 的连接、断开与增删查改操作</h2><p>下面用一个 demo 来演示 Qt 中 SQL 的连接、断开与增删查改操作。</p>
<img src="https://gitee.com/skykeyjoker/PicCloud/raw/master/img/demo.png" alt="demo" style="zoom:80%;" />



<hr>
<p>先来讲数据库的连接与断开。</p>
<h3 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h3><p>上一章已经讲过如何连接 SQL 数据库，这里就简简单单放一下代码。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Connect to db</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Widget::connectToDb</span><span class="params">(<span class="keyword">const</span> QString &amp; hostName, <span class="keyword">const</span> <span class="keyword">int</span> &amp; port, <span class="keyword">const</span> QString &amp; databaseName, <span class="keyword">const</span> QString &amp; username, <span class="keyword">const</span> QString &amp; password)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;hostName;</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;port;</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;databaseName;</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;username;</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;password;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set info</span></span><br><span class="line">    _db.<span class="built_in">setHostName</span>(hostName);</span><br><span class="line">    _db.<span class="built_in">setPort</span>(port);</span><br><span class="line">    _db.<span class="built_in">setDatabaseName</span>(databaseName);</span><br><span class="line">    _db.<span class="built_in">setUserName</span>(username);</span><br><span class="line">    _db.<span class="built_in">setPassword</span>(password);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Open Db</span></span><br><span class="line">    <span class="keyword">bool</span> ret = _db.<span class="built_in">open</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Error Info</span></span><br><span class="line">    QSqlError error = _db.<span class="built_in">lastError</span>();</span><br><span class="line">    <span class="keyword">if</span>(error.<span class="built_in">type</span>() != QSqlError::NoError)</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;error.<span class="built_in">text</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里要注意下打印出错信息的技巧，这样可以方便查错。</p>
<h3 id="断开数据库"><a href="#断开数据库" class="headerlink" title="断开数据库"></a>断开数据库</h3><p>啊这，更简单：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Close Db</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Widget::closeDb</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    _db.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<p>接下来讲数据库的增删查改操作。这些操作主要是对 Query 语句的简单利用。</p>
<p><strong>注意：</strong> MySQL 与 SQLite 的 SQL 语法存在一定区别，要注意区分使用。</p>
<h3 id="创建数据表"><a href="#创建数据表" class="headerlink" title="创建数据表"></a>创建数据表</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Create Table</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Widget::createTable</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Query</span></span><br><span class="line">    QSqlQuery query;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create table</span></span><br><span class="line">    query.<span class="built_in">exec</span>(<span class="string">&quot;CREATE TABLE `runoob_tbl` \</span></span><br><span class="line"><span class="string">                   (`runoob_id` INT UNSIGNED AUTO_INCREMENT, \</span></span><br><span class="line"><span class="string">                   `runoob_title` VARCHAR(100) NOT NULL,\</span></span><br><span class="line"><span class="string">                   `runoob_author` VARCHAR(40) NOT NULL,\</span></span><br><span class="line"><span class="string">                   `submission_date` DATE,\</span></span><br><span class="line"><span class="string">                   PRIMARY KEY ( `runoob_id`)) &quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Error Info</span></span><br><span class="line">    QSqlError error = _db.<span class="built_in">lastError</span>();</span><br><span class="line">    <span class="keyword">if</span>(error.<span class="built_in">type</span>() != QSqlError::NoError)</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;error.<span class="built_in">text</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="增加字段"><a href="#增加字段" class="headerlink" title="增加字段"></a>增加字段</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Add new column</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Widget::addNewcolumn</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Query</span></span><br><span class="line">    QSqlQuery query;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add column</span></span><br><span class="line">    query.<span class="built_in">exec</span>(<span class="string">&quot;ALTER TABLE runoob_tbl ADD COLUMN new1 VARCHAR(20) DEFAULT NULL;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Error Info</span></span><br><span class="line">    QSqlError error = _db.<span class="built_in">lastError</span>();</span><br><span class="line">    <span class="keyword">if</span>(error.<span class="built_in">type</span>() != QSqlError::NoError)</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;error.<span class="built_in">text</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="检验表是否存在"><a href="#检验表是否存在" class="headerlink" title="检验表是否存在"></a>检验表是否存在</h3><p>检验数据库中是否存在某表，可以利用 QSqlDatabase 提供的 <code>QSqlDatabase::tables()</code>函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Is Table Exists</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Widget::isTableExists</span><span class="params">(<span class="keyword">const</span> QString &amp;)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(_db.<span class="built_in">tables</span>().<span class="built_in">contains</span>(<span class="string">&quot;user&quot;</span>))</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;Table exists&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;Table not exists&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> _db.<span class="built_in">tables</span>().<span class="built_in">contains</span>(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>QSqlDatabase::tables()</code>函数返回一个 <em>QStringList</em> 类型的数据，里面储存着所有表名，所以我们可以很方便的调用 <code>QStringList::contains()</code> 函数了来检验表是否存在。</p>
<h3 id="查询、遍历数据表"><a href="#查询、遍历数据表" class="headerlink" title="查询、遍历数据表"></a>查询、遍历数据表</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Query Table</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Widget::queryTable</span><span class="params">(<span class="keyword">const</span> QString &amp;)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Query</span></span><br><span class="line">    QSqlQuery query;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Query the database</span></span><br><span class="line">    query.<span class="built_in">exec</span>(<span class="string">&quot;SELECT * FROM user WHERE 1&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get record</span></span><br><span class="line">    <span class="keyword">while</span>(query.<span class="built_in">next</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        QSqlRecord record = query.<span class="built_in">record</span>();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;record.<span class="built_in">value</span>(<span class="number">0</span>)&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;record.<span class="built_in">value</span>(<span class="number">1</span>)&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;record.<span class="built_in">value</span>(<span class="number">2</span>)&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;record.<span class="built_in">value</span>(<span class="number">3</span>)&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;record.<span class="built_in">value</span>(<span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Error Info</span></span><br><span class="line">    QSqlError error = _db.<span class="built_in">lastError</span>();</span><br><span class="line">    <span class="keyword">if</span>(error.<span class="built_in">type</span>() != QSqlError::NoError)</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;error.<span class="built_in">text</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>数据表的遍历技巧要记住。</p>
<h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Insert Data</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Widget::insertData</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//Query</span></span><br><span class="line">    QSqlQuery query;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Prepare</span></span><br><span class="line">    query.<span class="built_in">prepare</span>(<span class="string">&quot;INSERT INTO user VALUES (:ID, :Name, :Age, :Type, :Gender)&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Bind value</span></span><br><span class="line">    query.<span class="built_in">bindValue</span>(<span class="string">&quot;:ID&quot;</span>,<span class="number">0</span>);</span><br><span class="line">    query.<span class="built_in">bindValue</span>(<span class="string">&quot;:Name&quot;</span>,<span class="string">&quot;test&quot;</span>);</span><br><span class="line">    query.<span class="built_in">bindValue</span>(<span class="string">&quot;:Age&quot;</span>,<span class="number">22</span>);</span><br><span class="line">    query.<span class="built_in">bindValue</span>(<span class="string">&quot;:Type&quot;</span>,<span class="string">&quot;testType&quot;</span>);</span><br><span class="line">    query.<span class="built_in">bindValue</span>(<span class="string">&quot;:Gender&quot;</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Exec inserting</span></span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;query.<span class="built_in">exec</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Error Info</span></span><br><span class="line">    QSqlError error = _db.<span class="built_in">lastError</span>();</span><br><span class="line">    <span class="keyword">if</span>(error.<span class="built_in">type</span>() != QSqlError::NoError)</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;error.<span class="built_in">text</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>插入数据时使用了<code>QSqlDatabase::prepare()</code> 与 <code>QSqlDatabase::bindValue()</code>方法，当然我们也可以直接调用 <code>QSqlDatabase::exec()</code>，使用<code>tr(&quot;%1&quot;).arg(arg1)</code>方法来指定参数。</p>
<h3 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Update Data</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Widget::updateData</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Query</span></span><br><span class="line">    QSqlQuery query;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update</span></span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;query.<span class="built_in">exec</span>(<span class="string">&quot;UPDATE user SET Age=233 WHERE Name=&#x27;Joker&#x27;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Error Info</span></span><br><span class="line">    QSqlError error = _db.<span class="built_in">lastError</span>();</span><br><span class="line">    <span class="keyword">if</span>(error.<span class="built_in">type</span>() != QSqlError::NoError)</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;error.<span class="built_in">text</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Delete Data</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Widget::deleteData</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Query</span></span><br><span class="line">    QSqlQuery query;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Delete</span></span><br><span class="line">    query.<span class="built_in">exec</span>(<span class="string">&quot;DELETE FROM user WHERE Name=&#x27;test&#x27;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Error Info</span></span><br><span class="line">    QSqlError error = _db.<span class="built_in">lastError</span>();</span><br><span class="line">    <span class="keyword">if</span>(error.<span class="built_in">type</span>() != QSqlError::NoError)</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;error.<span class="built_in">text</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<p>至此本章的内容基本结束。下一章将讲解 Qt SQL 操作中最为精彩的部分：Model/View 模式。</p>
<blockquote>
<p>简单的 MySQL 和 SQLite 教程：</p>
<p>MySQL: <a href="https://www.runoob.com/mysql/mysql-tutorial.html">https://www.runoob.com/mysql/mysql-tutorial.html</a></p>
<p>SQLite: <a href="https://www.runoob.com/sqlite/sqlite-tutorial.html">https://www.runoob.com/sqlite/sqlite-tutorial.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>Qt</tag>
        <tag>Sql</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL on Qt (1):安装 MySQL 驱动以及连接 MySQL 与 SQLite</title>
    <url>/2020/07/22/mysqlonqt1/</url>
    <content><![CDATA[<h1 id="MySQL-on-Qt-1-安装-MySQL-驱动以及连接-MySQL-与-SQLite"><a href="#MySQL-on-Qt-1-安装-MySQL-驱动以及连接-MySQL-与-SQLite" class="headerlink" title="MySQL on Qt (1): 安装 MySQL 驱动以及连接 MySQL 与 SQLite"></a>MySQL on Qt (1): 安装 MySQL 驱动以及连接 MySQL 与 SQLite</h1><blockquote>
<p>写在前面： </p>
<p>大一下学期的 CPP 大作业“自主订餐系统”可真是颇费了一些力气，每天晚睡早起撸代码，课都没听，很多知识都是现学现用。</p>
<p>为了避免当时学到的东西给全部忘光光（`_&gt;`，我这脑子啊。。。），所以我把当时大作业的一些核心部分（一些零碎的小细节，能记就记）给记录一下，一方面是复习，一方面也方便以后用到的时候查阅。</p>
</blockquote>
<p>这篇文章是大作业 MySQL + SQLite 操作相关部分的第一章，主要讲一下如何安装 MySQL 驱动（Win 下）以及如何连接 MySQL 及 SQLite。</p>
<span id="more"></span>

<h2 id="准备部分——安装-MySQL-驱动"><a href="#准备部分——安装-MySQL-驱动" class="headerlink" title="准备部分——安装 MySQL 驱动"></a>准备部分——安装 MySQL 驱动</h2><p>还记得跟着教程学 Qt MySQL 操作的时候兴致冲冲地跟着打下了一行行代码，然后编译—运行，卧槽，报错。。。报错信息如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">QSqlDatabase: QMYSQL driver not loaded</span><br><span class="line"></span><br><span class="line">QSqlDatabase: available drivers: QSQLITE QPSQL QPSQL7</span><br><span class="line"></span><br><span class="line">&quot;Driver not loaded Driver not loaded&quot;</span><br></pre></td></tr></table></figure>

<p>看一下报错信息，大体的意思就是说 Qt 没有连接 MySQL 的驱动。</p>
<p>查看当前系统环境中的 Qt 支持哪些 Sql 驱动，可以输出一下 QSqlDatabase::drivers() 的值。</p>
<p>坑爹的 Qt 在 Win 下并没有附带 MySQL 的连接驱动，需要我们自行编译。</p>
<p>如果只需要连接远程数据库，那我们本地并不需要安装 MySQL，只要找到 MySQL 提供的 <code>libmysql.dll</code> 和 <code>libmysqld.dll</code> 拷贝到 Qt 的安装目录（<code>%QtDir%/migw.../bin</code>）。网上有教程说 Qt 默认自带已经编译好的 <code>qsqlmysql.dll</code> 和 <code>qsqlmysqld.dll</code> （路径在 <code>%QtDir%/mingw.../plugins/sqldrivers</code>），但是实测这些教程都已经老的不能再老了，我的安装目录下就没有自带的编译好的这两个 dll 文件，接下来我们开始着手安装和编译 MySQL 驱动。</p>
<h3 id="第一步：下载-MySQL-DLL文件"><a href="#第一步：下载-MySQL-DLL文件" class="headerlink" title="第一步：下载 MySQL DLL文件"></a>第一步：下载 MySQL DLL文件</h3><p>扔个地址： </p>
<blockquote>
<p><a href="https://dev.mysql.com/downloads/connector/cpp/">https://dev.mysql.com/downloads/connector/cpp/</a></p>
</blockquote>
<p>下载下来拷贝一下扔过去就好了。。。</p>
<p>（我记得当时搞了一个老版本的才能用。。。记不清了。。。需要的时候现搞吧。）</p>
<h3 id="第二步：-编译-MySQL-驱动"><a href="#第二步：-编译-MySQL-驱动" class="headerlink" title="第二步： 编译 MySQL 驱动"></a>第二步： 编译 MySQL 驱动</h3><p>这一步是重中之重，不巧的是我也忘的差不多了。。。</p>
<p>这里我们需要有 Qt 的源码，可以去下载一下。Qt 全部源码2G大小，我们可以仅选择模块进行下载。</p>
<p>用 Qt 打开源码目录下的<code>\src\plugins\sqldrivers\mysql\mysql.pro</code>。</p>
<p>在末尾加上两句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INCLUDEPATH += mysql安装目录\include</span><br><span class="line">LIBS += -Lmysql安装目录\lib\ -llibmysql</span><br></pre></td></tr></table></figure>

<p>构建项目后会生成 <code>qsqlmysql.dll</code> 和 <code>qsqlmysqld.dll</code>两个文件，然后拷贝到<code>%QtDir%/mingw.../plugins/sqldrivers</code>文件夹中。</p>
<p>准备部分到这里就大体结束了，理论上 Qt 就已经能成功连接 MySQL 。</p>
<h2 id="上路！连接-MySQL-和-SQLite"><a href="#上路！连接-MySQL-和-SQLite" class="headerlink" title="上路！连接 MySQL 和 SQLite"></a>上路！连接 MySQL 和 SQLite</h2><h3 id="配置工程文件"><a href="#配置工程文件" class="headerlink" title="配置工程文件"></a>配置工程文件</h3><p>若要使用 Qt 的 SQL 库，则需要在工程文件中添加相应的参数。</p>
<p>CMakeLists.txt:</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(Qt5 Sql)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(Ordering-System-Server PRIVATE Qt5::Sql)</span><br></pre></td></tr></table></figure>

<p>.pro工程文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">QT += sql</span><br></pre></td></tr></table></figure>



<h3 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h3><p>SQL 用到的库主要为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QSqlDatabase&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QSqlError&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QSqlRecord&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QSqlQuery&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QSqlIndex&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>其中 QSqlDatabase 是最重要的库，数据库的连接及其他基本操作都要在这个类上执行。</p>
<p>连接数据库时，我们主要会用到以下几个函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//添加数据库</span></span><br><span class="line">[<span class="keyword">static</span>] <span class="function">QSqlDatabase <span class="title">QSqlDatabase::addDatabase</span><span class="params">(<span class="keyword">const</span> QString &amp;type, <span class="keyword">const</span> QString &amp;connectionName = QLatin1String(defaultConnection))</span></span></span><br><span class="line"><span class="function"><span class="comment">//设置数据库相关信息</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QSqlDatabase::setHostName</span><span class="params">(<span class="keyword">const</span> QString &amp;host)</span>        <span class="comment">//主机地址</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QSqlDatabase::setDatabaseName</span><span class="params">(<span class="keyword">const</span> QString &amp;name)</span>    <span class="comment">//数据库名</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QSqlDatabase::setUserName</span><span class="params">(<span class="keyword">const</span> QString &amp;name)</span>    	   <span class="comment">//数据库用户名</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QSqlDatabase::setPassword</span><span class="params">(<span class="keyword">const</span> QString &amp;password)</span>    <span class="comment">//数据库密码</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QSqlDatabase::setPort</span><span class="params">(<span class="keyword">int</span> port)</span>                       <span class="comment">//数据库端口</span></span></span><br></pre></td></tr></table></figure>

<p>这里要特别注意一下<code>addDatabase()</code>这个函数的第二个参数 <em>connectionName</em> ，如果不指定这个参数，<strong>每次添加的数据库连接都会被应用程序当作默认连接</strong>。当初被这个坑了很久，因为大作业中服务端同时操作着两个数据库，一个远程 MySQL 数据库，一个本地 SQLite 数据库，添加第二个 SQLite 数据库后，就出锅不断，原因就在我没有注意第二个参数。</p>
<p><img src="https://gitee.com/skykeyjoker/PicCloud/raw/master/img/adddatabase.png" alt="Qt Doc中关于 addDatabase的介绍"></p>
<p>接下来分别就给一下连接 MySQL 和 SQLite 数据库的范例：</p>
<h4 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL:"></a>MySQL:</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QSqlDatabase db = QSqlDatabase::<span class="built_in">addDatabase</span>(<span class="string">&quot;QMYSQL&quot;</span>);   <span class="comment">//添加一个数据库 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//设置数据库信息</span></span><br><span class="line">db.<span class="built_in">setHostName</span>(_dbHost);</span><br><span class="line">db.<span class="built_in">setDatabaseName</span>(_dbName);</span><br><span class="line">db.<span class="built_in">setUserName</span>(_dbUser);</span><br><span class="line">db.<span class="built_in">setPassword</span>(_dbPasswd);</span><br><span class="line">db.<span class="built_in">setPort</span>(_dbPort);</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> dbRet = db.<span class="built_in">open</span>(); <span class="comment">//连接数据库</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!ret)</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;Can not open the DB&quot;</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;Open the DB successfully.&quot;</span>;</span><br></pre></td></tr></table></figure>



<p>SQLite:</p>
<p>因为 SQLite 数据库没有网络层，是一种本地储存的关系型数据库，因此连接的时候与 MySQL 有很大的差别。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置数据库文件名</span></span><br><span class="line">QString dbPath = QDir::<span class="built_in">currentPath</span>()+<span class="string">&quot;/&quot;</span>+<span class="string">&quot;orders.db&quot;</span>;</span><br><span class="line"></span><br><span class="line">sqliteDb = QSqlDatabase::<span class="built_in">addDatabase</span>(<span class="string">&quot;QSQLITE&quot;</span>,<span class="string">&quot;LocalSqlite&quot;</span>);</span><br><span class="line">sqliteDb.<span class="built_in">setDatabaseName</span>(dbPath);</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> ret = sqliteDb.<span class="built_in">open</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!ret)</span><br><span class="line">	<span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;Can not open the DB&quot;</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;Open the DB successfully.&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>数据库连接成功！</p>
<hr>
<p>MySQL 部分的第一章到此便结束了， 接下来的一章会讲解一些数据库的基本操作。</p>
<blockquote>
<p>补充：</p>
<p>MySQL 与 SQLite 的区别：</p>
<p><a href="https://blog.csdn.net/zbw1185/article/details/47975965">https://blog.csdn.net/zbw1185/article/details/47975965</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>Qt</tag>
        <tag>Sql</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下CMake使用</title>
    <url>/2020/07/21/cmake/</url>
    <content><![CDATA[<h1 id="Linux下CMake使用方法"><a href="#Linux下CMake使用方法" class="headerlink" title="Linux下CMake使用方法"></a>Linux下CMake使用方法</h1><p>在 linux 平台下使用 CMake 生成 Makefile 并编译的流程如下：</p>
<ol>
<li>编写 CMake 配置文件 CMakeLists.txt 。</li>
<li>执行命令 <code>cmake PATH</code> 或者 <code>ccmake PATH</code> 生成 Makefile 1 1<code>ccmake</code> 和 <code>cmake</code> 的区别在于前者提供了一个交互式的界面。。其中， <code>PATH</code> 是 CMakeLists.txt 所在的目录。</li>
<li>使用 <code>make</code> 命令进行编译。</li>
</ol>
<p>本文将从实例入手，一步步讲解 CMake 的常见用法，文中所有的实例代码可以在<a href="https://github.com/wzpan/cmake-demo">这里</a>找到。如果你读完仍觉得意犹未尽，可以继续学习我在文章末尾提供的其他资源。</p>
<span id="more"></span>

<h2 id="1-单个源文件"><a href="#1-单个源文件" class="headerlink" title="1.单个源文件"></a>1.单个源文件</h2><p>对于简单的项目，只需要写几行代码就可以了。例如，假设现在我们的项目中只有一个源文件 <a href="http://main.cc/">main.c</a> ，首先编写 CMakeLists.txt 文件，并保存在与 <a href="http://main.cc/">main.c</a> 源文件同个目录下：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># CMake 最低版本号要求</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span> (VERSION <span class="number">2.8</span>)</span><br><span class="line"><span class="comment"># 项目信息</span></span><br><span class="line"><span class="keyword">project</span> (Demo1)</span><br><span class="line"><span class="comment"># 指定生成目标</span></span><br><span class="line"><span class="keyword">add_executable</span>(Demo1 main.cc)</span><br></pre></td></tr></table></figure>

<p>CMakeLists.txt 的语法比较简单，由命令、注释和空格组成，其中命令是不区分大小写的。符号 <code>#</code> 后面的内容被认为是注释。命令由命令名称、小括号和参数组成，参数之间使用空格进行间隔。</p>
<p>对于上面的 ==CMakeLists.txt== 文件，依次出现了几个命令：</p>
<ol>
<li><code>cmake_minimum_required</code>：指定运行此配置文件所需的 CMake 的最低版本；</li>
<li><code>project</code>：参数值是 <code>Demo1</code>，该命令表示项目的名称是 <code>Demo1</code> 。</li>
<li><code>add_executable</code>： 将名为 <a href="http://main.cc/">main.c</a> 的源文件编译成一个名称为 Demo 的可执行文件。</li>
</ol>
<p>之后，在当前目录执行 <strong><code>cmake .</code></strong> ，得到 Makefile 后再使用 <strong><code>make</code></strong> 命令编译得到 Demo1 可执行文件。</p>
<h2 id="2-多个源文件"><a href="#2-多个源文件" class="headerlink" title="2.多个源文件"></a>2.多个源文件</h2><h3 id="1-同一目录，多个源文件"><a href="#1-同一目录，多个源文件" class="headerlink" title="1) 同一目录，多个源文件"></a>1) 同一目录，多个源文件</h3><p>上面的例子只有单个源文件。现在假如把 <code>power</code> 函数单独写进一个名为 <code>MathFunctions.c</code> 的源文件里，使得这个工程变成如下的形式：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">./Demo2</span><br><span class="line">    |</span><br><span class="line">    +--- main.cc</span><br><span class="line">    |</span><br><span class="line">    +--- MathFunctions.cc</span><br><span class="line">    |</span><br><span class="line">    +--- MathFunctions.h</span><br></pre></td></tr></table></figure>

<p>这个时候，CMakeLists.txt 可以改成如下的形式：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># CMake 最低版本号要求</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span> (VERSION <span class="number">2.8</span>)</span><br><span class="line"><span class="comment"># 项目信息</span></span><br><span class="line"><span class="keyword">project</span> (Demo2)</span><br><span class="line"><span class="comment"># 指定生成目标</span></span><br><span class="line"><span class="keyword">add_executable</span>(Demo main.cc MathFunctions.cc)</span><br></pre></td></tr></table></figure>

<p>唯一的改动只是在 <strong><code>add_executable</code></strong> 命令中增加了一个 <strong><code>MathFunctions.cc</code></strong> 源文件。这样写当然没什么问题，但是如果源文件很多，把所有源文件的名字都加进去将是一件烦人的工作。更省事的方法是使用 <strong><code>aux_source_directory</code></strong> 命令，该命令会查找指定目录下的所有源文件，然后将结果存进指定变量名。其语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">aux_source_directory(&lt;dir&gt; &lt;variable&gt;)</span><br></pre></td></tr></table></figure>

<p>因此，可以修改 CMakeLists.txt 如下：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># CMake 最低版本号要求</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span> (VERSION <span class="number">2.8</span>)</span><br><span class="line"><span class="comment"># 项目信息</span></span><br><span class="line"><span class="keyword">project</span> (Demo2)</span><br><span class="line"><span class="comment"># 查找当前目录下的所有源文件</span></span><br><span class="line"><span class="comment"># 并将名称保存到 DIR_SRCS 变量</span></span><br><span class="line"><span class="keyword">aux_source_directory</span>(. DIR_SRCS)</span><br><span class="line"><span class="comment"># 指定生成目标</span></span><br><span class="line"><span class="keyword">add_executable</span>(Demo <span class="variable">$&#123;DIR_SRCS&#125;</span>)</span><br></pre></td></tr></table></figure>

<p>这样，CMake 会将当前目录所有源文件的文件名赋值给变量 <code>DIR_SRCS</code> ，再指示变量 <code>DIR_SRCS</code> 中的源文件需要编译成一个名称为 Demo 的可执行文件。</p>
<h3 id="2-多个目录，多个源文件"><a href="#2-多个目录，多个源文件" class="headerlink" title="2) 多个目录，多个源文件"></a>2) 多个目录，多个源文件</h3><p>现在进一步将 MathFunctions.h 和 <a href="http://mathfunctions.cc/">MathFunctions.cc</a> 文件移动到 math 目录下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./Demo3</span><br><span class="line">    |</span><br><span class="line">    +--- main.cc</span><br><span class="line">    |</span><br><span class="line">    +--- math/</span><br><span class="line">          |</span><br><span class="line">          +--- MathFunctions.cc</span><br><span class="line">          |</span><br><span class="line">          +--- MathFunctions.h</span><br></pre></td></tr></table></figure>

<p>于这种情况，需要分别在项目根目录 Demo3 和 math 目录里各编写一个 CMakeLists.txt 文件。为了方便，我们可以先将 math 目录里的文件编译成静态库再由 main 函数调用。</p>
<p>根目录中的 CMakeLists.txt ：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># CMake 最低版本号要求</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span> (VERSION <span class="number">2.8</span>)</span><br><span class="line"><span class="comment"># 项目信息</span></span><br><span class="line"><span class="keyword">project</span> (Demo3)</span><br><span class="line"><span class="comment"># 查找当前目录下的所有源文件</span></span><br><span class="line"><span class="comment"># 并将名称保存到 DIR_SRCS 变量</span></span><br><span class="line"><span class="keyword">aux_source_directory</span>(. DIR_SRCS)</span><br><span class="line"><span class="comment"># 添加 math 子目录</span></span><br><span class="line"><span class="keyword">add_subdirectory</span>(<span class="keyword">math</span>)</span><br><span class="line"><span class="comment"># 指定生成目标 </span></span><br><span class="line"><span class="keyword">add_executable</span>(Demo main.cc)</span><br><span class="line"><span class="comment"># 添加链接库</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(Demo MathFunctions)</span><br></pre></td></tr></table></figure>

<p>该文件添加了下面的内容: 第3行，使用命令 <strong><code>add_subdirectory</code></strong> 指明本项目包含一个子目录 math，这样 <strong>math 目录下的 CMakeLists.txt 文件和源代码也会被处理</strong> 。第6行，使用命令 <strong><code>target_link_libraries</code></strong> 指明可执行文件 main 需要连接一个名为 MathFunctions 的链接库 。</p>
<p>==子目录中的 CMakeLists.txt==：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查找当前目录下的所有源文件</span></span><br><span class="line"><span class="comment"># 并将名称保存到 DIR_LIB_SRCS 变量</span></span><br><span class="line"><span class="keyword">aux_source_directory</span>(. DIR_LIB_SRCS)</span><br><span class="line"><span class="comment"># 生成链接库</span></span><br><span class="line"><span class="keyword">add_library</span> (MathFunctions <span class="variable">$&#123;DIR_LIB_SRCS&#125;</span>)</span><br></pre></td></tr></table></figure>

<p>在该文件中使用命令 <code>add_library</code> 将 src 目录中的源文件编译为静态链接库。</p>
<h2 id="3-正规一点的组织结构"><a href="#3-正规一点的组织结构" class="headerlink" title="3.正规一点的组织结构"></a>3.正规一点的组织结构</h2><p>正规一点来说，一般会把源文件放到<strong>src</strong>目录下，把头文件放入到<strong>include</strong>文件下，生成的对象文件放入到<strong>build</strong>目录下，最终输出的elf文件会放到<strong>bin</strong>目录下，这样整个结构更加清晰。让我们把前面的文件再次重新组织下，</p>
<p>我们在最外层目录下新建一个CMakeLists.txt，内容如下，</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span> (VERSION <span class="number">2.8</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span> (demo)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_subdirectory</span> (src)</span><br></pre></td></tr></table></figure>

<p>这里出现一个新的命令<code>add_subdirectory()</code>，这个命令==可以向当前工程添加存放源文件的子目录，并可以指定中间二进制和目标二进制的存放位置==，具体用法可以百度。<br>这里指定src目录下存放了源文件，当执行cmake时，就会进入src目录下去找src目录下的CMakeLists.txt，所以在<strong>src目录</strong>下也建立一个<strong>CMakeLists.txt</strong>，内容如下，</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">aux_source_directory</span> (. SRC_LIST)</span><br><span class="line"></span><br><span class="line"><span class="keyword">include_directories</span> (../<span class="keyword">include</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span> (main <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> (EXECUTABLE_OUTPUT_PATH <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/bin)</span><br></pre></td></tr></table></figure>


<p>这里又出现一个新的命令<code>set</code>，是用于定义变量的，<code>EXECUTABLE_OUT_PATH</code>和<code>PROJECT_SOURCE_DIR</code>是CMake自带的预定义变量，其意义如下，</p>
<blockquote>
<p><strong>EXECUTABLE_OUTPUT_PATH</strong> ：目标二进制可执行文件的存放位置<br><strong>PROJECT_SOURCE_DIR</strong>：工程的根目录</p>
</blockquote>
<p>所以，这里set的意思是把存放elf文件的位置设置为工程根目录下的bin目录。</p>
<p>添加好以上这2个CMakeLists.txt后，整体文件结构如下，</p>
<p>下面来运行cmake，不过这次先让我们切到build目录下，然后输入以下命令，<br><code>cmake ..</code><br>Makefile会在build目录下生成，然后在build目录下运行make，</p>
<p>运行ok，我们再切到bin目录下，发现main已经生成，并运行测试，</p>
<p>测试OK！</p>
<blockquote>
<p>这里解释一下为什么在build目录下运行cmake？从前面几个case中可以看到，如果不这样做，cmake运行时生成的附带文件就会跟源码文件混在一起，这样会对程序的目录结构造成污染，而在build目录下运行cmake，生成的附带文件就只会待在build目录下，如果我们不想要这些文件了就可以直接清空build目录，非常方便。</p>
</blockquote>
<p>另外一种写法：<br>前面的工程使用了2个CMakeLists.txt，这种写法是为了处理需要生成多个elf文件的情况，最外层的CMakeLists.txt用于掌控全局，使用<code>add_subdirectory</code>来添加要生成elf文件的源码目录。</p>
<p>如果只生成一个elf文件，那么上面的例子可以只使用一个CMakeLists.txt，可以把最外层的CMakeLists.txt内容改成如下，</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span> (VERSION <span class="number">2.8</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span> (demo)</span><br><span class="line"></span><br><span class="line"><span class="keyword">aux_source_directory</span> (src SRC_LIST)</span><br><span class="line"></span><br><span class="line"><span class="keyword">include_directories</span> (<span class="keyword">include</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span> (main <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> (EXECUTABLE_OUTPUT_PATH <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/bin)</span><br></pre></td></tr></table></figure>

<p>==同时，还要把src目录下的CMakeLists.txt删除。==</p>
<h2 id="4-动态库和静态库的编译控制"><a href="#4-动态库和静态库的编译控制" class="headerlink" title="4.动态库和静态库的编译控制"></a>4.动态库和静态库的编译控制</h2><p>有时我们只需要编译出动态库，静态库，然后等着让其它程序去使用。让我们看下这种情况该如何使用cmake。首先按照如下重新组织文件，只留下testFunc.h和TestFunc.c，</p>
<p>我们会在build目录下运行cmake，并把生成的库文件存放到lib目录下。<br><strong>最外层</strong>的CMakeLists.txt内容如下，</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span> (VERSION <span class="number">2.8</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span> (demo)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_subdirectory</span> (lib_testFunc)</span><br></pre></td></tr></table></figure>

<p><strong>lib_testFunc</strong>目录下的CMakeLists.txt如下，</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">aux_source_directory</span> (. SRC_LIST)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_library</span> (testFunc_shared SHARED <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br><span class="line"><span class="keyword">add_library</span> (testFunc_static STATIC <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set_target_properties</span> (testFunc_shared PROPERTIES OUTPUT_NAME <span class="string">&quot;testFunc&quot;</span>)</span><br><span class="line"><span class="keyword">set_target_properties</span> (testFunc_static PROPERTIES OUTPUT_NAME <span class="string">&quot;testFunc&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> (LIBRARY_OUTPUT_PATH <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/lib)</span><br></pre></td></tr></table></figure>

<p>这里又出现了新的命令和预定义变量，</p>
<blockquote>
<p><strong>add_library</strong>: 生成动态库或静态库(第1个参数指定库的名字；第2个参数决定是动态还是静态，如果没有就默认静态；第3个参数指定生成库的源文件)<br><strong>set_target_properties</strong>: 设置输出的名称，还有其它功能，如设置库的版本号等等<br>LIBRARY_OUTPUT_PATH: 库文件的默认输出路径，这里设置为工程目录下的lib目录<br>好了，让我们进入build目录下运行cmake ..，成功后再运行make，</p>
</blockquote>
<p>cd到lib目录下进行查看，发现已经成功生成了动态库和静态库，</p>
<blockquote>
<p>ps：可以看出前面使用<code>set_target_properties</code>重新定义了库的输出名字，如果不用<code>set_target_properties</code>也可以，那么库的名字就是<strong>add_library</strong>里定义的名字，只是我们连续2次使用add_library指定库名字时，这个名字不能相同，而<code>set_target_properties</code>可以把名字设置为相同，只是最终生成的库文件后缀不同，这样相对来说会好看点。</p>
</blockquote>
<h2 id="5-对库进行链接"><a href="#5-对库进行链接" class="headerlink" title="5.对库进行链接"></a>5.对库进行链接</h2><p>既然我们已经生成了库，那么就进行链接测试下。把build里的文件都删除，然后在在工程目录下新建src目录和bin目录，在src目录下添加一个main.c和一个CMakeLists.txt，整体结构如下，</p>
<p><img src="https://img-blog.csdn.net/20180827221422465?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3doYWh1MTk4OQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<p><strong>main.c</strong>内容如下，</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;testFunc.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    func(<span class="number">100</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>修改工程目录下的CMakeLists.txt</strong>，如下，</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span> (VERSION <span class="number">2.8</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span> (demo)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_subdirectory</span> (lib_testFunc)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_subdirectory</span> (src)</span><br></pre></td></tr></table></figure>

<p>只是使用<code>add_subdirectory</code>把<strong>src</strong>目录添加进来。<br><strong>src</strong>目录下的CMakeLists.txt如下，</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">aux_source_directory</span> (. SRC_LIST)</span><br><span class="line"><span class="comment"># find testFunc.h</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">include_directories</span> (../lib_testFunc)</span><br><span class="line"></span><br><span class="line"><span class="keyword">link_directories</span> (<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/lib)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span> (main <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span> (main testFunc)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> (EXECUTABLE_OUTPUT_PATH <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/bin)</span><br></pre></td></tr></table></figure>


<p>这里出现2个新的命令，</p>
<blockquote>
<p><code>link_directories</code>: 添加非标准的共享库搜索路径<br><code>target_link_libraries</code>: 把目标文件与库文件进行链接</p>
</blockquote>
<p>make成功，进入到bin目录下查看，发现main已经生成，并运行，</p>
<p>运行成功！</p>
<blockquote>
<p>ps：在lib目录下有testFunc的静态库和动态库，<code>target_link_libraries (main testFunc)</code>默认是使用动态库，如果lib目录下只有静态库，那么这种写法就会去链接静态库。也可以直接指定使用动态库还是静态库，写法是：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">target_link_libraries</span> (main libtestFunc.so)</span><br><span class="line"><span class="comment">#或</span></span><br><span class="line"><span class="keyword">target_link_libraries</span> (main libtestFunc.a)</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>ps： 查看elf文件使用了哪些库，可以使用<code>readelf -d ./xx</code>来查看</p>
</blockquote>
<h2 id="6-添加编译选项"><a href="#6-添加编译选项" class="headerlink" title="6.添加编译选项"></a>6.添加编译选项</h2><p>有时编译程序时想添加一些编译选项，如<code>-Wall</code>，<code>-std=c++11</code>等，就可以使用<code>add_compile_options</code>来进行操作。<br>这里以一个简单程序来做演示，main.cpp如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> data = <span class="number">100</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;data: &quot;</span> &lt;&lt; data &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>CMakeLists.txt内容如下，</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span> (VERSION <span class="number">2.8</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span> (demo)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> (EXECUTABLE_OUTPUT_PATH <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/bin)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_compile_options</span>(-std=c++<span class="number">11</span> -Wall) </span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(main main.cpp)</span><br></pre></td></tr></table></figure>


<p>整体目录结构如下，</p>
<p><img src="https://img-blog.csdnimg.cn/20190718210743197.png" alt="在这里插入图片描述"></p>
<p>然后cd到build目录下，执行<code>cmake .. &amp;&amp; make</code>命令，就可以在bin目录下得到main的elf文件</p>
<h2 id="7-添加控制选项"><a href="#7-添加控制选项" class="headerlink" title="7. 添加控制选项"></a>7. 添加控制选项</h2><p>有时希望在<strong>编译代码时只编译一些指定的源码</strong>，例如本来要编译生成多个bin或库文件，现在<strong>只想生成某些指定的bin或库文件</strong>，这时可以使用cmake的<strong>option</strong>命令。</p>
<p>这里仍然使用例子来解释，假设我们现在的工程会生成2个bin文件，main1和main2，现在整体结构体如下，</p>
<p><img src="https://img-blog.csdnimg.cn/20190811114036435.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3doYWh1MTk4OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>外层的CMakeLists.txt内容如下，</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">2.8</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span>(demo)</span><br><span class="line"></span><br><span class="line"><span class="keyword">option</span>(MYDEBUG <span class="string">&quot;enable debug compilation&quot;</span> <span class="keyword">OFF</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> (EXECUTABLE_OUTPUT_PATH <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/bin)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_subdirectory</span>(src)</span><br></pre></td></tr></table></figure>


<p>这里使用了<code>option</code>命令，其第一个参数是这个option的名字，第二个参数是字符串，用来描述这个option是来干嘛的，第三个是option的值，ON或OFF，也可以不写，不写就是默认OFF。</p>
<p>然后编写src目录下的CMakeLists.txt，如下</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span> (VERSION <span class="number">2.8</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(main1 main1.c)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (MYDEBUG)</span><br><span class="line">    <span class="keyword">add_executable</span>(main2 main2.c)</span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line">    <span class="keyword">message</span>(STATUS <span class="string">&quot;Currently is not in debug mode&quot;</span>)    </span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>

<p>注意，这里使用了<code>if-else</code>来根据option来决定是否编译main2.c<br>其中main1.c和main2.c的内容如下，</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main1.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello, this main1\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main2.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello, this main2\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>然后cd到build目录下输入<code>cmake .. &amp;&amp; make</code>就可以只编译出main1，如果想编译出main2，就把<code>MYDEBUG</code>设置为<strong>ON</strong>，再次输入<code>cmake .. &amp;&amp; make</code>重新编译。</p>
<p>每次想改变MYDEBUG时都需要去修改CMakeLists.txt，有点麻烦，其实可以通过cmake的命令行去操作，例如我们想把MYDEBUG设置为OFF，先cd到build目录，然后输入<code>cmake .. -DMYDEBUG=ON</code>，这样就可以编译出main1和main2 （在bin目录下）</p>
<blockquote>
<p>来源：<a href="https://blog.csdn.net/qq_28114615/article/details/90406140">https://blog.csdn.net/qq_28114615/article/details/90406140</a></p>
</blockquote>
<p><em>2020.3.29 19:01</em></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>cmake</tag>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title>二元运算符重载</title>
    <url>/2020/07/21/%E4%BA%8C%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/</url>
    <content><![CDATA[<h1 id="C-二元运算符重载"><a href="#C-二元运算符重载" class="headerlink" title="C++ 二元运算符重载"></a>C++ 二元运算符重载</h1><p>二元运算符需要两个参数，下面是二元运算符的实例。我们平常使用的加运算符（ + ）、减运算符（ - ）、乘运算符（ * ）和除运算符（ / ）都属于二元运算符。就像加(+)运算符。</p>
<p>下面的实例演示了如何重载加运算符（ + ）。类似地，您也可以尝试重载减运算符（ - ）和除运算符（ / ）。</p>
<span id="more"></span>

<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span> &#123;</span>   </span><br><span class="line">    <span class="keyword">double</span> length;      <span class="comment">// 长度   </span></span><br><span class="line">    <span class="keyword">double</span> breadth;     <span class="comment">// 宽度   </span></span><br><span class="line">    <span class="keyword">double</span> height;      <span class="comment">// 高度 </span></span><br><span class="line">    <span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getVolume</span><span class="params">(<span class="keyword">void</span>)</span>   </span></span><br><span class="line"><span class="function">    </span>&#123;      </span><br><span class="line">        <span class="keyword">return</span> length * breadth * height;   </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setLength</span><span class="params">( <span class="keyword">double</span> len )</span>   </span></span><br><span class="line"><span class="function">    </span>&#123;       </span><br><span class="line">        length = len;   </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setBreadth</span><span class="params">( <span class="keyword">double</span> bre )</span>   </span></span><br><span class="line"><span class="function">    </span>&#123;       </span><br><span class="line">        breadth = bre;   </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setHeight</span><span class="params">( <span class="keyword">double</span> hei )</span>   </span></span><br><span class="line"><span class="function">    </span>&#123;       </span><br><span class="line">        height = hei;   </span><br><span class="line">    &#125;   <span class="comment">// 重载 + 运算符，用于把两个 Box 对象相加   </span></span><br><span class="line">    Box <span class="keyword">operator</span>+(<span class="keyword">const</span> Box&amp; b)   </span><br><span class="line">    &#123;      </span><br><span class="line">        Box box;      </span><br><span class="line">        box.length = <span class="keyword">this</span>-&gt;length + b.length;      </span><br><span class="line">        box.breadth = <span class="keyword">this</span>-&gt;breadth + b.breadth;      </span><br><span class="line">        box.height = <span class="keyword">this</span>-&gt;height + b.height;      </span><br><span class="line">        <span class="keyword">return</span> box;   &#125; &#125;; </span><br><span class="line"><span class="comment">// 程序的主函数 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( )</span> </span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    Box Box1;                <span class="comment">// 声明 Box1，类型为 Box   </span></span><br><span class="line">    Box Box2;                <span class="comment">// 声明 Box2，类型为 Box   </span></span><br><span class="line">    Box Box3;                <span class="comment">// 声明 Box3，类型为 Box   </span></span><br><span class="line">    <span class="keyword">double</span> volume = <span class="number">0.0</span>;     <span class="comment">// 把体积存储在该变量中    </span></span><br><span class="line">    <span class="comment">// Box1 详述  </span></span><br><span class="line">    Box1.<span class="built_in">setLength</span>(<span class="number">6.0</span>);    </span><br><span class="line">    Box1.<span class="built_in">setBreadth</span>(<span class="number">7.0</span>);    </span><br><span class="line">    Box1.<span class="built_in">setHeight</span>(<span class="number">5.0</span>);    </span><br><span class="line">    <span class="comment">// Box2 详述   </span></span><br><span class="line">    Box2.<span class="built_in">setLength</span>(<span class="number">12.0</span>);    </span><br><span class="line">    Box2.<span class="built_in">setBreadth</span>(<span class="number">13.0</span>);    </span><br><span class="line">    Box2.<span class="built_in">setHeight</span>(<span class="number">10.0</span>);    </span><br><span class="line">    <span class="comment">// Box1 的体积   </span></span><br><span class="line">    volume = Box1.<span class="built_in">getVolume</span>();   </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Volume of Box1 : &quot;</span> &lt;&lt; volume &lt;&lt;endl;    </span><br><span class="line">    <span class="comment">// Box2 的体积   </span></span><br><span class="line">    volume = Box2.<span class="built_in">getVolume</span>();   </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Volume of Box2 : &quot;</span> &lt;&lt; volume &lt;&lt;endl;    </span><br><span class="line">    <span class="comment">// 把两个对象相加，得到 Box3   </span></span><br><span class="line">    Box3 = Box1 + Box2;    <span class="comment">// Box3 的体积   </span></span><br><span class="line">    volume = Box3.<span class="built_in">getVolume</span>();   </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Volume of Box3 : &quot;</span> &lt;&lt; volume &lt;&lt;endl;    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Volume of Box1 : 210</span><br><span class="line">Volume of Box2 : 1560</span><br><span class="line">Volume of Box3 : 5400</span><br></pre></td></tr></table></figure>





<h2 id="非成员函数与类成员二元运算-友元函数"><a href="#非成员函数与类成员二元运算-友元函数" class="headerlink" title="非成员函数与类成员二元运算(友元函数)"></a>非成员函数与类成员二元运算(友元函数)</h2><p>当 2 个对象相加时是没有顺序要求的，<strong>但要重载 ‘+’让其与一个数字相加则有顺序要求，可以通过加一个</strong>友元函数<strong>使另一个顺序的输入合法。</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">            <span class="built_in">A</span>();</span><br><span class="line">            <span class="built_in">A</span>(<span class="keyword">int</span> n);</span><br><span class="line">            A <span class="keyword">operator</span>+(<span class="keyword">const</span> A &amp; obj);</span><br><span class="line">            A <span class="keyword">operator</span>+(<span class="keyword">const</span> <span class="keyword">int</span> b);</span><br><span class="line">    		<span class="keyword">friend</span> A <span class="keyword">operator</span>+(<span class="keyword">const</span> <span class="keyword">int</span> b, A obj); </span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>; </span><br><span class="line">&#125; ;</span><br><span class="line">A::<span class="built_in">A</span>()</span><br><span class="line">&#123;</span><br><span class="line">    a=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">A::<span class="built_in">A</span>(<span class="keyword">int</span> n)<span class="comment">//构造函数 </span></span><br><span class="line">&#123;</span><br><span class="line">    a=n;</span><br><span class="line">&#125;</span><br><span class="line">A A::<span class="keyword">operator</span> +(<span class="keyword">const</span> A&amp; obj)<span class="comment">//重载+号用于 对象相加 </span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;a+obj.a;</span><br><span class="line">&#125;</span><br><span class="line">A A::<span class="keyword">operator</span>+(<span class="keyword">const</span> <span class="keyword">int</span> b)<span class="comment">//重载+号用于  对象与数相加</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">A</span>(a+b);</span><br><span class="line">&#125;</span><br><span class="line">A <span class="keyword">operator</span>+(<span class="keyword">const</span> <span class="keyword">int</span> b,  A obj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> obj+b;<span class="comment">//友元函数调用第二个重载+的成员函数  相当于 obj.operator+(b); </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">A::display</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">a1</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">A <span class="title">a2</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">    A a3,a4,a5;</span><br><span class="line">    a1.<span class="built_in">display</span>();</span><br><span class="line">    a2.<span class="built_in">display</span>();</span><br><span class="line">    <span class="keyword">int</span> m=<span class="number">1</span>;</span><br><span class="line">    a3=a1+a2;<span class="comment">//可以交换顺序，相当月a3=a1.operator+(a2); </span></span><br><span class="line">    a3.<span class="built_in">display</span>();</span><br><span class="line">    a4=a1+m;<span class="comment">//因为加了个友元函数所以也可以交换顺序了。</span></span><br><span class="line">    a4.<span class="built_in">display</span>();</span><br><span class="line">    a5=m+a1;</span><br><span class="line">    a5.<span class="built_in">display</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title>构造函数</title>
    <url>/2020/07/21/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="【C-】类构造函数（深拷贝与浅拷贝）"><a href="#【C-】类构造函数（深拷贝与浅拷贝）" class="headerlink" title="【C++】类构造函数（深拷贝与浅拷贝）"></a>【C++】类构造函数（深拷贝与浅拷贝）</h1><blockquote>
<p>原创Jacky_Feng 最后发布于2019-11-29 19:56:28 阅读数 16  收藏</p>
</blockquote>
<h2 id="1-什么是类的构造函数"><a href="#1-什么是类的构造函数" class="headerlink" title="1.什么是类的构造函数"></a>1.什么是类的构造函数</h2><p>类的构造函数是类的一种特殊的成员函数，它会在每次创建类的新对象时被自动调用。没创建一个对象都必须调用一次构造函数。</p>
<p>构造函数的名称与类的名称是完全相同的，并且不会返回任何类型，也不会返回void。构造函数可用于为某些成员变量设置初始值。</p>
<span id="more"></span>

<p>实例演示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 类Counter的构造函数</span></span><br><span class="line">    <span class="comment">// 特点：以类名作为函数名，无返回类型</span></span><br><span class="line">    <span class="built_in">Counter</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;object is being created&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 数据成员</span></span><br><span class="line">    <span class="keyword">int</span> m_value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Counter obj1;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>以上代码编译和执行的结果如下：</p>
<p><strong>object is being created</strong></p>
</blockquote>
<p> 该类对象obj1被创建时，编译系统为对象分配内存空间，并自动调用构造函数Counter()完成对象成员变量的初始化工作。</p>
<h2 id="2-构造函数的分类"><a href="#2-构造函数的分类" class="headerlink" title="2.构造函数的分类"></a>2.构造函数的分类</h2><h3 id="1）按函数有无参数分类"><a href="#1）按函数有无参数分类" class="headerlink" title="1）按函数有无参数分类"></a>1）按函数有无参数分类</h3><img src="https://img-blog.csdnimg.cn/20191129164917429.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phY2t5X0Zlbmc=,size_16,color_FFFFFF,t_70" alt="有无参数分类" style="zoom:80%;" />

<p> 其中所有带有默认值的有参构造函数会转变成默认构造函数。</p>
<h3 id="2）按参数的类型分类"><a href="#2）按参数的类型分类" class="headerlink" title="2）按参数的类型分类"></a>2）按参数的类型分类</h3><img src="https://img-blog.csdnimg.cn/20191129165633658.png" alt="按参数的类型分类" style="zoom:80%;" />

<p> 一个类中至少有上述两个构造函数，可以有更多的构造函数（构造函数允许重载），以实现不同形式对象的创建。</p>
<h2 id="3-构造函数的重载"><a href="#3-构造函数的重载" class="headerlink" title="3.构造函数的重载"></a>3.构造函数的重载</h2><p>和普通成员函数一样，构造函数是允许重载的。一个类中可以有多个重载的构造函数，创建对象时根据传递的实参来判断调用哪个构造函数。创建对象构造函数的调用是强制性的，一旦在类中定义了构造函数，那么创建对象时就一定要调用。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">String</span>(<span class="keyword">const</span> <span class="keyword">char</span> *str = <span class="literal">NULL</span>); <span class="comment">// 普通构造函数</span></span><br><span class="line">    <span class="built_in">String</span>(<span class="keyword">const</span> String &amp;other);    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    ~ <span class="built_in">String</span>(<span class="keyword">void</span>);                 <span class="comment">// 析构函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> *m_data; <span class="comment">// 用于保存字符串</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// String 的析构函数</span></span><br><span class="line">String::~<span class="built_in">String</span>(<span class="keyword">void</span>) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> [] m_data;</span><br><span class="line">    <span class="comment">// 由于m_data 是内部数据类型，也可以写成 delete m_data;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// String 的普通构造函数</span></span><br><span class="line">String::<span class="built_in">String</span>(<span class="keyword">const</span> <span class="keyword">char</span> *str) </span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Ordinary constructor is running&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 拷贝构造函数</span></span><br><span class="line">String::<span class="built_in">String</span>(<span class="keyword">const</span> String &amp;other) </span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Copy constructor is running&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	String  str1; </span><br><span class="line">	<span class="function">String  <span class="title">str2</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span></span>; </span><br><span class="line">	<span class="function">String  <span class="title">str3</span><span class="params">(str2)</span></span>; </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p> 上面代码编译和执行结果为：</p>
<img src="https://img-blog.csdnimg.cn/20191129172558212.png" alt="结果" style="zoom:80%;" />

 

<h2 id="4-常见的构造函数"><a href="#4-常见的构造函数" class="headerlink" title="4.常见的构造函数"></a>4.常见的构造函数</h2><h3 id="1）默认构造函数"><a href="#1）默认构造函数" class="headerlink" title="1）默认构造函数"></a>1）默认构造函数</h3><p>如果用户自己没有定义构造函数，那么编译器会自动生成一个默认构造函数，只是这个构造函数没有形参，函数体也是空的，不执行任何操作。例如：Student类的默认生成的构造函数如下：</p>
<p>​       <code> Student()&#123;&#125;</code></p>
<p>==一个类中必须有构造函数，要么用户自己定义，要么编译器自动生成。一旦用户自己定义了构造函数，不管几个，也不管形参如何，编译器都不再自动生成。==</p>
<p>调用不带参数的构造函数也可以省略括号。即创建对象Student stu()和Student stu是等价的。</p>
<h3 id="2）-拷贝构造函数"><a href="#2）-拷贝构造函数" class="headerlink" title="2） 拷贝构造函数"></a>2） 拷贝构造函数</h3><p>当以拷贝的方式初始化一个对象时，会调用一个特殊的构造函数，就是拷贝构造函数。拷贝构造函数的名称与类的名称一致，它必须的一个参数是本类型的一个引用变量。</p>
<p>注意，默认构造函数（即无参构造函数）不一定存在，但是拷贝构造函数总是会存在。</p>
<blockquote>
<p>拷贝构造函数常用的三种情况：</p>
<p>==①当用一个对象去初始化同类的另一个对象==。</p>
<p>例如：</p>
<p>​    A test_b(test_a);<br>​    A test_b = test_a;//这两条语句是等价的<br><strong>【注意】第二条语句是初始化语句，不是赋值语句。赋值语句的等号左边是一个早已有定义的变量，赋值语句不会引发拷贝构造函数的调用。</strong></p>
<pre><code>A test_a,test_b;
 test_b = test_a;//这句不会引发拷贝构造函数的调用，因为test_b早已生成，已经初始化过了
</code></pre>
<p>②==一个对象以值传递的方式传入函数体==，而调用拷贝构造函数时的参数，就是调用函数时所给的实参。</p>
<p>③==一个对象以值传递的方式从函数中返回==，而调用拷贝构造函数的参数，就是return语句所返回的对象。</p>
</blockquote>
<h4 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h4><p>浅拷贝是指在对象拷贝时，只对对象中的数据成员进行简单的赋值，默认拷贝构造函数执行的也是浅拷贝。大多数情况下“浅拷贝”可以很好的工作，但一旦对象存在动态成员，那么浅拷贝就会出问题。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rect</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Rect</span>()</span><br><span class="line">    &#123;</span><br><span class="line">     p=<span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	~<span class="built_in">Rect</span>()</span><br><span class="line">	&#123;</span><br><span class="line"> 		<span class="built_in">assert</span>(p!=<span class="literal">NULL</span>);</span><br><span class="line">    	<span class="keyword">delete</span> p;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> width;</span><br><span class="line">    <span class="keyword">int</span> height;</span><br><span class="line">    <span class="keyword">int</span> *p;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Rect rect1;</span><br><span class="line">    <span class="function">Rect <span class="title">rect2</span><span class="params">(rect1)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; 这段代码运行结束后，会出现运行错误。原因就在于在进行对象拷贝时，对于动态分配的内容没有正确的操作。</span><br></pre></td></tr></table></figure>

<p>原因分析：</p>
<p>在使用rect1复制rect2时，由于执行的是浅拷贝，只是将成员的值进行赋值，这时 rect1.p = rect2.p，也即这两个指针指向了堆里的同一个空间。</p>
<img src="https://img-blog.csdnimg.cn/20191129194029601.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phY2t5X0Zlbmc=,size_16,color_FFFFFF,t_70" alt="原因" style="zoom:80%;" />

<p> 在销毁对象时，两个对象的析构函数将对同一个内存空间释放两次，这就是错误出现的原因。我们需要的不是两个p有相同的值，而是两个p指向的空间有相同的值，解决办法就是使用“深拷贝”。</p>
<h4 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h4><p>深拷贝对于动态成员，并不是简单地复制，而是重新动态分配空间。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rect</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Rect</span>()</span><br><span class="line">    &#123;</span><br><span class="line">     p=<span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//深拷贝</span></span><br><span class="line">    <span class="built_in">Rect</span>(<span class="keyword">const</span> Rect&amp; r)</span><br><span class="line">    &#123;</span><br><span class="line">     width=r.width;</span><br><span class="line">        height=r.height;</span><br><span class="line">     p=<span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">100</span>);</span><br><span class="line">        *p=*(r.p);</span><br><span class="line">    &#125;</span><br><span class="line">~<span class="built_in">Rect</span>()</span><br><span class="line">&#123;</span><br><span class="line"> <span class="built_in">assert</span>(p!=<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> width;</span><br><span class="line">    <span class="keyword">int</span> height;</span><br><span class="line">    <span class="keyword">int</span> *p;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Rect rect1;</span><br><span class="line">    <span class="function">Rect <span class="title">rect2</span><span class="params">(rect1)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完成对象拷贝地过程为:</p>
<img src="https://img-blog.csdnimg.cn/2019112919463854.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phY2t5X0Zlbmc=,size_16,color_FFFFFF,t_70" alt="过程" style="zoom:80%;" />

<p> 此时rect1的p和rect2的p各自指向一段内存空间，但它们指向的空间具有相同的内容，这就是所谓的“深拷贝”。</p>
<blockquote>
<p>小结：</p>
<p><strong>拷贝构造函数有两种：深拷贝和浅拷贝</strong></p>
<p>当出现类的等号赋值时，会调用拷贝函数，在未定义显示拷贝构造函数的情况下，系统会调用默认的拷贝函数——即浅拷贝，它能够完成成员的一一复制。当数据成员中没有指针时，浅拷贝是可行的。但<strong>当数据成员中有指针</strong>时，如果采用简单的浅拷贝，则两类中的两个指针将指向同一个地址，当对象快结束时，会调用两次析构函数，而导致指针悬挂现象。所以，这时，必须采用深拷贝.</p>
<p>深拷贝与浅拷贝的区别就在于深拷贝会在堆内存中另外申请空间来储存数据，从而也就解决了指针悬挂的问题。<strong>简而言之，当数据成员中有指针时，必须要用深拷贝。</strong></p>
</blockquote>
<h2 id="5-综合实例分析"><a href="#5-综合实例分析" class="headerlink" title="5.综合实例分析"></a>5.综合实例分析</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CPoint</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//缺省构造函数,如果定义类时未指定任何构造函数，</span></span><br><span class="line">    <span class="comment">//系统将自动生成不带参数的缺省构造函数</span></span><br><span class="line">    <span class="built_in">CPoint</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;默认构造函数 &quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        x = <span class="number">0</span>;</span><br><span class="line">        y = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//带一个参数的可用于类型转换的构造函数</span></span><br><span class="line">	<span class="comment">//  explicit    //加上 explicit 可防止 CPoint pt1 = 1; 这种隐性转换</span></span><br><span class="line">    <span class="built_in">CPoint</span>(<span class="keyword">int</span> ix)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;1参数构造函数 &quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        x = ix;</span><br><span class="line">        y = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//带参数的构造函数</span></span><br><span class="line">	<span class="built_in">CPoint</span>(<span class="keyword">int</span> ix, <span class="keyword">int</span> iy)</span><br><span class="line">	&#123;</span><br><span class="line">    	cout &lt;&lt; <span class="string">&quot;2参数构造函数 &quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    	x = ix;</span><br><span class="line">   	 y = iy;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//拷贝构造函数,如果此函数不定义，系统将生成缺省拷贝构造函数功能,</span></span><br><span class="line">	<span class="comment">//缺省拷贝构造函数的行为是：用传入的对象参数的成员初始化正要建立的对象的相应成员</span></span><br><span class="line">	<span class="comment">//  explicit    //加上 explicit 可防止 CPoint pt2 = pt1; 这种隐性转换</span></span><br><span class="line">    <span class="built_in">CPoint</span>(<span class="keyword">const</span> CPoint &amp;cp)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;拷贝构造函数 &quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        x = cp.x;</span><br><span class="line">        y = cp.y;</span><br><span class="line">    &#125;</span><br><span class="line">    CPoint &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> CPoint &amp;cp)</span><br><span class="line">	&#123;</span><br><span class="line">    	cout &lt;&lt; <span class="string">&quot;赋值重载函数 &quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    	<span class="keyword">if</span> (<span class="keyword">this</span> != &amp;cp)</span><br><span class="line">    	&#123;</span><br><span class="line">       	 	x = cp.x;</span><br><span class="line">       	 	y = cp.y;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">return</span> (*<span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//析构函数，一个类中只能有一个析构函数,如果用户没有定义析构函数，</span></span><br><span class="line">	<span class="comment">//系统会自动未类生成一个缺省的析构函数</span></span><br><span class="line">	~<span class="built_in">CPoint</span>()</span><br><span class="line">	&#123;</span><br><span class="line">    	cout &lt;&lt; <span class="string">&quot;析构函数 &quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	CPoint &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> CPoint &amp;cp)</span><br><span class="line">	&#123;</span><br><span class="line">    	cout &lt;&lt; <span class="string">&quot;赋值重载函数 &quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    	<span class="keyword">if</span> (<span class="keyword">this</span> != &amp;cp)</span><br><span class="line">    	&#123;</span><br><span class="line">        	x = cp.x;</span><br><span class="line">        	y = cp.y;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">return</span> (*<span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//析构函数，一个类中只能有一个析构函数,如果用户没有定义析构函数，</span></span><br><span class="line">	<span class="comment">//系统会自动未类生成一个缺省的析构函数</span></span><br><span class="line">	~<span class="built_in">CPoint</span>()</span><br><span class="line">	&#123;</span><br><span class="line">    	cout &lt;&lt; <span class="string">&quot;析构函数 &quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">CPoint <span class="title">p0</span><span class="params">()</span></span>;        <span class="comment">//这是函数的声明，不是实例化类</span></span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; <span class="string">&quot;CPoint pt1;\t\t&quot;</span>;</span><br><span class="line">	CPoint pt1;         <span class="comment">//缺省构造函数</span></span><br><span class="line"> </span><br><span class="line">	cout &lt;&lt; endl &lt;&lt; <span class="string">&quot;CPoint pt2(1);\t\t&quot;</span>;</span><br><span class="line">	<span class="function">CPoint <span class="title">pt2</span><span class="params">(<span class="number">1</span>)</span></span>;      <span class="comment">//一个参数的构造函数</span></span><br><span class="line"> </span><br><span class="line">	cout &lt;&lt; endl &lt;&lt; <span class="string">&quot;CPoint pt3(1, 2);\t&quot;</span>;</span><br><span class="line">	<span class="function">CPoint <span class="title">pt3</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;   <span class="comment">//两个参数的构造函数</span></span><br><span class="line"> </span><br><span class="line">	cout &lt;&lt; endl &lt;&lt; <span class="string">&quot;CPoint pt4 = 1;\t\t&quot;</span>;</span><br><span class="line">	CPoint pt4 = <span class="number">1</span>;     <span class="comment">//等价于CPoint t4(1);  //explicit</span></span><br><span class="line"> </span><br><span class="line">	cout &lt;&lt; endl &lt;&lt; <span class="string">&quot;CPoint pt5 = t1;\t&quot;</span>;</span><br><span class="line">	CPoint pt5 = pt1;   <span class="comment">//CPoint(t1);</span></span><br><span class="line"> </span><br><span class="line">	cout &lt;&lt; endl &lt;&lt; <span class="string">&quot;CPoint pt6 = CPoint();\t&quot;</span>;</span><br><span class="line">	CPoint pt6 = <span class="built_in">CPoint</span>();  <span class="comment">//CPoint(1); CPoint(1,2);</span></span><br><span class="line"> </span><br><span class="line">	cout &lt;&lt; endl &lt;&lt; <span class="string">&quot;pt6 = CPoint(1);\t&quot;</span>;</span><br><span class="line">	pt6 = <span class="built_in">CPoint</span>(<span class="number">1</span>);</span><br><span class="line"> </span><br><span class="line">	cout &lt;&lt; endl &lt;&lt; <span class="string">&quot;pt6 = 1;\t\t&quot;</span>;</span><br><span class="line">	pt6 = <span class="number">1</span>;            <span class="comment">//首先调用单个参数的构造函数，生成临时对象CPoint(1), 然后调用赋值运算符函数</span></span><br><span class="line"> </span><br><span class="line">	cout &lt;&lt; endl &lt;&lt; <span class="string">&quot;pt6 = t1;\t\t&quot;</span>;</span><br><span class="line">	pt6 = pt1;          <span class="comment">//调用赋值运算符函数</span></span><br><span class="line"> </span><br><span class="line">	cout &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码编译和执行结果如下：</p>
<img src="https://img-blog.csdnimg.cn/2019112918062265.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phY2t5X0Zlbmc=,size_16,color_FFFFFF,t_70" alt="执行结果" style="zoom:80%;" />



<blockquote>
<p>————————————————<br>版权声明：本文为CSDN博主「Jacky_Feng」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/Jacky_Feng/article/details/103313208">https://blog.csdn.net/Jacky_Feng/article/details/103313208</a></p>
</blockquote>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title>欧拉筛法</title>
    <url>/2020/07/21/euler-prime/</url>
    <content><![CDATA[<h1 id="欧拉筛法"><a href="#欧拉筛法" class="headerlink" title="欧拉筛法"></a>欧拉筛法</h1><blockquote>
<p>原创程画 最后发布于2018-05-15 18:24:08 阅读数 4146  收藏</p>
</blockquote>
<p>想看欧拉筛法的可直接拉到最后。</p>
<p>相信各位对素数并不陌生，素数就是指不能被除了1和自身以外的别的数整除的数，比如2,3,5，而且根据欧几里得的证明来看，素数是无限的，普通的筛选素数的方法可能对较小的数据能在较短时间内完成筛选，但对于很大的数据（比如1e9）就会花费很长的时间。</p>
<span id="more"></span>

<h2 id="1-普通的求素数方法"><a href="#1-普通的求素数方法" class="headerlink" title="1.普通的求素数方法"></a>1.普通的求素数方法</h2><p>例如，普通的求素数方法时这样的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> pri[MAXN];</span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prime</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cnt=<span class="number">0</span>;</span><br><span class="line">	pri[cnt++]=<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">int</span> i,j;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">3</span>;i&lt;=n;++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">2</span>;j&lt;i;++j)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(i%j!=<span class="number">0</span>)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(j&gt;=i)</span><br><span class="line">			pri[cnt++]=i;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>根据素数的定义所写的代码很容易理解，但是运行的效率是不太优秀的，所以我们要改进，当然在学习的过程中相信大家也或多或少的学了些改进方法，一个简单的改进方法就是将第二个循环的结束条件改为j&lt;sqrt(i)，相应地再更改判断条件，这样当然可以减少我们运行所需要的时间，但是任然不够好，下面我们就来介绍一下埃式筛法和今天的真正目标——欧拉筛法。</p>
<h2 id="2-埃式筛法"><a href="#2-埃式筛法" class="headerlink" title="2.埃式筛法"></a>2.埃式筛法</h2><p>先来介绍埃式筛法，埃式筛法的基本思想就是，当我们遍历到一个素数时，把所有该素数的倍数（自然是合数）都筛选出来，我们来看看代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> prime[MAXN];</span><br><span class="line"><span class="keyword">bool</span> vis[MAXN];</span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Era_prime</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(!vis[i])</span><br><span class="line">			prime[cnt++]=i;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;=n;j+=i)</span><br><span class="line">		&#123;</span><br><span class="line">			vis[j]=<span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们有没被选过的素数时，加入素数数组prime并且将它的所有n以内的倍数给筛选出来（vis[j]=true），埃式筛法很容易理解，并且在效率上也比较优秀，时间复杂度为O(nlglgn)，但是在处理1e8以上的数据时，还是稍稍力不从心，所以接下来我们着重介绍下线性时间筛法——欧拉筛法，我们还是先来看下代码：</p>
<h2 id="3-欧拉筛法"><a href="#3-欧拉筛法" class="headerlink" title="3.欧拉筛法"></a>3.欧拉筛法</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> prime[MAXN];</span><br><span class="line"><span class="keyword">bool</span> vis[MAXN];</span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Euler_prime</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(!vis[i])</span><br><span class="line">		&#123;prime[cnt++]=i;vis[i]=<span class="literal">true</span>;&#125;<span class="comment">//vis[i]置为true或不置true都可以</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;cnt;++j)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(i*prime[j]&gt;n)<span class="comment">//判断是否越界</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			vis[i*prime[j]]=<span class="literal">true</span>;<span class="comment">//筛数</span></span><br><span class="line">			<span class="keyword">if</span>(i%prime[j]==<span class="number">0</span>)<span class="comment">//时间复杂度为O(n)的关键！</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>我们注意到，在用埃式筛法的同时，同一个数字也许会被筛选多次，比如6先被2筛选一次，再被3筛选一次，这样就浪费了很多不必要的时间，而欧拉筛法通过<code>if(i%prime[j]==0)break;</code>这一步就避免了重复筛选的发生，我们举个例子，比如，2先筛选了4，然后进行下一个循环，3筛选6和9，当我们执行到4的时候，可以发现，当<code>i==4</code>时，第一次运行到<code>if(i%prime[j]==0)</code>这一步的时候就直接<code>break;</code>掉了，这也就是说，当我们的合数进入循环时，其实它已经被之前的数筛选过了，所以当合数进入内层循环时，内层循环只执行了一次，从而减少了时间复杂度。</p>
<p>结束</p>
<blockquote>
<p>————————————————<br>版权声明：本文为CSDN博主「程画」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/chczy1/java/article/details/80327323">https://blog.csdn.net/chczy1/java/article/details/80327323</a></p>
</blockquote>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>转载</tag>
      </tags>
  </entry>
</search>
