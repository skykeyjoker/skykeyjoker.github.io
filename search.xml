<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>欧拉筛法</title>
    <url>/2020/07/21/euler-prime/</url>
    <content><![CDATA[<h1 id="欧拉筛法"><a href="#欧拉筛法" class="headerlink" title="欧拉筛法"></a>欧拉筛法</h1><blockquote>
<p>原创程画 最后发布于2018-05-15 18:24:08 阅读数 4146  收藏</p>
</blockquote>
<p>想看欧拉筛法的可直接拉到最后。</p>
<p>相信各位对素数并不陌生，素数就是指不能被除了1和自身以外的别的数整除的数，比如2,3,5，而且根据欧几里得的证明来看，素数是无限的，普通的筛选素数的方法可能对较小的数据能在较短时间内完成筛选，但对于很大的数据（比如1e9）就会花费很长的时间。</p>
<span id="more"></span>

<h2 id="1-普通的求素数方法"><a href="#1-普通的求素数方法" class="headerlink" title="1.普通的求素数方法"></a>1.普通的求素数方法</h2><p>例如，普通的求素数方法时这样的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> pri[MAXN];</span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prime</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cnt=<span class="number">0</span>;</span><br><span class="line">	pri[cnt++]=<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">int</span> i,j;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">3</span>;i&lt;=n;++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">2</span>;j&lt;i;++j)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(i%j!=<span class="number">0</span>)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(j&gt;=i)</span><br><span class="line">			pri[cnt++]=i;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>根据素数的定义所写的代码很容易理解，但是运行的效率是不太优秀的，所以我们要改进，当然在学习的过程中相信大家也或多或少的学了些改进方法，一个简单的改进方法就是将第二个循环的结束条件改为j&lt;sqrt(i)，相应地再更改判断条件，这样当然可以减少我们运行所需要的时间，但是任然不够好，下面我们就来介绍一下埃式筛法和今天的真正目标——欧拉筛法。</p>
<h2 id="2-埃式筛法"><a href="#2-埃式筛法" class="headerlink" title="2.埃式筛法"></a>2.埃式筛法</h2><p>先来介绍埃式筛法，埃式筛法的基本思想就是，当我们遍历到一个素数时，把所有该素数的倍数（自然是合数）都筛选出来，我们来看看代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> prime[MAXN];</span><br><span class="line"><span class="keyword">bool</span> vis[MAXN];</span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Era_prime</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(!vis[i])</span><br><span class="line">			prime[cnt++]=i;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;=n;j+=i)</span><br><span class="line">		&#123;</span><br><span class="line">			vis[j]=<span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们有没被选过的素数时，加入素数数组prime并且将它的所有n以内的倍数给筛选出来（vis[j]=true），埃式筛法很容易理解，并且在效率上也比较优秀，时间复杂度为O(nlglgn)，但是在处理1e8以上的数据时，还是稍稍力不从心，所以接下来我们着重介绍下线性时间筛法——欧拉筛法，我们还是先来看下代码：</p>
<h2 id="3-欧拉筛法"><a href="#3-欧拉筛法" class="headerlink" title="3.欧拉筛法"></a>3.欧拉筛法</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> prime[MAXN];</span><br><span class="line"><span class="keyword">bool</span> vis[MAXN];</span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Euler_prime</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(!vis[i])</span><br><span class="line">		&#123;prime[cnt++]=i;vis[i]=<span class="literal">true</span>;&#125;<span class="comment">//vis[i]置为true或不置true都可以</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;cnt;++j)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(i*prime[j]&gt;n)<span class="comment">//判断是否越界</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			vis[i*prime[j]]=<span class="literal">true</span>;<span class="comment">//筛数</span></span><br><span class="line">			<span class="keyword">if</span>(i%prime[j]==<span class="number">0</span>)<span class="comment">//时间复杂度为O(n)的关键！</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>我们注意到，在用埃式筛法的同时，同一个数字也许会被筛选多次，比如6先被2筛选一次，再被3筛选一次，这样就浪费了很多不必要的时间，而欧拉筛法通过<code>if(i%prime[j]==0)break;</code>这一步就避免了重复筛选的发生，我们举个例子，比如，2先筛选了4，然后进行下一个循环，3筛选6和9，当我们执行到4的时候，可以发现，当<code>i==4</code>时，第一次运行到<code>if(i%prime[j]==0)</code>这一步的时候就直接<code>break;</code>掉了，这也就是说，当我们的合数进入循环时，其实它已经被之前的数筛选过了，所以当合数进入内层循环时，内层循环只执行了一次，从而减少了时间复杂度。</p>
<p>结束</p>
<blockquote>
<p>————————————————<br>版权声明：本文为CSDN博主「程画」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/chczy1/java/article/details/80327323">https://blog.csdn.net/chczy1/java/article/details/80327323</a></p>
</blockquote>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下CMake使用</title>
    <url>/2020/07/21/cmake/</url>
    <content><![CDATA[<h1 id="Linux下CMake使用方法"><a href="#Linux下CMake使用方法" class="headerlink" title="Linux下CMake使用方法"></a>Linux下CMake使用方法</h1><p>在 linux 平台下使用 CMake 生成 Makefile 并编译的流程如下：</p>
<ol>
<li>编写 CMake 配置文件 CMakeLists.txt 。</li>
<li>执行命令 <code>cmake PATH</code> 或者 <code>ccmake PATH</code> 生成 Makefile 1 1<code>ccmake</code> 和 <code>cmake</code> 的区别在于前者提供了一个交互式的界面。。其中， <code>PATH</code> 是 CMakeLists.txt 所在的目录。</li>
<li>使用 <code>make</code> 命令进行编译。</li>
</ol>
<p>本文将从实例入手，一步步讲解 CMake 的常见用法，文中所有的实例代码可以在<a href="https://github.com/wzpan/cmake-demo">这里</a>找到。如果你读完仍觉得意犹未尽，可以继续学习我在文章末尾提供的其他资源。</p>
<span id="more"></span>

<h2 id="1-单个源文件"><a href="#1-单个源文件" class="headerlink" title="1.单个源文件"></a>1.单个源文件</h2><p>对于简单的项目，只需要写几行代码就可以了。例如，假设现在我们的项目中只有一个源文件 <a href="http://main.cc/">main.c</a> ，首先编写 CMakeLists.txt 文件，并保存在与 <a href="http://main.cc/">main.c</a> 源文件同个目录下：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># CMake 最低版本号要求</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span> (VERSION <span class="number">2.8</span>)</span><br><span class="line"><span class="comment"># 项目信息</span></span><br><span class="line"><span class="keyword">project</span> (Demo1)</span><br><span class="line"><span class="comment"># 指定生成目标</span></span><br><span class="line"><span class="keyword">add_executable</span>(Demo1 main.cc)</span><br></pre></td></tr></table></figure>

<p>CMakeLists.txt 的语法比较简单，由命令、注释和空格组成，其中命令是不区分大小写的。符号 <code>#</code> 后面的内容被认为是注释。命令由命令名称、小括号和参数组成，参数之间使用空格进行间隔。</p>
<p>对于上面的 ==CMakeLists.txt== 文件，依次出现了几个命令：</p>
<ol>
<li><code>cmake_minimum_required</code>：指定运行此配置文件所需的 CMake 的最低版本；</li>
<li><code>project</code>：参数值是 <code>Demo1</code>，该命令表示项目的名称是 <code>Demo1</code> 。</li>
<li><code>add_executable</code>： 将名为 <a href="http://main.cc/">main.c</a> 的源文件编译成一个名称为 Demo 的可执行文件。</li>
</ol>
<p>之后，在当前目录执行 <strong><code>cmake .</code></strong> ，得到 Makefile 后再使用 <strong><code>make</code></strong> 命令编译得到 Demo1 可执行文件。</p>
<h2 id="2-多个源文件"><a href="#2-多个源文件" class="headerlink" title="2.多个源文件"></a>2.多个源文件</h2><h3 id="1-同一目录，多个源文件"><a href="#1-同一目录，多个源文件" class="headerlink" title="1) 同一目录，多个源文件"></a>1) 同一目录，多个源文件</h3><p>上面的例子只有单个源文件。现在假如把 <code>power</code> 函数单独写进一个名为 <code>MathFunctions.c</code> 的源文件里，使得这个工程变成如下的形式：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">./Demo2</span><br><span class="line">    |</span><br><span class="line">    +--- main.cc</span><br><span class="line">    |</span><br><span class="line">    +--- MathFunctions.cc</span><br><span class="line">    |</span><br><span class="line">    +--- MathFunctions.h</span><br></pre></td></tr></table></figure>

<p>这个时候，CMakeLists.txt 可以改成如下的形式：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># CMake 最低版本号要求</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span> (VERSION <span class="number">2.8</span>)</span><br><span class="line"><span class="comment"># 项目信息</span></span><br><span class="line"><span class="keyword">project</span> (Demo2)</span><br><span class="line"><span class="comment"># 指定生成目标</span></span><br><span class="line"><span class="keyword">add_executable</span>(Demo main.cc MathFunctions.cc)</span><br></pre></td></tr></table></figure>

<p>唯一的改动只是在 <strong><code>add_executable</code></strong> 命令中增加了一个 <strong><code>MathFunctions.cc</code></strong> 源文件。这样写当然没什么问题，但是如果源文件很多，把所有源文件的名字都加进去将是一件烦人的工作。更省事的方法是使用 <strong><code>aux_source_directory</code></strong> 命令，该命令会查找指定目录下的所有源文件，然后将结果存进指定变量名。其语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">aux_source_directory(&lt;dir&gt; &lt;variable&gt;)</span><br></pre></td></tr></table></figure>

<p>因此，可以修改 CMakeLists.txt 如下：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># CMake 最低版本号要求</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span> (VERSION <span class="number">2.8</span>)</span><br><span class="line"><span class="comment"># 项目信息</span></span><br><span class="line"><span class="keyword">project</span> (Demo2)</span><br><span class="line"><span class="comment"># 查找当前目录下的所有源文件</span></span><br><span class="line"><span class="comment"># 并将名称保存到 DIR_SRCS 变量</span></span><br><span class="line"><span class="keyword">aux_source_directory</span>(. DIR_SRCS)</span><br><span class="line"><span class="comment"># 指定生成目标</span></span><br><span class="line"><span class="keyword">add_executable</span>(Demo <span class="variable">$&#123;DIR_SRCS&#125;</span>)</span><br></pre></td></tr></table></figure>

<p>这样，CMake 会将当前目录所有源文件的文件名赋值给变量 <code>DIR_SRCS</code> ，再指示变量 <code>DIR_SRCS</code> 中的源文件需要编译成一个名称为 Demo 的可执行文件。</p>
<h3 id="2-多个目录，多个源文件"><a href="#2-多个目录，多个源文件" class="headerlink" title="2) 多个目录，多个源文件"></a>2) 多个目录，多个源文件</h3><p>现在进一步将 MathFunctions.h 和 <a href="http://mathfunctions.cc/">MathFunctions.cc</a> 文件移动到 math 目录下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./Demo3</span><br><span class="line">    |</span><br><span class="line">    +--- main.cc</span><br><span class="line">    |</span><br><span class="line">    +--- math/</span><br><span class="line">          |</span><br><span class="line">          +--- MathFunctions.cc</span><br><span class="line">          |</span><br><span class="line">          +--- MathFunctions.h</span><br></pre></td></tr></table></figure>

<p>于这种情况，需要分别在项目根目录 Demo3 和 math 目录里各编写一个 CMakeLists.txt 文件。为了方便，我们可以先将 math 目录里的文件编译成静态库再由 main 函数调用。</p>
<p>根目录中的 CMakeLists.txt ：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># CMake 最低版本号要求</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span> (VERSION <span class="number">2.8</span>)</span><br><span class="line"><span class="comment"># 项目信息</span></span><br><span class="line"><span class="keyword">project</span> (Demo3)</span><br><span class="line"><span class="comment"># 查找当前目录下的所有源文件</span></span><br><span class="line"><span class="comment"># 并将名称保存到 DIR_SRCS 变量</span></span><br><span class="line"><span class="keyword">aux_source_directory</span>(. DIR_SRCS)</span><br><span class="line"><span class="comment"># 添加 math 子目录</span></span><br><span class="line"><span class="keyword">add_subdirectory</span>(<span class="keyword">math</span>)</span><br><span class="line"><span class="comment"># 指定生成目标 </span></span><br><span class="line"><span class="keyword">add_executable</span>(Demo main.cc)</span><br><span class="line"><span class="comment"># 添加链接库</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(Demo MathFunctions)</span><br></pre></td></tr></table></figure>

<p>该文件添加了下面的内容: 第3行，使用命令 <strong><code>add_subdirectory</code></strong> 指明本项目包含一个子目录 math，这样 <strong>math 目录下的 CMakeLists.txt 文件和源代码也会被处理</strong> 。第6行，使用命令 <strong><code>target_link_libraries</code></strong> 指明可执行文件 main 需要连接一个名为 MathFunctions 的链接库 。</p>
<p>==子目录中的 CMakeLists.txt==：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查找当前目录下的所有源文件</span></span><br><span class="line"><span class="comment"># 并将名称保存到 DIR_LIB_SRCS 变量</span></span><br><span class="line"><span class="keyword">aux_source_directory</span>(. DIR_LIB_SRCS)</span><br><span class="line"><span class="comment"># 生成链接库</span></span><br><span class="line"><span class="keyword">add_library</span> (MathFunctions <span class="variable">$&#123;DIR_LIB_SRCS&#125;</span>)</span><br></pre></td></tr></table></figure>

<p>在该文件中使用命令 <code>add_library</code> 将 src 目录中的源文件编译为静态链接库。</p>
<h2 id="3-正规一点的组织结构"><a href="#3-正规一点的组织结构" class="headerlink" title="3.正规一点的组织结构"></a>3.正规一点的组织结构</h2><p>正规一点来说，一般会把源文件放到<strong>src</strong>目录下，把头文件放入到<strong>include</strong>文件下，生成的对象文件放入到<strong>build</strong>目录下，最终输出的elf文件会放到<strong>bin</strong>目录下，这样整个结构更加清晰。让我们把前面的文件再次重新组织下，</p>
<p>我们在最外层目录下新建一个CMakeLists.txt，内容如下，</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span> (VERSION <span class="number">2.8</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span> (demo)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_subdirectory</span> (src)</span><br></pre></td></tr></table></figure>

<p>这里出现一个新的命令<code>add_subdirectory()</code>，这个命令==可以向当前工程添加存放源文件的子目录，并可以指定中间二进制和目标二进制的存放位置==，具体用法可以百度。<br>这里指定src目录下存放了源文件，当执行cmake时，就会进入src目录下去找src目录下的CMakeLists.txt，所以在<strong>src目录</strong>下也建立一个<strong>CMakeLists.txt</strong>，内容如下，</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">aux_source_directory</span> (. SRC_LIST)</span><br><span class="line"></span><br><span class="line"><span class="keyword">include_directories</span> (../<span class="keyword">include</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span> (main <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> (EXECUTABLE_OUTPUT_PATH <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/bin)</span><br></pre></td></tr></table></figure>


<p>这里又出现一个新的命令<code>set</code>，是用于定义变量的，<code>EXECUTABLE_OUT_PATH</code>和<code>PROJECT_SOURCE_DIR</code>是CMake自带的预定义变量，其意义如下，</p>
<blockquote>
<p><strong>EXECUTABLE_OUTPUT_PATH</strong> ：目标二进制可执行文件的存放位置<br><strong>PROJECT_SOURCE_DIR</strong>：工程的根目录</p>
</blockquote>
<p>所以，这里set的意思是把存放elf文件的位置设置为工程根目录下的bin目录。</p>
<p>添加好以上这2个CMakeLists.txt后，整体文件结构如下，</p>
<p>下面来运行cmake，不过这次先让我们切到build目录下，然后输入以下命令，<br><code>cmake ..</code><br>Makefile会在build目录下生成，然后在build目录下运行make，</p>
<p>运行ok，我们再切到bin目录下，发现main已经生成，并运行测试，</p>
<p>测试OK！</p>
<blockquote>
<p>这里解释一下为什么在build目录下运行cmake？从前面几个case中可以看到，如果不这样做，cmake运行时生成的附带文件就会跟源码文件混在一起，这样会对程序的目录结构造成污染，而在build目录下运行cmake，生成的附带文件就只会待在build目录下，如果我们不想要这些文件了就可以直接清空build目录，非常方便。</p>
</blockquote>
<p>另外一种写法：<br>前面的工程使用了2个CMakeLists.txt，这种写法是为了处理需要生成多个elf文件的情况，最外层的CMakeLists.txt用于掌控全局，使用<code>add_subdirectory</code>来添加要生成elf文件的源码目录。</p>
<p>如果只生成一个elf文件，那么上面的例子可以只使用一个CMakeLists.txt，可以把最外层的CMakeLists.txt内容改成如下，</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span> (VERSION <span class="number">2.8</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span> (demo)</span><br><span class="line"></span><br><span class="line"><span class="keyword">aux_source_directory</span> (src SRC_LIST)</span><br><span class="line"></span><br><span class="line"><span class="keyword">include_directories</span> (<span class="keyword">include</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span> (main <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> (EXECUTABLE_OUTPUT_PATH <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/bin)</span><br></pre></td></tr></table></figure>

<p>==同时，还要把src目录下的CMakeLists.txt删除。==</p>
<h2 id="4-动态库和静态库的编译控制"><a href="#4-动态库和静态库的编译控制" class="headerlink" title="4.动态库和静态库的编译控制"></a>4.动态库和静态库的编译控制</h2><p>有时我们只需要编译出动态库，静态库，然后等着让其它程序去使用。让我们看下这种情况该如何使用cmake。首先按照如下重新组织文件，只留下testFunc.h和TestFunc.c，</p>
<p>我们会在build目录下运行cmake，并把生成的库文件存放到lib目录下。<br><strong>最外层</strong>的CMakeLists.txt内容如下，</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span> (VERSION <span class="number">2.8</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span> (demo)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_subdirectory</span> (lib_testFunc)</span><br></pre></td></tr></table></figure>

<p><strong>lib_testFunc</strong>目录下的CMakeLists.txt如下，</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">aux_source_directory</span> (. SRC_LIST)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_library</span> (testFunc_shared SHARED <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br><span class="line"><span class="keyword">add_library</span> (testFunc_static STATIC <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set_target_properties</span> (testFunc_shared PROPERTIES OUTPUT_NAME <span class="string">&quot;testFunc&quot;</span>)</span><br><span class="line"><span class="keyword">set_target_properties</span> (testFunc_static PROPERTIES OUTPUT_NAME <span class="string">&quot;testFunc&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> (LIBRARY_OUTPUT_PATH <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/lib)</span><br></pre></td></tr></table></figure>

<p>这里又出现了新的命令和预定义变量，</p>
<blockquote>
<p><strong>add_library</strong>: 生成动态库或静态库(第1个参数指定库的名字；第2个参数决定是动态还是静态，如果没有就默认静态；第3个参数指定生成库的源文件)<br><strong>set_target_properties</strong>: 设置输出的名称，还有其它功能，如设置库的版本号等等<br>LIBRARY_OUTPUT_PATH: 库文件的默认输出路径，这里设置为工程目录下的lib目录<br>好了，让我们进入build目录下运行cmake ..，成功后再运行make，</p>
</blockquote>
<p>cd到lib目录下进行查看，发现已经成功生成了动态库和静态库，</p>
<blockquote>
<p>ps：可以看出前面使用<code>set_target_properties</code>重新定义了库的输出名字，如果不用<code>set_target_properties</code>也可以，那么库的名字就是<strong>add_library</strong>里定义的名字，只是我们连续2次使用add_library指定库名字时，这个名字不能相同，而<code>set_target_properties</code>可以把名字设置为相同，只是最终生成的库文件后缀不同，这样相对来说会好看点。</p>
</blockquote>
<h2 id="5-对库进行链接"><a href="#5-对库进行链接" class="headerlink" title="5.对库进行链接"></a>5.对库进行链接</h2><p>既然我们已经生成了库，那么就进行链接测试下。把build里的文件都删除，然后在在工程目录下新建src目录和bin目录，在src目录下添加一个main.c和一个CMakeLists.txt，整体结构如下，</p>
<p><img src="https://img-blog.csdn.net/20180827221422465?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3doYWh1MTk4OQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<p><strong>main.c</strong>内容如下，</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;testFunc.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    func(<span class="number">100</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>修改工程目录下的CMakeLists.txt</strong>，如下，</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span> (VERSION <span class="number">2.8</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span> (demo)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_subdirectory</span> (lib_testFunc)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_subdirectory</span> (src)</span><br></pre></td></tr></table></figure>

<p>只是使用<code>add_subdirectory</code>把<strong>src</strong>目录添加进来。<br><strong>src</strong>目录下的CMakeLists.txt如下，</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">aux_source_directory</span> (. SRC_LIST)</span><br><span class="line"><span class="comment"># find testFunc.h</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">include_directories</span> (../lib_testFunc)</span><br><span class="line"></span><br><span class="line"><span class="keyword">link_directories</span> (<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/lib)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span> (main <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span> (main testFunc)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> (EXECUTABLE_OUTPUT_PATH <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/bin)</span><br></pre></td></tr></table></figure>


<p>这里出现2个新的命令，</p>
<blockquote>
<p><code>link_directories</code>: 添加非标准的共享库搜索路径<br><code>target_link_libraries</code>: 把目标文件与库文件进行链接</p>
</blockquote>
<p>make成功，进入到bin目录下查看，发现main已经生成，并运行，</p>
<p>运行成功！</p>
<blockquote>
<p>ps：在lib目录下有testFunc的静态库和动态库，<code>target_link_libraries (main testFunc)</code>默认是使用动态库，如果lib目录下只有静态库，那么这种写法就会去链接静态库。也可以直接指定使用动态库还是静态库，写法是：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">target_link_libraries</span> (main libtestFunc.so)</span><br><span class="line"><span class="comment">#或</span></span><br><span class="line"><span class="keyword">target_link_libraries</span> (main libtestFunc.a)</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>ps： 查看elf文件使用了哪些库，可以使用<code>readelf -d ./xx</code>来查看</p>
</blockquote>
<h2 id="6-添加编译选项"><a href="#6-添加编译选项" class="headerlink" title="6.添加编译选项"></a>6.添加编译选项</h2><p>有时编译程序时想添加一些编译选项，如<code>-Wall</code>，<code>-std=c++11</code>等，就可以使用<code>add_compile_options</code>来进行操作。<br>这里以一个简单程序来做演示，main.cpp如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> data = <span class="number">100</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;data: &quot;</span> &lt;&lt; data &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>CMakeLists.txt内容如下，</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span> (VERSION <span class="number">2.8</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span> (demo)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> (EXECUTABLE_OUTPUT_PATH <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/bin)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_compile_options</span>(-std=c++<span class="number">11</span> -Wall) </span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(main main.cpp)</span><br></pre></td></tr></table></figure>


<p>整体目录结构如下，</p>
<p><img src="https://img-blog.csdnimg.cn/20190718210743197.png" alt="在这里插入图片描述"></p>
<p>然后cd到build目录下，执行<code>cmake .. &amp;&amp; make</code>命令，就可以在bin目录下得到main的elf文件</p>
<h2 id="7-添加控制选项"><a href="#7-添加控制选项" class="headerlink" title="7. 添加控制选项"></a>7. 添加控制选项</h2><p>有时希望在<strong>编译代码时只编译一些指定的源码</strong>，例如本来要编译生成多个bin或库文件，现在<strong>只想生成某些指定的bin或库文件</strong>，这时可以使用cmake的<strong>option</strong>命令。</p>
<p>这里仍然使用例子来解释，假设我们现在的工程会生成2个bin文件，main1和main2，现在整体结构体如下，</p>
<p><img src="https://img-blog.csdnimg.cn/20190811114036435.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3doYWh1MTk4OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>外层的CMakeLists.txt内容如下，</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">2.8</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span>(demo)</span><br><span class="line"></span><br><span class="line"><span class="keyword">option</span>(MYDEBUG <span class="string">&quot;enable debug compilation&quot;</span> <span class="keyword">OFF</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> (EXECUTABLE_OUTPUT_PATH <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/bin)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_subdirectory</span>(src)</span><br></pre></td></tr></table></figure>


<p>这里使用了<code>option</code>命令，其第一个参数是这个option的名字，第二个参数是字符串，用来描述这个option是来干嘛的，第三个是option的值，ON或OFF，也可以不写，不写就是默认OFF。</p>
<p>然后编写src目录下的CMakeLists.txt，如下</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span> (VERSION <span class="number">2.8</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(main1 main1.c)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (MYDEBUG)</span><br><span class="line">    <span class="keyword">add_executable</span>(main2 main2.c)</span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line">    <span class="keyword">message</span>(STATUS <span class="string">&quot;Currently is not in debug mode&quot;</span>)    </span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>

<p>注意，这里使用了<code>if-else</code>来根据option来决定是否编译main2.c<br>其中main1.c和main2.c的内容如下，</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main1.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello, this main1\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main2.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello, this main2\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>然后cd到build目录下输入<code>cmake .. &amp;&amp; make</code>就可以只编译出main1，如果想编译出main2，就把<code>MYDEBUG</code>设置为<strong>ON</strong>，再次输入<code>cmake .. &amp;&amp; make</code>重新编译。</p>
<p>每次想改变MYDEBUG时都需要去修改CMakeLists.txt，有点麻烦，其实可以通过cmake的命令行去操作，例如我们想把MYDEBUG设置为OFF，先cd到build目录，然后输入<code>cmake .. -DMYDEBUG=ON</code>，这样就可以编译出main1和main2 （在bin目录下）</p>
<blockquote>
<p>来源：<a href="https://blog.csdn.net/qq_28114615/article/details/90406140">https://blog.csdn.net/qq_28114615/article/details/90406140</a></p>
</blockquote>
<p><em>2020.3.29 19:01</em></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>转载</tag>
        <tag>linux</tag>
        <tag>cmake</tag>
      </tags>
  </entry>
  <entry>
    <title>C++日期与时间编程（C++11-C++17）</title>
    <url>/2021/05/19/C++%E6%97%A5%E6%9C%9F%E4%B8%8E%E6%97%B6%E9%97%B4%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="C-日期与时间编程（C-11-C-17）"><a href="#C-日期与时间编程（C-11-C-17）" class="headerlink" title="C++日期与时间编程（C++11-C++17）"></a>C++日期与时间编程（C++11-C++17）</h1><h2 id="0x00-导言"><a href="#0x00-导言" class="headerlink" title="0x00 导言"></a>0x00 导言</h2><p>日期和时间是在编程中常常接触到的东西，而C++也为程序员提供了强（复）大（杂）的日期和时间编程的相关支持。在C++20标准中，C++的<code>chrono</code>库继C++11标准后也迎来了空前绝后大更新，但本文讨论的重点主要集中在C++11至C++17标准中日期和时间相关的内容，C++20标准中的<code>chrono</code>新东西完全可以另开一个坑。</p>
<p>在翻了N篇cppreference标准、chrome爽吃我800Mb的内存之后，我果断决定把这次的学习心得记下来，以防以后全部忘光光（实在太多了.jpg）。本片学习心得纯新手向，求大佬轻喷。</p>
<span id="more"></span>

<h2 id="0x01-概论"><a href="#0x01-概论" class="headerlink" title="0x01 概论"></a>0x01 概论</h2><p>先给两个例子：</p>
<ol>
<li>获取当前时间</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 实现1 **/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">time_t</span> now = <span class="built_in">time</span>(<span class="literal">nullptr</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Now is: &quot;</span> &lt;&lt; <span class="built_in">ctime</span>(&amp;now);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 实现2 **/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> now = chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line">	<span class="keyword">time_t</span> time = chrono::system_clock::<span class="built_in">to_time_t</span>(now);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Now is: &quot;</span> &lt;&lt; <span class="built_in">ctime</span>(&amp;time) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>计算时间差</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 实现1 **/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">time_t</span> time1 = <span class="built_in">time</span>(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000000</span>; i++) &#123;</span><br><span class="line">  		sum += <span class="built_in">sqrt</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">time_t</span> time2 = <span class="built_in">time</span>(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">double</span> time_diff = <span class="built_in">difftime</span>(time2, time1);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;time1: &quot;</span> &lt;&lt; time1 &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;time2: &quot;</span> &lt;&lt; time2 &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;time_diff: &quot;</span> &lt;&lt; time_diff &lt;&lt; <span class="string">&quot;s&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 实现2 **/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> start = chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line">	<span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000000</span>; i++) &#123;</span><br><span class="line">    	sum += <span class="built_in">sqrt</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">auto</span> end = chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">auto</span> time_diff = end - start;</span><br><span class="line">	<span class="keyword">auto</span> duration = chrono::duration_cast&lt;chrono::seconds&gt;(time_diff);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Operation cost : &quot;</span> &lt;&lt; duration.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot;s&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上文的两个要求都分别给出了两种实现方法，那接下来要说的事情已经显而易见了：</p>
<p><strong>C++给出了两类日期时间API，分别是：</strong></p>
<ul>
<li>C-Style日期时间库，主要位于<code>&lt;ctime&gt;</code>头文件（原C语言<code>&lt;time.h&gt;</code>头文件的C++版本）中。</li>
<li><code>chrono</code>库：C++11新增的API。</li>
</ul>
<p>在C++11引入<code>chrono</code>库之前，C++程序员只能使用C-Style的日期时间库。然而，C-Style日期时间库有着鲜明的缺点：<strong>精度只有秒级别</strong>（当时），这对于对时间有着高精度要求的程序来说是完全不够用的。而C++11引入的<code>chrono</code>库解决了这个问题，它极大地扩展了对精度的支持。当然，针对习惯C-Style日期时间库的程序员来说，C++17也进行了精度的扩充，详情请见下文。</p>
<p>本文也会分为C-Style和<code>chrono</code>两个板块进行讲解。</p>
<h2 id="0x02-必备的知识"><a href="#0x02-必备的知识" class="headerlink" title="0x02 必备的知识"></a>0x02 必备的知识</h2><p>在正式进入日期时间库的讨论之前，我们应该先复习一下与日期时间相关的必要知识。</p>
<h3 id="UTC时间"><a href="#UTC时间" class="headerlink" title="UTC时间"></a>UTC时间</h3><p><strong>协调世界时</strong>（<strong>C</strong>oordinated <strong>U</strong>niversial <strong>T</strong>ime，简称<strong>UTC</strong>）是最主要的时间标准，其以原子时秒长为基础，在时刻上尽量接近于格林威治标准时间。</p>
<p>协调世界时是世界上调节时钟和时间的主要时间标准，它与0度经线的平太阳时相差不超过1秒。因此UTC时间+8即可获得北京标准时间（UTC+8）。</p>
<h3 id="本地时间"><a href="#本地时间" class="headerlink" title="本地时间"></a>本地时间</h3><p>本地时间与当地的时区相关，例如中国当地时间采用了北京标准时间（UTC+8）.</p>
<h3 id="纪元时间"><a href="#纪元时间" class="headerlink" title="纪元时间"></a>纪元时间</h3><p><strong>纪元时间</strong>（Epoch time）又被称为Unix时间（常用Linux的小伙伴可能会比较熟悉）。它表示1970年1月1日00:00UTC以来所经历的<strong>秒数</strong>（不考虑闰秒）。</p>
<p>例如北京时间2021年5月18日晚上9点07分32秒的纪元时间为：<code>1621372052</code>。</p>
<p>作为一个敏感的CPP程序员，你应该很快就意识到这个大整数在储存会产生很多问题，例如溢出。然而事实正是如此，在一些历史机器上，使用了32位的有符号整数来储存这个时间戳，因此产生在结果就是：在2038-01-19 03:14:07这一刻，该值会溢出。</p>
<p>另外，如果你对为什么选1970-1-1日零点做位纪元时间起点，可以看一下这个帖子：</p>
<p><a href="https://stackoverflow.com/questions/1090869/why-is-1-1-1970-the-epoch-time">Why is 1/1/1970 the “epoch time”?</a></p>
<h2 id="0x03-C-Style-日期时间库"><a href="#0x03-C-Style-日期时间库" class="headerlink" title="0x03 C-Style 日期时间库"></a>0x03 C-Style 日期时间库</h2><p>C-Style日期时间库主要位于<code>&lt;ctime&gt;</code>头文件中，下面给出头文件中包含的常用的<em>类型</em>和<em>函数</em>。</p>
<h3 id="常用类型与函数"><a href="#常用类型与函数" class="headerlink" title="常用类型与函数"></a>常用类型与函数</h3><p><strong>类型</strong></p>
<table>
<thead>
<tr>
<th>类型名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>clock_t</td>
<td>进程运行时间</td>
</tr>
<tr>
<td>size_t</td>
<td>sizeof运算符返回的无符号整数类型</td>
</tr>
<tr>
<td>time_t</td>
<td>从纪元起的时间类型</td>
</tr>
<tr>
<td>tm</td>
<td>日历时间类型</td>
</tr>
<tr>
<td>timespec*(C++17)*</td>
<td>以秒和纳秒表示的时间（C++17）</td>
</tr>
</tbody></table>
<p><strong>函数</strong></p>
<table>
<thead>
<tr>
<th>函数名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>std::clock_t clock()</td>
<td>返回自程序启动时起的原始处理器时钟时间</td>
</tr>
<tr>
<td>std::time_t time(std::time_t* arg)</td>
<td>返回自纪元起计的系统当前时间</td>
</tr>
<tr>
<td>double difftime(std::time_t time_end, std::time_t time_beg)</td>
<td>计算时间之间的差</td>
</tr>
<tr>
<td>int timespec_get(std::timespec* ts, int base)<em>(C++17)</em></td>
<td>返回基于给定时间基底的日历时间（C++17）</td>
</tr>
<tr>
<td>char* ctime(const std::time_t* time)</td>
<td>转换 time_t 对象为文本表示</td>
</tr>
<tr>
<td>char* asctime(const std::tm* time_ptr)</td>
<td>转换 tm 对象为文本表示</td>
</tr>
<tr>
<td>std::size_t strftime(char* str, std::size_t count, const char* format, const std::tm* time)</td>
<td>转换 tm 对象到自定义的文本表示</td>
</tr>
<tr>
<td>std::size_t wcsftime( wchar_t* str, std::size_t count, const wchar_t* format, const std::tm* time)</td>
<td>转换 tm 对象为定制的宽字符串文本表示</td>
</tr>
<tr>
<td>std::tm* gmtime(const std::time_t* time)</td>
<td>将time_t转换成UTC表示的时间</td>
</tr>
<tr>
<td>std::tm* localtime(const std::time_t *time)</td>
<td>将time_t转换成本地时间</td>
</tr>
<tr>
<td>std::time_t mktime(std::tm* time)</td>
<td>将tm格式的时间转换成time_t表示的时间</td>
</tr>
</tbody></table>
<p>函数和数据类型又多又杂有木有，刚开始接触的时候很容易弄混且不太容易记住，这里借鉴一下大佬的一张图来理解记忆：</p>
<p><img src="C:\Users\Skykey\Desktop\ctime.png"></p>
<p>这幅图中，以数据类型为中心，带方向的实心箭头表示该函数返回相应类型的结果。</p>
<ul>
<li>clock函数比较特别，它返回进程运行的时间，因而是相对独立的。</li>
<li>time_t描述纪元时间（精确到秒），使用time函数获得。</li>
<li>timespec类型在time_t的基础上增加了纳秒的精度，需要通过timespec_get函数获取。该类型与函数为C++17新增内容。</li>
<li>tm是日历类型，包含了年月日等信息。可以通过gmtime，localtime和mktime函数进行time_t和tm类型的相互转化。</li>
<li>gmtime和localtime两个函数存在时区差异相关问题。</li>
<li>time_t和tm结构都可以用字符串格式输出。ctime和asctime输出的格式是固定的，如果需要自定义格式，需要使用strftime或者wcsftime函数。</li>
</ul>
<h3 id="计算进程运行的时间"><a href="#计算进程运行的时间" class="headerlink" title="计算进程运行的时间"></a>计算进程运行的时间</h3><p>clock函数会返回从关联到进程开始执行的实现定义时期的起，进程所用的粗略处理器时间。将此值除以<code>CLOCKS_PER_SEC</code>常量可转换为秒。</p>
<p>这里给出cppreference上clock函数示例的简化版：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;threads.h&gt;</span> <span class="comment">// POSIX 中的 pthread.h</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 函数 f() 做一些耗时的工作</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">void</span>* thr_data)</span> <span class="comment">// POSIX 中返回 void*</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">double</span> d = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n=<span class="number">0</span>; n&lt;<span class="number">10000</span>; ++n)</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> m=<span class="number">0</span>; m&lt;<span class="number">10000</span>; ++m)</span><br><span class="line">           d += d*n*m;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">clock_t</span> t1 = <span class="built_in">clock</span>();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">thrd_t</span> thr1, thr2;  <span class="comment">// C11 ；POSIX 中用 pthread_t</span></span><br><span class="line">    <span class="built_in">thrd_create</span>(&amp;thr1, f, <span class="literal">NULL</span>); <span class="comment">// C11 ； POSIX 中用 pthread_create</span></span><br><span class="line">    <span class="built_in">thrd_create</span>(&amp;thr2, f, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">thrd_join</span>(thr1, <span class="literal">NULL</span>); <span class="comment">// C11 ； POSIX 中用 pthread_join</span></span><br><span class="line">    <span class="built_in">thrd_join</span>(thr2, <span class="literal">NULL</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">clock_t</span> t2 = <span class="built_in">clock</span>();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">double</span> dur = <span class="number">1000.0</span>*(t2-t1)/CLOCKS_PER_SEC;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;CPU time used (per clock(): %.2f ms\n&quot;</span>, dur);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可能的输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CPU time used (per clock(): 1580.00 ms</span><br></pre></td></tr></table></figure>

<p>我们应当注意，clock时间或许会快于或慢于挂钟时间，这取决于操作系统给予程序的执行资源。在单处理器的情况下，若CPU为其他进程所共享，clock可能慢于挂钟，若当前进程为多线程，而有更多资源可用，clock时间可能会快于挂钟。在多处理器情况下，若进程使用了多线程，那么clock时间可能要慢于挂钟。</p>
<h3 id="获取纪元时间"><a href="#获取纪元时间" class="headerlink" title="获取纪元时间"></a>获取纪元时间</h3><p>使用time函数可以获取储存于time_t类型返回值里的纪元时间。</p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">time_t</span> epoch_time = <span class="built_in">time</span>(<span class="literal">nullptr</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Epoch time: &quot;</span> &lt;&lt; epoch_time &lt;&lt;endl; </span><br></pre></td></tr></table></figure>

<p>在北京时间2021年5月18日晚上9点07分32秒输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Epoch time: 1621372052</span><br></pre></td></tr></table></figure>



<h3 id="计算时间差"><a href="#计算时间差" class="headerlink" title="计算时间差"></a>计算时间差</h3><p>在一些情况下我们需要计算操作所花费的<strong>时间长度</strong>。可以看出，time_t结构中储存的是<strong>时间点</strong>，而通过常识我们得知：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">时间差（时间长度） = 时间点 - 时间点</span><br></pre></td></tr></table></figure>

<p>在C-Style日期时间库中，我们可以通过difftime函数来计算两个时间点的差。</p>
<p>下面给出cppreference的示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::<span class="keyword">time_t</span> start = std::<span class="built_in">time</span>(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">double</span> d;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 一些耗时操作</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n=<span class="number">0</span>; n&lt;<span class="number">10000</span>; ++n) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> m=<span class="number">0</span>; m&lt;<span class="number">100000</span>; ++m) &#123;</span><br><span class="line">           d += d*n*m;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Wall time passed: &quot;</span></span><br><span class="line">              &lt;&lt; std::<span class="built_in">difftime</span>(std::<span class="built_in">time</span>(<span class="literal">NULL</span>), start) &lt;&lt; <span class="string">&quot; s.\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可能的输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Wall time passed: 7 s.</span><br></pre></td></tr></table></figure>



<h3 id="UTC时间与本地时间"><a href="#UTC时间与本地时间" class="headerlink" title="UTC时间与本地时间"></a>UTC时间与本地时间</h3><p>在C-Style日期时间库中，我们可以使用gmtime将std::time_t的纪元时间转换为UTC时间，使用localtime将纪元时间转换为本地时区所代表的日历时间。</p>
<p>gmtime与localtime返回值的类型为tm结构，即日历时间的结构描述，其结构如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tm</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> tm_sec;</span><br><span class="line">  <span class="keyword">int</span> tm_min</span><br><span class="line">  <span class="keyword">int</span> tm_hour;</span><br><span class="line">  <span class="keyword">int</span> tm_mday;</span><br><span class="line">  <span class="keyword">int</span> tm_mon;</span><br><span class="line">  <span class="keyword">int</span> tm_year;</span><br><span class="line">  <span class="keyword">int</span> tm_wday;</span><br><span class="line">  <span class="keyword">int</span> tm_yday;</span><br><span class="line">  <span class="keyword">int</span> tm_isdst;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>有两点我们需要注意：</p>
<ul>
<li>tm_mon表示的范围为[0, 11]。转换成日常使用的月份表示需要+1。</li>
<li>tm_year表示的是自1900年之后所过的年份数。转换成日常使用的年份表示需要+1900。</li>
</ul>
<p>下面给出示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">time_t</span> now = <span class="built_in">time</span>(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">tm* gm_time = <span class="built_in">gmtime</span>(&amp;now);</span><br><span class="line">tm* local_time = <span class="built_in">localtime</span>(&amp;now);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;gmtime: &quot;</span> &lt;&lt; <span class="built_in">asctime</span>(gm_time);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;local_time: &quot;</span> &lt;&lt; <span class="built_in">asctime</span>(local_time);</span><br></pre></td></tr></table></figure>

<p>输出如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">gmtime: Tue May <span class="number">18</span> <span class="number">21</span>:<span class="number">36</span>:<span class="number">48</span> <span class="number">2021</span></span><br><span class="line">local_time: Tue May <span class="number">18</span> <span class="number">21</span>:<span class="number">36</span>:<span class="number">48</span> <span class="number">2021</span></span><br></pre></td></tr></table></figure>



<h3 id="输出时间和日期"><a href="#输出时间和日期" class="headerlink" title="输出时间和日期"></a>输出时间和日期</h3><p>获取了时间，我们自然想要将时间以字符串的形式打印出来。此时可以使用ctime函数。</p>
<p>应注意的是，ctime函数打印的格式是固定的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Www Mmm dd hh:mm:ss yyyy\n</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">time_t</span> now = <span class="built_in">time</span>(<span class="literal">nullptr</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Now is: &quot;</span> &lt;&lt; <span class="built_in">ctime</span>(&amp;now);</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Now is: Tue May 18 21:39:46 2021</span><br></pre></td></tr></table></figure>

<p>而tm储存的日期时间结构，我们也可以使用asctime函数将其转换为字符串格式。</p>
<p>然而，ctime和asctime函数其输出的格式都是固定的，在有格式要求的情况下，我们通常有两种做法：</p>
<ol>
<li><p>拆分tm结构体的字段：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">time_t now = time(nullptr);</span><br><span class="line">tm* t = localtime(&amp;now);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &quot;Now is: &quot; &lt;&lt; t-&gt;tm_year + 1900 &lt;&lt; &quot;/&quot; &lt;&lt; t-&gt;tm_mon + 1&lt;&lt; &quot;/&quot; &lt;&lt; t-&gt;tm_mday &lt;&lt; &quot; &quot;;</span><br><span class="line">cout &lt;&lt; t-&gt;tm_hour &lt;&lt; &quot;:&quot; &lt;&lt; t-&gt;tm_min &lt;&lt; &quot;:&quot; &lt;&lt; t-&gt;tm_sec &lt;&lt; endl;</span><br></pre></td></tr></table></figure></li>
<li><p>使用strftime或者wcsftime函数来指定格式输出。函数格式可以参考以下文档：</p>
<p><a href="https://zh.cppreference.com/w/cpp/chrono/c/strftime">https://zh.cppreference.com/w/cpp/chrono/c/strftime</a></p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;locale&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::locale::<span class="built_in">global</span>(std::<span class="built_in">locale</span>(<span class="string">&quot;ja_JP.utf8&quot;</span>));</span><br><span class="line">    std::<span class="keyword">time_t</span> t = std::<span class="built_in">time</span>(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">char</span> mbstr[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">if</span> (std::<span class="built_in">strftime</span>(mbstr, <span class="built_in"><span class="keyword">sizeof</span></span>(mbstr), <span class="string">&quot;%A %c&quot;</span>, std::<span class="built_in">localtime</span>(&amp;t))) &#123;</span><br><span class="line">        std::cout &lt;&lt; mbstr &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">火曜日 2011年12月27日 17時39分03秒</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="C-17新内容timespec，迈向纳秒精度"><a href="#C-17新内容timespec，迈向纳秒精度" class="headerlink" title="C++17新内容timespec，迈向纳秒精度"></a>C++17新内容timespec，迈向纳秒精度</h3><p>纪元时间的精度只有秒，这在很多时候是不够用的。为了解决这个问题，C++17增加timespec类型，提供了纳秒级别的精度。</p>
<p>一些熟悉C语言的朋友可能会立即满头问号：timespec不是在C11（注意看，是C11，不是CPP11）就已经引入了么？</p>
<p>但事实的确如此，严格的C++的C-Style日期时间库，在C++17标准才正式引入timespec类型。</p>
<p>timespec类型结构如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> &#123;</span></span><br><span class="line">  std::<span class="keyword">time_t</span> tv_sec;</span><br><span class="line">  <span class="keyword">long</span> tv_nsec;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中tv_nsec成员保存了纳秒数。</p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">timespec ts;</span><br><span class="line"><span class="built_in">timespec_get</span>(&amp;ts, TIME_UTC);</span><br><span class="line"><span class="keyword">char</span> buff[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">strftime</span>(buff, <span class="keyword">sizeof</span> buff, <span class="string">&quot;%D %T&quot;</span>, std::<span class="built_in">gmtime</span>(&amp;ts.tv_sec));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Current time: %s.%09ld UTC\n&quot;</span>, buff, ts.tv_nsec);</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Current time: <span class="number">05</span>/<span class="number">18</span>/<span class="number">21</span> <span class="number">13</span>:<span class="number">50</span>:<span class="number">58.667861100</span> UTC</span><br></pre></td></tr></table></figure>



<p>C-Style日期时间库至此已基本结束，接下来讲解C++11起新增的chrono库。</p>
<hr>
<h2 id="0x04-chrono库"><a href="#0x04-chrono库" class="headerlink" title="0x04 chrono库"></a>0x04 chrono库</h2><p>chrono是以各种精度跟踪时间的类型的灵活汇集。chrono库定义三种主要类型以及工具函数和常用的typedef：</p>
<ul>
<li>时钟</li>
<li>时长</li>
<li>时间点</li>
</ul>
<h3 id="时钟"><a href="#时钟" class="headerlink" title="时钟"></a>时钟</h3><p>C++11的chrono库主要包含了三种类型的时钟：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>system_clock</td>
<td>来自系统范畴实时时钟的挂钟时间</td>
</tr>
<tr>
<td>steady_clock</td>
<td>决不会调整的单调时钟</td>
</tr>
<tr>
<td>high_resolution_clock</td>
<td>拥有可用的最短嘀嗒周期的时钟</td>
</tr>
</tbody></table>
<p>system_clock来源是系统时钟。然而在大多数系统上，系统时间是可以在任何时候被调节的。所以如果用来计算两个时间点的时间差，这并不是一个好的选择。</p>
<p>steady_clock是一个单调时钟。此时钟的时间点无法减少，因为物理十几件向前移动。因而steady_clock是度量间隔的最适宜的选择。</p>
<p>high_resolution_clock表示实现提供的拥有最小计次周期的时钟。它可以是system_clock或steady_clock的别名，或者第三个独立时钟。</p>
<p>对于high_resolution_clock，cppreference给出了以下需要我们注意的地方：</p>
<p><a href="https://zh.cppreference.com/w/cpp/chrono/high_resolution_clock">https://zh.cppreference.com/w/cpp/chrono/high_resolution_clock</a></p>
<blockquote>
<p><code>high_resolution_clock</code> 在不同标准库实现之间实现不一致，而应该避免使用它。通常它只是 <a href="https://zh.cppreference.com/w/cpp/chrono/steady_clock">std::chrono::steady_clock</a> 或 <a href="https://zh.cppreference.com/w/cpp/chrono/system_clock">std::chrono::system_clock</a> 的别名，但实际是哪个取决于库或配置。它是 <code>system_clock</code> 时不是单调的（即时间能后退）。例如对于 gcc 的 libstdc++ 它是 <code>system_clock</code> ，对于 MSVC 它是 <code>steady_clock</code> ，而对于 clang 的 libc++ 它取决于配置。</p>
<p>通常用户应该直接使用 <a href="https://zh.cppreference.com/w/cpp/chrono/steady_clock">std::chrono::steady_clock</a> 或 <a href="https://zh.cppreference.com/w/cpp/chrono/system_clock">std::chrono::system_clock</a> 代替 <code>std::chrono::high_resolution_clock</code> ：对时长度量使用 <code>steady_clock</code> ，对壁钟时间使用 <code>system_clock</code> 。</p>
</blockquote>
<p>对于这三个时钟类，有着以下共同的成员：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>now()</td>
<td>静态成员函数，返回当前时间，类型为clock::time_point</td>
</tr>
<tr>
<td>time_point</td>
<td>成员类型，当前时钟的时间点类型。</td>
</tr>
<tr>
<td>duration</td>
<td>成员类型，时钟的时长类型。</td>
</tr>
<tr>
<td>rep</td>
<td>成员类型，时钟的tick类型，等同于clock::duration::rep</td>
</tr>
<tr>
<td>period</td>
<td>成员类型，时钟的单位，等同于clock::duration::period</td>
</tr>
<tr>
<td>is_steady</td>
<td>静态成员类型：是否是稳定时钟，对于steady_clock来说该值一定是true</td>
</tr>
</tbody></table>
<p>每个时钟类都有着一个静态成员函数<code>new()</code>来获取当前时间。该函数的返回类型则是由该时钟类的time_point描述，例如<code>std::chrono::time_point&lt;std::chrono::system_clock&gt;</code>或者<code>std::chrono::time_point&lt;std::chrono::steady_clock&gt;</code>。我们可以使用auto关键字来简写（auto是个好文明）。</p>
<p>阅读文档，我们不难发现system_clock有着与另外两个clock所不具有的特性：它是唯一有能力映射其时间点到C-Style时间的C++时钟。system_clock提供了两个静态成员函数来与std::time_t进行互相转换：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>to_time_t</td>
<td>转换系统时钟时间点为 std::time_t</td>
</tr>
<tr>
<td>from_time_t</td>
<td>转换 std::time_t 到系统时钟时间点</td>
</tr>
</tbody></table>
<p>为了方便理解和记忆，我们也用一副图来描述几种时间类型的转换：</p>
<p><img src="C:\Users\Skykey\Desktop\conversion.png"></p>
<h3 id="时长"><a href="#时长" class="headerlink" title="时长"></a>时长</h3><p>人类对精度的要求永无止境。C-Style日期时间库为了提供对纳秒的精度，增加了timespec类型及相关的函数。那如果以后对更高精度的需求越来越高，C++标准库还要不断增加更多的类型和配套函数吗？这明显是一个不合理的设计。因而C++标准提出了一个新的解决思路，而这个思路涉及到了C++11引入的一个新的头文件和类型：ratio。</p>
<h4 id="ratio"><a href="#ratio" class="headerlink" title="ratio"></a>ratio</h4><p><code>std::ratio</code>定义在<code>&lt;ratio&gt;</code>文件中，提供了编译期的比例计算功能。</p>
<p><code>std::ratio</code>的定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;</span><br><span class="line">    std::<span class="keyword">intmax_t</span> Num,</span><br><span class="line">    std::<span class="keyword">intmax_t</span> Denom = <span class="number">1</span></span><br><span class="line">&gt; class ratio;</span><br></pre></td></tr></table></figure>

<p>类成员Num即为分子，类成员Denom即为分母。我们可以直接通过调用类成员来获取相关值。</p>
<p><code>&lt;ratio&gt;</code>头文件还包含了：ratio_add，ratio_subtract，ratio_multiply，ratio_divide来完成分数的加减乘除四则运算。</p>
<p>例如，想要计算5/7 + 59/1023，我们可以这样写：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ratio_add&lt;ratio&lt;<span class="number">5</span>, <span class="number">7</span>&gt;, ratio&lt;<span class="number">59</span>, <span class="number">1023</span>&gt;&gt; result;</span><br><span class="line"><span class="keyword">double</span> value = ((<span class="keyword">double</span>) result.num) / result.den;</span><br><span class="line">cout &lt;&lt; result.num &lt;&lt; <span class="string">&quot;/&quot;</span> &lt;&lt; result.den &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; value &lt;&lt; endl;</span><br></pre></td></tr></table></figure>



<p>对于编译期有理数算数的相关内容，可以在这篇文档中找到更多信息：</p>
<p><a href="https://zh.cppreference.com/w/cpp/numeric/ratio">https://zh.cppreference.com/w/cpp/numeric/ratio</a></p>
<p>有了ratio之后，结合<code>std::chrono::duration</code>，我们便可以表示任意精度的值了。</p>
<p>例如，相对于秒来说，毫秒是1/1,000，微秒是1/1,000,000，纳秒是1/1,000,000,000。通过ratio就可以这样表达：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::ratio&lt;<span class="number">1</span>, <span class="number">1000</span>&gt;       milliseconds;</span><br><span class="line">std::ratio&lt;<span class="number">1</span>, <span class="number">1000000</span>&gt;    microseconds;</span><br><span class="line">std::ratio&lt;<span class="number">1</span>, <span class="number">1000000000</span>&gt; nanoseconds;</span><br></pre></td></tr></table></figure>



<h4 id="时长类型"><a href="#时长类型" class="headerlink" title="时长类型"></a>时长类型</h4><p>类模板 std::chrono::duration 表示时间间隔。有了ratio之后，表达时长就很方便了，下面是chrono库中提供的很常用的几个时长单位：</p>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">定义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">std::chrono::nanoseconds</td>
<td align="left">duration&lt;/*至少 64 位的有符号整数类型*/, std::nano&gt;</td>
</tr>
<tr>
<td align="left">std::chrono::microseconds</td>
<td align="left">duration&lt;/*至少 55 位的有符号整数类型*/, std::micro&gt;</td>
</tr>
<tr>
<td align="left">std::chrono::milliseconds</td>
<td align="left">duration&lt;/*至少 45 位的有符号整数类型*/, std::milli&gt;</td>
</tr>
<tr>
<td align="left">std::chrono::seconds</td>
<td align="left">duration&lt;/*至少 35 位的有符号整数类型*/&gt;</td>
</tr>
<tr>
<td align="left">std::chrono::minutes</td>
<td align="left">duration&lt;/*至少 29 位的有符号整数类型*/, std::ratio&lt;60»</td>
</tr>
<tr>
<td align="left">std::chrono::hours</td>
<td align="left">duration&lt;/*至少 23 位的有符号整数类型*/, std::ratio&lt;3600»</td>
</tr>
</tbody></table>
<p>我们可以调用duration类的<code>count()</code>成员函数来获取具体数值。</p>
<h4 id="时长运算"><a href="#时长运算" class="headerlink" title="时长运算"></a>时长运算</h4><p>时长运算可以直接使用“+”或“-”相加相减。chrono库也提供了几个常用的函数：</p>
<table>
<thead>
<tr>
<th align="left">函数</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">duration_cast</td>
<td align="left">进行时长的转换</td>
</tr>
<tr>
<td align="left">floor(C++17)</td>
<td align="left">以向下取整的方式，将一个时长转换为另一个时长</td>
</tr>
<tr>
<td align="left">ceil(C++17)</td>
<td align="left">以向上取整的方式，将一个时长转换为另一个时长</td>
</tr>
<tr>
<td align="left">round(C++17)</td>
<td align="left">转换时长到另一个时长，就近取整，偶数优先</td>
</tr>
<tr>
<td align="left">abs(C++17)</td>
<td align="left">获取时长的绝对值</td>
</tr>
</tbody></table>
<p>例如：想要知道2个小时零5分钟一共是多少秒，可以这样写：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">chrono::hours <span class="title">two_hours</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="function">chrono::minutes <span class="title">five_minutes</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> duration = two_hours + five_minutes;</span><br><span class="line"><span class="keyword">auto</span> seconds = chrono::duration_cast&lt;chrono::seconds&gt;(duration);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;02:05 is &quot;</span> &lt;&lt; seconds.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot; seconds&quot;</span> &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>我们可以得到：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">02:05 is 7500 seconds</span><br></pre></td></tr></table></figure>

<p>从C++14开始，你甚至可以用字面值来描述常见的时长。这包括：</p>
<ul>
<li><code>h</code>表示小时</li>
<li><code>min</code>表示分钟</li>
<li><code>s</code>表示秒</li>
<li><code>ms</code>表示毫秒</li>
<li><code>us</code>表示微妙</li>
<li><code>ns</code>表示纳秒</li>
</ul>
<p>这些字面值位于<code>std::chrono_literals</code>命名空间下。于是，可以这样表达2个小时以及5分钟：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono_literals;</span><br><span class="line"><span class="keyword">auto</span> two_hours = <span class="number">2</span>h;</span><br><span class="line"><span class="keyword">auto</span> five_minutes = <span class="number">5</span>min;</span><br></pre></td></tr></table></figure>



<h3 id="时间点"><a href="#时间点" class="headerlink" title="时间点"></a>时间点</h3><p>时钟的now函数返回的值就是一个时间点，时间点包含了时钟和时长两个信息。</p>
<p>类模板<code>std::chrono::time_point</code>表示时间中的一个点，定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Clock</span>,</span></span><br><span class="line"><span class="class">    <span class="keyword">class</span> <span class="title">Duration</span> =</span> <span class="keyword">typename</span> Clock::duration</span><br><span class="line">&gt; <span class="class"><span class="keyword">class</span> <span class="title">time_point</span>;</span></span><br></pre></td></tr></table></figure>

<p>与我们的常识一致，时间点具有加法和减法操作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">时间点 + 时长 = 时间点</span><br><span class="line">时间点 - 时间点 = 时长</span><br></pre></td></tr></table></figure>

<p>因而我们可以通过两个时间点相减来计算一个时间间隔，示例如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> start = chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line"><span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000000</span>; i++) &#123;</span><br><span class="line">    sum += <span class="built_in">sqrt</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">auto</span> end = chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> time_diff = end - start;</span><br><span class="line"><span class="keyword">auto</span> duration = chrono::duration_cast&lt;chrono::milliseconds&gt;(time_diff);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Operation cost : &quot;</span> &lt;&lt; duration.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot;ms&quot;</span> &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>两个时间点也存在着比较操作，用于判断一个时间点在另外一个时间点之前还是之后，<code>std::chrono::time_point</code>重载了<code>==</code>，<code>!=</code>，<code>&lt;</code>，<code>&lt;=</code>，<code>&gt;</code>，<code>&gt;=</code>操作符来实现比较操作。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>C++11</tag>
        <tag>C++17</tag>
        <tag>日期与时间编程</tag>
        <tag>学习心得</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL on Qt (3):SQL的MVC结构基础知识总结</title>
    <url>/2020/07/24/mysqlonqt3/</url>
    <content><![CDATA[<h1 id="MySQL-on-Qt-3-SQL的MVC结构基础知识总结"><a href="#MySQL-on-Qt-3-SQL的MVC结构基础知识总结" class="headerlink" title="MySQL on Qt (3): SQL的MVC结构基础知识总结"></a>MySQL on Qt (3): SQL的MVC结构基础知识总结</h1><blockquote>
<p> 写在前面： </p>
<p>大一下学期的 CPP 大作业“自主订餐系统”可真是颇费了一些力气，每天晚睡早起撸代码，课都没听，很多知识都是现学现用。</p>
<p>为了避免当时学到的东西给全部忘光光（`_&gt;`，我这脑子啊。。。），所以我把当时大作业的一些核心部分（一些零碎的小细节，能记就记）给记录一下，一方面是复习，一方面也方便以后用到的时候查阅。</p>
</blockquote>
<p>这篇文章是大作业 MySQL + SQLite 操作相关部分的第三章，主要讲一下 Qt 中 SQL 的 MVC 结构的基础知识，包括一部分的 MVC 原理介绍和基础使用。</p>
<span id="more"></span>

<h2 id="什么是-MVC-结构"><a href="#什么是-MVC-结构" class="headerlink" title="什么是 MVC 结构"></a>什么是 MVC 结构</h2><p>关于 MVC 结构的具体介绍，可以看一个名为《Qt中文文档》的 Github 项目中 Qt 关于 MVC 的官方文档的中文翻译版（这里打个广告=。=）：</p>
<blockquote>
<p>模型/视图 编程</p>
<p><a href="https://www.cryfeifei.cn/2020/08/08/qt-zhong-wen-wen-dang-mo-xing-shi-tu-jian-jie/">https://www.cryfeifei.cn/2020/08/08/qt-zhong-wen-wen-dang-mo-xing-shi-tu-jian-jie/</a></p>
</blockquote>
<p>也可以看上一篇我转载自网络的文章：</p>
<blockquote>
<p>Qt Model/View（模型/视图）结构（无师自通）</p>
<p><a href="http://www.skykeyjoker.com/2020/07/23/model-view/">http://www.skykeyjoker.com/2020/07/23/model-view/</a></p>
</blockquote>
<p>以上两篇网络文章我都转载到了我的博客中。</p>
<p>这里我就不再讲太多太细的知识和原理，只是简单概括一下。</p>
<p>GUI 应用程序的一个很重要的功能是由用户在界面上编辑和修改数据，典型的如数据库应用程序。数据库应用程序中，用户在界面上执行各种操作，实际上是修改了界面组件所关联的数据库内的数据。</p>
<p>Model/View（模型/视图）结构是 Qt 中用界面组件显示与编辑数据的一种结构，视图（View）是显示和编辑数据的界面组件，模型（Model）是视图与原始数据之间的接口。</p>
<p>将界面组件与所编辑的数据分离开来，又通过数据源的方式连接起来，是处理界面与数据的一种较好的方式。Qt 使用 Model/View 结构来处理这种关系，Model/View 的基本结构如图 1 所示。</p>
<p><a href="http://c.biancheng.net/uploads/allimg/190103/2-1Z10316062G22.gif"><img src="http://c.biancheng.net/uploads/allimg/190103/2-1Z10316062G22.gif" alt="Model/View基本结构"></a></p>
<p>其中各部分的功能如下：</p>
<ul>
<li>数据（Data）是实际的数据，如数据库的一个数据表或SQL查询结果，内存中的一个 StringList，或磁盘文件结构等。</li>
<li>视图或视图组件（View）是屏幕上的界面组件，视图从数据模型获得每个数据项的模型索引（model index），通过模型索引获取数据，然后为界面组件提供显示数据。Qt 提供一些现成的数据视图组件，如 QListView、QTreeView 和 QTableView 等。</li>
<li>模型或数据模型（Model）与实际数据通信，并为视图组件提供数据接口。它从原始数据提取需要的内容，用于视图组件进行显示和编辑。Qt 中有一些预定义的数据模型，如 QStringListModel 可作为 StringList 的数据模型，QSqlTableModel 可以作为数据库中一个数据表的数据模型。</li>
</ul>
<h2 id="开启-MVC-之旅"><a href="#开启-MVC-之旅" class="headerlink" title="开启 MVC 之旅"></a>开启 MVC 之旅</h2><p>讲完又臭又长的理论，我们就要进入令人激动的实践啦。</p>
<p>外甥打灯笼，这次我也是写了一个 Demo 来演示具体的应用。</p>
<p><img src="https://gitee.com/skykeyjoker/PicCloud/raw/master/img/QQ%E5%9B%BE%E7%89%8720200724132133.png" alt="demo"></p>
<p>与以往不同，这次会先把全部工程代码贴出来再分块讲。</p>
<p><code>sqlmvcdemo.h</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SQLMVCDEMO_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SQLMVCDEMO_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QHBoxLayout&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QVBoxLayout&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QPushButton&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QLineEdit&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QLabel&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QTableView&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QHeaderView&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QSqlTableModel&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QSqlDatabase&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QSqlError&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QSqlRecord&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">QT_BEGIN_NAMESPACE</span><br><span class="line"><span class="keyword">namespace</span> Ui &#123; <span class="class"><span class="keyword">class</span> <span class="title">SQLMVCDemo</span>;</span> &#125;</span><br><span class="line">QT_END_NAMESPACE</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SQLMVCDemo</span> :</span> <span class="keyword">public</span> QWidget</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SQLMVCDemo</span>(QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line">    ~<span class="built_in">SQLMVCDemo</span>();</span><br><span class="line"></span><br><span class="line">    QVBoxLayout *mainLay;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Sql model/view</span></span><br><span class="line">    QSqlTableModel *_tableModel;</span><br><span class="line">    QTableView *_tableView;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">connectToDb</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::SQLMVCDemo *ui;</span><br><span class="line"></span><br><span class="line">    QSqlDatabase _db = QSqlDatabase::<span class="built_in">addDatabase</span>(<span class="string">&quot;QMYSQL&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// SQLMVCDEMO_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<p><code>sqlmvcdemo.cpp</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;sqlmvcdemo.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ui_sqlmvcdemo.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">SQLMVCDemo::<span class="built_in">SQLMVCDemo</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QWidget</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::SQLMVCDemo)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Instance</span></span><br><span class="line">    mainLay = <span class="keyword">new</span> <span class="built_in">QVBoxLayout</span>(<span class="keyword">this</span>);</span><br><span class="line">    _tableView = <span class="keyword">new</span> QTableView;</span><br><span class="line">    _tableModel = <span class="keyword">new</span> <span class="built_in">QSqlTableModel</span>(<span class="literal">nullptr</span>,_db); <span class="comment">// Construct from allocated Database</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// UI</span></span><br><span class="line">    mainLay-&gt;<span class="built_in">addWidget</span>(_tableView);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Connect to Db</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">connectToDb</span>())</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;Connected sucessfully.&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        QSqlError error = _db.<span class="built_in">lastError</span>();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;Connected failed.&quot;</span>;</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;error.<span class="built_in">text</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Model</span></span><br><span class="line">    _tableModel-&gt;<span class="built_in">setTable</span>(<span class="string">&quot;user&quot;</span>); <span class="comment">// Set table</span></span><br><span class="line">    _tableModel-&gt;<span class="built_in">select</span>();  <span class="comment">// Must ** SELECT ** first!</span></span><br><span class="line">    <span class="comment">//_tableModel-&gt;setEditStrategy(QSqlTableModel::OnManualSubmit);  // Manual submit</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//View</span></span><br><span class="line">    _tableView-&gt;<span class="built_in">setModel</span>(_tableModel);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Init Hearders</span></span><br><span class="line"><span class="comment">    _tableView-&gt;setColumnCount(5);</span></span><br><span class="line"><span class="comment">    _tableView-&gt;setHorizontalHeader(QStringList()&lt;&lt;&quot;ID&quot;&lt;&lt;&quot;Name&quot;);</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set width of cols</span></span><br><span class="line">    _tableView-&gt;<span class="built_in">setColumnWidth</span>(<span class="number">0</span>,<span class="number">100</span>);</span><br><span class="line">    _tableView-&gt;<span class="built_in">setColumnWidth</span>(<span class="number">1</span>,<span class="number">180</span>);</span><br><span class="line">    _tableView-&gt;<span class="built_in">setColumnWidth</span>(<span class="number">2</span>,<span class="number">100</span>);</span><br><span class="line">    _tableView-&gt;<span class="built_in">setColumnWidth</span>(<span class="number">3</span>,<span class="number">220</span>);</span><br><span class="line">    _tableView-&gt;<span class="built_in">setColumnWidth</span>(<span class="number">4</span>,<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Resize with stretch</span></span><br><span class="line">    _tableView-&gt;<span class="built_in">horizontalHeader</span>()-&gt;<span class="built_in">setSectionResizeMode</span>(<span class="number">3</span>,QHeaderView::Stretch);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Color varies in rows</span></span><br><span class="line">    _tableView-&gt;<span class="built_in">setAlternatingRowColors</span>(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Some propertis of view</span></span><br><span class="line"><span class="comment">    _tableView-&gt;setSelectionBehavior(QAbstractItemView::SelectRows);  // SelectRows</span></span><br><span class="line"><span class="comment">    _tableView-&gt;setSelectionMode(QAbstractItemView::SingleSelection); // SingleSelection</span></span><br><span class="line"><span class="comment">    _tableView-&gt;setEditTriggers(QAbstractItemView::NoEditTriggers);  // NoEditTriggers</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SQLMVCDemo::~<span class="built_in">SQLMVCDemo</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SQLMVCDemo::connectToDb</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    _db.<span class="built_in">setHostName</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    _db.<span class="built_in">setPort</span>(<span class="number">3306</span>);</span><br><span class="line">    _db.<span class="built_in">setDatabaseName</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    _db.<span class="built_in">setUserName</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    _db.<span class="built_in">setPassword</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> ret = _db.<span class="built_in">open</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Model-View-相关的类"><a href="#Model-View-相关的类" class="headerlink" title="Model/View 相关的类"></a>Model/View 相关的类</h3><p>demo 头文件<code>sqlmvcdemo.h</code>比较重要的部分是头文件<code>include</code>部分，这涉及了 Qt 中 MVC 相关的类。</p>
<p>Qt 中 MVC 结构相关类列表如下：</p>
<p><img src="http://c.biancheng.net/uploads/allimg/190103/2-1Z103160KBJ.gif" alt="Qt中模型类的层次结构"></p>
<p><img src="http://c.biancheng.net/uploads/allimg/190103/2-1Z103160934132.gif" alt="视图相关类的层次结构图"></p>
<p>从图里列出的类名基本上就能推测出我们要用到哪些类：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QTableView&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QHeaderView&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QSqlTableModel&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>其中 <code>QHeaderView</code> 类比较特殊，看起来与我们要使用的 SQL 毫不相关对不对。但其实它作用很大，到后面用到的时候再来说一说。</p>
<hr>
<h3 id="SQL-Model-View-绑定"><a href="#SQL-Model-View-绑定" class="headerlink" title="SQL Model/View 绑定"></a>SQL Model/View 绑定</h3><p>正如前面所说，Model 作为数据模型为操作数据提供了相关接口，因而在使相关 Model 时我们要绑定到具体的数据上。在我们这次使用的 SQL MVC 模型中，就是要把 <code>QSqlTableModel</code> 与 <code>QSqlDatabase</code> 对象绑定。所以便有了如下实例化代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">_tableModel = <span class="keyword">new</span> <span class="built_in">QSqlTableModel</span>(<span class="literal">nullptr</span>,_db); <span class="comment">// Construct from allocated Database</span></span><br></pre></td></tr></table></figure>

<p>这样待绑定的数据库连接后，<code>QSqlTableModel</code>对象就可以对数据库进行相关操作了。</p>
<p>这里要注意一下<code>QSqlTableModel</code>模型指定一个表后，还要执行一下<code>QSqlTableModel::select()</code>函数才能选中表中的数据。 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Model</span></span><br><span class="line">_tableModel-&gt;<span class="built_in">setTable</span>(<span class="string">&quot;user&quot;</span>); <span class="comment">// Set table</span></span><br><span class="line">_tableModel-&gt;<span class="built_in">select</span>();  <span class="comment">// Must ** SELECT ** first!</span></span><br></pre></td></tr></table></figure>

<p>关于数据模型我们还要考虑一个小细节：<strong>用户提交策略</strong></p>
<p>一般情况下，用户完成数据编辑后，会有两种提交策略：</p>
<ul>
<li>自动提交（默认），即编辑完数据（ dataChanged() ）后，数据模型自动提交。</li>
<li>手动提交，即编辑完数据后，需手动调用提交函数方能提交用户数据修改。</li>
</ul>
<p>若要设置为手动模式，我们需要对 Model 进行如下设置：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">_tableModel-&gt;<span class="built_in">setEditStrategy</span>(QSqlTableModel::OnManualSubmit); <span class="comment">// Manual submit</span></span><br></pre></td></tr></table></figure>

<p>并在相应位置手动调用该函数提交：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">_tableModel-&gt;<span class="built_in">submitAll</span>()</span><br></pre></td></tr></table></figure>

<hr>
<p>前面也说过，View 是视图结构，与数据模型绑定，为用户操作提供相应的接口，并将用户操作具体应用到数据模型，数据模型再将操作实际应用到数据中。在我们这次使用的 SQL MVC 模型中，就是要把 <code>QTableView</code> 与 <code>QSqlTableModel</code>绑定。所以便有以下代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">_tableView-&gt;<span class="built_in">setModel</span>(_tableModel);</span><br></pre></td></tr></table></figure>

<p>对 View 控件的设置，主要包括以下方面：</p>
<ul>
<li>表头设置</li>
<li>编辑策略</li>
<li>代理</li>
</ul>
<h4 id="View-表头设置"><a href="#View-表头设置" class="headerlink" title="View 表头设置"></a>View 表头设置</h4><p>先来讲一下 View 控件表头的设置。</p>
<p>还记得前面提到的<code>QHeaderView</code>类嘛？这里对表头的各种设置，就必须引用该类。</p>
<p>首先是设置表头，这里以水平表头为例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Init Hearders</span></span><br><span class="line">_tableView-&gt;<span class="built_in">setColumnCount</span>(<span class="number">5</span>);</span><br><span class="line">_tableView-&gt;<span class="built_in">setHorizontalHeader</span>(<span class="built_in">QStringList</span>()&lt;&lt;<span class="string">&quot;ID&quot;</span>&lt;&lt;<span class="string">&quot;Name&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>然后我们肯定会遇到要设置某一列宽度的情况：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Set width of cols</span></span><br><span class="line">_tableView-&gt;<span class="built_in">setColumnWidth</span>(<span class="number">0</span>,<span class="number">100</span>);</span><br><span class="line">_tableView-&gt;<span class="built_in">setColumnWidth</span>(<span class="number">1</span>,<span class="number">180</span>);</span><br><span class="line">_tableView-&gt;<span class="built_in">setColumnWidth</span>(<span class="number">2</span>,<span class="number">100</span>);</span><br><span class="line">_tableView-&gt;<span class="built_in">setColumnWidth</span>(<span class="number">3</span>,<span class="number">220</span>);</span><br><span class="line">_tableView-&gt;<span class="built_in">setColumnWidth</span>(<span class="number">4</span>,<span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<p>当然，我们还能设置某一列的宽度随着界面缩放比例而改变（建议开启该选项，这样才能让表格占满 View 控件，美观度++）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Resize with stretch</span></span><br><span class="line">_tableView-&gt;<span class="built_in">horizontalHeader</span>()-&gt;<span class="built_in">setSectionResizeMode</span>(<span class="number">3</span>,QHeaderView::Stretch);</span><br></pre></td></tr></table></figure>

<p>再来设置一下让数据按行交替现实不同的颜色：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Color varies in rows</span></span><br><span class="line">_tableView-&gt;<span class="built_in">setAlternatingRowColors</span>(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="编辑策略"><a href="#编辑策略" class="headerlink" title="编辑策略"></a>编辑策略</h4><p>按行选中而不是按单元格选中：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">_tableView-&gt;<span class="built_in">setSelectionBehavior</span>(QAbstractItemView::SelectRows);  <span class="comment">// SelectRows</span></span><br></pre></td></tr></table></figure>

<p>单选：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">_tableView-&gt;<span class="built_in">setSelectionMode</span>(QAbstractItemView::SingleSelection); <span class="comment">// SingleSelection</span></span><br></pre></td></tr></table></figure>

<p>只读：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">_tableView-&gt;<span class="built_in">setEditTriggers</span>(QAbstractItemView::NoEditTriggers);  <span class="comment">// NoEditTriggers</span></span><br></pre></td></tr></table></figure>

<h4 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h4><p>例如本 Demo 中的 Gender 项，我想编辑的时候出现一个“男生|女生”的下拉框而不是仅仅出现一个0或1的编辑框，这个时候我们就需要使用代理。</p>
<p>代理这里先卖一个关子。</p>
<p>好吧其实不是卖关子，而是太长了实在是不想在这一章讲了。。。</p>
<p>代理是一个很庞大的部分，我打算在下一章讲一些皮毛的东西。</p>
<hr>
<p>到这里本章的内容基本上就结束了，下一章我会讲一下代理最为皮毛的一些原理和应用。</p>
<blockquote>
<p>Qt Model/View（模型/视图）结构（无师自通）</p>
<p><a href="http://www.skykeyjoker.com/2020/07/23/model-view/">http://www.skykeyjoker.com/2020/07/23/model-view/</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>Qt</tag>
        <tag>Sql</tag>
        <tag>Model/View</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt Model/View（模型/视图）结构（无师自通）</title>
    <url>/2020/07/23/model-view/</url>
    <content><![CDATA[<h1 id="Qt-Model-View（模型-视图）结构（无师自通）"><a href="#Qt-Model-View（模型-视图）结构（无师自通）" class="headerlink" title="Qt Model/View（模型/视图）结构（无师自通）"></a>Qt Model/View（模型/视图）结构（无师自通）</h1><blockquote>
<p>本文转载自：</p>
<p><a href="http://c.biancheng.net/view/1864.html">http://c.biancheng.net/view/1864.html</a></p>
</blockquote>
<p>Model/View（模型/视图）结构是 <a href="http://c.biancheng.net/qt/">Qt</a> 中用界面组件显示与编辑数据的一种结构，视图（View）是显示和编辑数据的界面组件，模型（Model）是视图与原始数据之间的接口。</p>
<p>GUI 应用程序的一个很重要的功能是由用户在界面上编辑和修改数据，典型的如数据库应用程序。数据库应用程序中，用户在界面上执行各种操作，实际上是修改了界面组件所关联的数据库内的数据。</p>
<p>将界面组件与所编辑的数据分离开来，又通过数据源的方式连接起来，是处理界面与数据的一种较好的方式。Qt 使用 Model/View 结构来处理这种关系，Model/View 的基本结构如图 1 所示。</p>
<p><img src="http://c.biancheng.net/uploads/allimg/190103/2-1Z10316062G22.gif" alt="Model/View基本结构"></p>
<span id="more"></span>

<p>其中各部分的功能如下：</p>
<ul>
<li>数据（Data）是实际的数据，如数据库的一个数据表或SQL查询结果，内存中的一个 StringList，或磁盘文件结构等。</li>
<li>视图或视图组件（View）是屏幕上的界面组件，视图从数据模型获得每个数据项的模型索引（model index），通过模型索引获取数据，然后为界面组件提供显示数据。Qt 提供一些现成的数据视图组件，如 QListView、QTreeView 和 QTableView 等。</li>
<li>模型或数据模型（Model）与实际数据通信，并为视图组件提供数据接口。它从原始数据提取需要的内容，用于视图组件进行显示和编辑。Qt 中有一些预定义的数据模型，如 QStringListModel 可作为 StringList 的数据模型，QSqlTableModel 可以作为数据库中一个数据表的数据模型。</li>
</ul>
<p>由于数据源与显示界面通过 Model/View 结构分离开来，因此可以将一个数据模型在不同的视图中显示，也可以在不修改数据模型的情况下，设计特殊的视图组件。</p>
<p>在 Model/View 结构中，还提供了代理（Delegate）功能，代理功能可以让用户定制数据的界面显示和编辑方式。在标准的视图组件中，代理功能显示一个数据，当数据被编辑时，代理通过模型索引与数据模型通信，并为编辑数据提供一个编辑器，一般是一个 QLineEdit 组件。</p>
<p>模型、视图和代理之间使用信号和槽通信。当源数据发生变化时，数据模型发射信号通知视图组件；当用户在界面上操作数据时，视图组件发射信号表示这些操作信息；当编辑数据时，代理发射信号告知数据模型和视图组件编辑器的状态。</p>
<h2 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h2><p>所有的基于项数据的数据模型（Model）都是基于 QAbstractltemModel 类的，这个类定义了视图组件和代理存取数据的接口。数据无需存储在数据模型里，数据可以是其他类、文件、数据库或任何数据源。</p>
<p>Qt 中与数据模型相关的几个主要的类的层次结构如图 2 所示：</p>
<p><img src="http://c.biancheng.net/uploads/allimg/190103/2-1Z103160KBJ.gif" alt="Qt中模型类的层次结构"></p>
<p>图 2 中的抽象类是不能直接使用的，需要由子类继承来实现一些纯虚函数。Qt 提供了一些模型类用于项数据处理，常见的几个见表 3。</p>
<table>
<thead>
<tr>
<th>Model 类</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>QStringListModel</td>
<td>用于处理字符串列表数据的数据模型类</td>
</tr>
<tr>
<td>QStandardltemModel</td>
<td>标准的基于项数据的数据模型类，每个项数据可以是任何数据类型</td>
</tr>
<tr>
<td>QFileSy stemModel</td>
<td>计算机上文件系统的数据模型类</td>
</tr>
<tr>
<td>QSortFilterProxyModel</td>
<td>与其他数据模型结合，提供排序和过滤功能的数据模型类</td>
</tr>
<tr>
<td>QSqlQueryModel</td>
<td>用于数据库SQL查询结果的数据模型类</td>
</tr>
<tr>
<td>QSqlTableModel</td>
<td>用于数据库的一个数据表的数据模型类</td>
</tr>
<tr>
<td>QSqlRelationalTableModel</td>
<td>用于关系型数据表的数据模型类</td>
</tr>
</tbody></table>
<p>数据库相关的 3 个模型类将在介绍数据库编程时专门说明。如果这些现有的模型类无法满足需求，用户可以从 QAbstractltemModel、QAbstractListModel 或 QAbstractTableModel 继承，生成自己定制的数据模型类。</p>
<h2 id="视图组件"><a href="#视图组件" class="headerlink" title="视图组件"></a>视图组件</h2><p>视图组件（View）就是显示数据模型的数据的界面组件，Qt 提供的视图组件如下：</p>
<ul>
<li>QListView：用于显示单列的列表数据，适用于一维数据的操作。</li>
<li>QTreeView：用于显示树状结构数据，适用于树状结构数据的操作。</li>
<li>QTableView：用于显示表格状数据，适用于二维表格型数据的操作。</li>
<li>QColumnView：用多个QListView显示树状层次结构，树状结构的一层用一个QListView显示。</li>
<li>QHeaderView：提供行表头或列表头的视图组件，如QTableView的行表头和列表头。</li>
</ul>
<p>视图组件在显示数据时，只需调用视图类的 setModel() 函数，为视图组件设置一个数据模型就可以实现视图组件与数据模型之间的关联，在视图组件上的修改将自动保存到关联的数据模型里，一个数据模型可以同时在多个视图组件里显示数据。</p>
<p>前面介绍了 QListWidget、QTreeWidget 和 QtableWidget 3个可用于数据编辑的组件。这 3 个类称为便利类（convenience classes），它们分别是 3 个视图类的子类，其层次关系如图 4 所示。</p>
<p><img src="http://c.biancheng.net/uploads/allimg/190103/2-1Z103160934132.gif" alt="视图相关类的层次结构图"></p>
<p>用于 Model/View 结构的几个视图类直接从 QAbstract ItemView 继承而来，而便利类则从相应的视图类继承而来。</p>
<p>视图组件类的数据采用单独的数据模型，视图组件不存储数据。便利类则为组件的每个节点或单元格创建一个项（item），用项存储数据、格式设置等。所以，便利类没有数据模型，它实际上是用项的方式集成了数据模型的功能，这样就将界面与数据绑定了。</p>
<p>所以，便利类缺乏对大型数据源进行灵活处理的能力，适用于小型数据的显示和编辑。</p>
<h2 id="代理（Delegate）"><a href="#代理（Delegate）" class="headerlink" title="代理（Delegate）"></a>代理（Delegate）</h2><p>代理就是在视图组件上为编辑数据提供编辑器，如在表格组件中编辑一个单元格的数据时，缺省是使用一个 QLineEdit 编辑框。代理负责从数据模型获取相应的数据，然后显示在编辑器里，修改数据后，又将其保存到数据模型中。</p>
<p>QAbstractltemDelegate 是所有代理类的基类，作为抽象类，它不能直接使用。它的一个子类 QStyledltemDelegate，是 Qt 的视图组件缺省使用的代理类。</p>
<p>对于一些特殊的数据编辑需求，例如只允许输入整型数，使用一个 QSpinBox 作为代理组件更恰当，从列表中选择数据时使用一个 QComboBox 作为代理组件更好。这时，就可以从 QStyledltemDelegate 继承创建自定义代理类。</p>
<h2 id="Model-View结构的一些概念"><a href="#Model-View结构的一些概念" class="headerlink" title="Model/View结构的一些概念"></a>Model/View结构的一些概念</h2><p>在 Model/View 结构中，数据模型为视图组件和代理提供存取数据的标准接口。在 Qt 中，所有的数据模型类都从 QAbstractltemModel 继承而来，不管底层的<a href="http://c.biancheng.net/data_structure/">数据结构</a>是如何组织数据的，QAbstractltemModel 的子类都以表格的层次结构表示数据，视图组件通过这种规则来存取模型中的数据，但是表现给用户的形式不一样。</p>
<p><img src="http://c.biancheng.net/uploads/allimg/190103/2-1Z1031610455L.gif" alt="数据模型的几种表现形式"></p>
<p>图 5 是数据模型的 3 种常见表现形式。不管数据模型的表现形式是怎么样的，数据模型中存储数据的基本单元都是项（item），每个项有一个行号、一个列号，还有一个父项。在列表和表格模式下，所有的项都有一个相同的顶层项；在树状结构中，行号、列号、父项稍微复杂一点，但是由这 3 个参数完全可以定义一个项的位置，从而存取项的数据。</p>
<h4 id="模型索引（model-index）"><a href="#模型索引（model-index）" class="headerlink" title="模型索引（model index）"></a>模型索引（model index）</h4><p>为了保证数据的表示与数据存取方式隔离，数据模型中引入了模型索引的概念。通过数据模型存取的每个数据都有一个模型索引，视图组件和代理都通过模型索引来获取数据。</p>
<p>QModelIndex 表示模型索引的类。模型索引提供数据存取的一个临时指针，用于通过数据模型提取或修改数据。因为模型内部组织数据的结构随时可能改变，所以模型索引是临时的。如果需要使用持久性的模型索引，则要使用 QPersistentModelIndex 类。</p>
<h4 id="行号和列号"><a href="#行号和列号" class="headerlink" title="行号和列号"></a>行号和列号</h4><p>数据模型的基本形式是用行和列定义的表格数据，但这并不意味着底层的数据是用二维数组存储的，使用行和列只是为了组件之间交互方便的一种规定。通过模型索引的行号和列号就可以存取数据。</p>
<p>要获得一个模型索引，必须提供 3 个参数：行号、列号、父项的模型索引。例如，对于如图 5 中的表格数据模型中的 3 个数据项 A、B、C，获取其模型索引的代码是：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QModelIndex indexA = model-&gt;<span class="built_in">index</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="built_in">QModelIndex</span>());</span><br><span class="line">QModelIndex indexB = model-&gt;<span class="built_in">index</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="built_in">QModelIndex</span>());</span><br><span class="line">QModelIndex indexC = model-&gt;<span class="built_in">index</span>(<span class="number">2</span>, <span class="number">1</span>, <span class="built_in">QModelIndex</span>());</span><br></pre></td></tr></table></figure>

<p>在创建模型索引的函数中需要传递行号、列号和父项的模型索引。对于列表和表格模式的数据模型，顶层节点总是用 QModelIndex() 表示。</p>
<h4 id="父项"><a href="#父项" class="headerlink" title="父项"></a>父项</h4><p>当数据模型是列表或表格时，使用行号、列号存储数据比较直观，所有数据项的父项就是顶层项；当数据模型是树状结构时，情况比较复杂（树状结构中，项一般习惯于称为节点），一个节点可以有父节点，也可以是其他节点的父节点，在构造数据项的模型索引时，必须指定正确的行号、列号和父节点。</p>
<p>对于图 5 中的树状数据模型，节点 A 和节点 C 的父节点是顶层节点，获取模型索引的代码是：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QModelIndex indexA = model-&gt;<span class="built_in">index</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="built_in">QModelIndex</span>());</span><br><span class="line">QModelIndex indexC = model-&gt;<span class="built_in">index</span>(<span class="number">2</span>, <span class="number">1</span>, <span class="built_in">QModelIndex</span>());</span><br></pre></td></tr></table></figure>

<p>但是，节点 B 的父节点是节点 A，节点 B 的模型索引由下面的代码生成：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QModelIndex indexB = model-&gt;<span class="built_in">index</span>(<span class="number">1</span>, <span class="number">0</span>, indexA);</span><br></pre></td></tr></table></figure>



<h4 id="项的角色"><a href="#项的角色" class="headerlink" title="项的角色"></a>项的角色</h4><p>在为数据模型的一个项设置数据时，可以赋予其不同项的角色的数据。例如，数据模型类 QStandardItemModel 的项数据类是 QStandardItem，其设置数据的函数是：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QStandardItem::setData</span><span class="params">(<span class="keyword">const</span> QVariant &amp;value, <span class="keyword">int</span> role= Qt::UserRole + <span class="number">1</span>)</span></span></span><br></pre></td></tr></table></figure>

<p>其中，value 是需要设置的数据，role 是设置数据的角色。一个项可以有不同角色的数据，用于不同的场合。</p>
<p>role 是 <code>Qt::ItemDataRole</code> 枚举类型，有多种取值，如 <code>Qt::DisplayRole</code> 角色是在视图组件中显示的字符串，<code>Qt::ToolTipRole</code> 是鼠标提示消息，<code>Qt::UserRole</code> 可以自定义数据。项的标准角色是 <code>Qt::DisplayRole</code>。</p>
<p>在获取一个项的数据时也需要指定角色，以获取不同角色的数据：</p>
<p><code>QVariant QStandardItem::data(int role = Qt::UserRole + 1) const</code></p>
<p>为一个项的不同角色定义数据，可以告知视图组件和代理组件如何显示数据。例如，在图 6 中，项的 DisplayRole 数据是显示的字符串，DecorationRole 是用于装饰显示的属性，ToolTipRole 定义了鼠标提示信息。不同的视图组件对各种角色数据的解释和显示可能不一样，也可能忽略某些角色的数据。</p>
<p><img src="http://c.biancheng.net/uploads/allimg/190103/2-1Z103161340927.gif" alt="不同角色数据的表现形式"></p>
]]></content>
      <categories>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>转载</tag>
        <tag>Qt</tag>
        <tag>Model/View</tag>
      </tags>
  </entry>
  <entry>
    <title>About Me</title>
    <url>/2020/07/21/about/</url>
    <content><![CDATA[<h2 id="Skykey"><a href="#Skykey" class="headerlink" title="Skykey"></a>Skykey</h2><h3 id="Hello-World-👋"><a href="#Hello-World-👋" class="headerlink" title="Hello,World! 👋"></a>Hello,World! 👋</h3><p>Hi, I’m Skykey 😉, a programmer 👨🏻‍💻 from China 🇨🇳. I’m an open-source profession and always develop in Cpp/Qt. Currently, I’m working on <a href="https://github.com/QtDocumentCN/QtDocumentCN">QtDocCN</a>. Besides programming, I like delicious food 🥗🥩🌮🍣 and doing sports 🏃⛹️‍♂️🏋🏼‍♂️.</p>
<span id="more"></span>

<p>​    <img align="right" alt="GIF" src="https://media.giphy.com/media/iIqmM5tTjmpOB9mpbn/giphy.gif" /></p>
<p><strong>Current Status Quo</strong></p>
<ul>
<li>👨🏻‍💻 I’m currently working on <a href="https://github.com/QtDocumentCN/QtDocumentCN">QtDocCN</a>.</li>
<li>🌱 I’m currently learning C++/Qt.</li>
<li>🤔  I hope to be a linux system development programmer. 🐧</li>
<li>💬 Ask me about anything and I would like to answer.</li>
<li>📫 Please email via <a href="zcxzxlc@163.com">zcxzxlc@163.com</a> to reach me.</li>
</ul>
<hr>
<p><img src="https://github-readme-stats.vercel.app/api?username=skykeyjoker&show_icons=true&hide_border=true" alt="stats"></p>
<p><img src="https://gitee.com/skykeyjoker/PicCloud/raw/master/img/dino.gif" alt="dino"></p>
]]></content>
  </entry>
  <entry>
    <title>基于C++11实现线程池</title>
    <url>/2021/04/23/cpp11-thread-pool/</url>
    <content><![CDATA[<h1 id="基于C-11实现线程池"><a href="#基于C-11实现线程池" class="headerlink" title="基于C++11实现线程池"></a>基于C++11实现线程池</h1><h2 id="0x00-导入"><a href="#0x00-导入" class="headerlink" title="0x00 导入"></a>0x00 导入</h2><p>前些日子通过阅读几篇博客，大体学习了一下C++的并发编程（主要是多线程、异步部分）。手撸了一个多生产者-多消费者模型之后，最终觉得这也只是小打小闹而已，需要整个硬货。经过一番思考之后，手撸一个线程池貌似是一个非常合适的练习。线程池前前后后一共折腾了四五个小时左右，最令我意外的是——原本以为最难理解的并发部分反而是最简单的部分，线程池实现中大量的CPP11语法糖才是真正影响我理解的部分。经过三四个小时的阅读博文、查阅资料以及向大佬求教之后，我才真正对线程池实现有了比较深入地理解。“纸上得来终觉浅，绝知此事要躬行。”经历这一番折腾后才清楚地认识到了自己对CPP11理解的薄弱，遂写下这篇博客来总结自己对线程池实现以及所涉及到的CPP11语法糖的理解，方便自己以后再次阅读源码时有所考据。</p>
<p>文章大量借鉴、节选了众多参考资料，并结合自己的理解进行讲解。参考资料会在最后列出。</p>
<p>这篇总结会将重心放在C++11的语法糖上，对于C++11的并发编程部分（<code>std::thread</code>, <code>std::future</code>等）将仅进行最简洁最必要的阐述。有关并发编程部分可以移步至几篇大佬总结的比较好的博文中进行补充学习：</p>
<ol>
<li>《C++并发编程（从C++11到C++17）》：<a href="https://paul.pub/cpp-concurrency">https://paul.pub/cpp-concurrency</a></li>
<li>《从pthread转换到std::thread》：<a href="https://segmentfault.com/a/1190000002655852">https://segmentfault.com/a/1190000002655852</a></li>
<li>《货比三家：C++中的task based并发》：<a href="https://segmentfault.com/a/1190000002706259">https://segmentfault.com/a/1190000002706259</a></li>
</ol>
<span id="more"></span>

<h2 id="0x01-逐步实现线程池"><a href="#0x01-逐步实现线程池" class="headerlink" title="0x01 逐步实现线程池"></a>0x01 逐步实现线程池</h2><h3 id="线程池原理"><a href="#线程池原理" class="headerlink" title="线程池原理"></a>线程池原理</h3><p><strong>C++11</strong>加入了线程库，从此告别了标准库不支持并发的历史。然而C++对于多线程的支持还是比较低级，稍微高级一点的用法都需要自己去实现，比如线程池、信号量等。线程池（thread pool）这个东西，一般在面试时的回答都是：“管理一个任务队列，一个线程队列，然后每次去一个任务分配给一个线程去做，循环往复。”这回答貌似没有问题，但是写起程序来的时候就出问题了。</p>
<p>有什么问题？线程池一般是要复用线程，所以如果是取一个task分配给某一个thread，执行完之后再重新分配，在语言层面这是基本不能实现的：C++的thread都是执行一个固定的task函数，执行完之后线程也就结束了。所以该如何实现task和thread的分配呢？</p>
<p><strong>让每一个thread创建后，就去执行调度函数：循环获取task，然后执行。</strong></p>
<p>这个循环该什么时候停止呢？</p>
<p>很简单，<strong>当线程池停止使用时</strong>，循环停止。</p>
<p>这样一来，就保证了thread函数的唯一性，而且复用线程执行task。</p>
<p>总结一下，我们的线程池的主要组成部分有二：</p>
<ul>
<li>任务队列（Task Queue）</li>
<li>线程池（Thread Pool）</li>
</ul>
<p>线程池与任务队列之间的匹配操作，是典型的<em>生产者-消费者</em>模型，本模型使用了两个工具：一个==mutex== + 一个==条件变量==。mutex就是锁，保证任务的添加和移除（获取）的互斥性；一个条件变量保证多个线程获取task的同步性：当任务队列为空时，线程应该等待（阻塞）。</p>
<p>接下来我们就可以逐渐将一块块积木拼成一个完整的简易线程池。</p>
<h3 id="积木1：任务队列（Task-Queue）"><a href="#积木1：任务队列（Task-Queue）" class="headerlink" title="积木1：任务队列（Task Queue）"></a>积木1：任务队列（Task Queue）</h3><p>我们会理所当然地希望任务以发送它相同的顺序来逐个执行，因此队列是最适合的数据结构。</p>
<p>这里我们把任务队列单拿出来，独自为类，方便以后进行各种骚操作。</p>
<p>将任务队列单拿出来之后，我们应考虑一个问题：正如上一节提到的线程池task与thread的分配方法所示，线程池中的线程会持续查询任务队列是否有可用工作。当两个甚至多个线程试图同时执行查询工作时，这会引起难以估计的灾难。因而我们需要对C++的<code>std::queue</code>进行包装，实现一个<strong>线程安全</strong>的<em>SafeQueue</em>。</p>
<p>实现一个线程安全的<em>SafeQueue</em>原理很简单，利用<strong>mutex</strong>来限制并发访问即可。我们可以在<em>SafeQueue</em>类中定义一个<code>std::mutex</code>类型的成员变量，并在相应的操作接口（如入队接口<code>enqueue()</code>）中利用互斥体包装器来管理这个mutex，确保没有其他人正在访问该资源。</p>
<p>下面给出完整的<em>SafeQueue</em>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SafeQueue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::queue&lt;T&gt; m_queue; <span class="comment">//利用模板函数构造队列</span></span><br><span class="line"></span><br><span class="line">    std::mutex m_mutex; <span class="comment">// 访问互斥信号量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SafeQueue</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">SafeQueue</span>(SafeQueue &amp;&amp;other) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">SafeQueue</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="comment">// 返回队列是否为空</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_mutex)</span></span>; <span class="comment">// 互斥信号变量加锁，防止m_queue被改变</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> m_queue.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_mutex)</span></span>; <span class="comment">// 互斥信号变量加锁，防止m_queue被改变</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> m_queue.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 队列添加元素</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(T &amp;t)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">        m_queue.<span class="built_in">emplace</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 队列取出元素</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dequeue</span><span class="params">(T &amp;t)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_mutex)</span></span>; <span class="comment">// 队列加锁</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (m_queue.<span class="built_in">empty</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        t = std::<span class="built_in">move</span>(m_queue.<span class="built_in">front</span>()); <span class="comment">// 取出队首元素，返回队首元素值，并进行右值引用</span></span><br><span class="line"></span><br><span class="line">        m_queue.<span class="built_in">pop</span>(); <span class="comment">// 弹出入队的第一个元素</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="积木2：线程池（Thread-Pool）"><a href="#积木2：线程池（Thread-Pool）" class="headerlink" title="积木2：线程池（Thread Pool）"></a>积木2：线程池（Thread Pool）</h3><p>线程池是线程池模型的主体，我们将它拆成更小的部分来逐步分析，方便理解。</p>
<h4 id="2-1-提交函数"><a href="#2-1-提交函数" class="headerlink" title="2-1 提交函数"></a>2-1 提交函数</h4><p>线程池最重要的方法就是负责向任务队列添加任务。我们的提交函数应该做到以下两点：</p>
<ul>
<li>接收任何参数的任何函数。（普通函数，==Lambda==，==成员函数==……）</li>
<li>立即返回“东西”，避免阻塞主线程。这里返回的“东西”或者说“对象”应该包含任务结束的结果。</li>
</ul>
<p>完整的提交函数如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Submit a function to be executed asynchronously by the pool</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">submit</span><span class="params">(F &amp;&amp;f, Args &amp;&amp;...args)</span> -&gt; std::future&lt;<span class="title">decltype</span><span class="params">(f(args...))</span>&gt; ①</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// Create a function with bounded parameter ready to execute</span></span><br><span class="line">        std::function&lt;<span class="keyword">decltype</span>(<span class="built_in">f</span>(args...))()&gt; func = std::<span class="built_in">bind</span>(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...); ②<span class="comment">// 连接函数和参数定义，特殊函数类型，避免左右值错误</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Encapsulate it into a shared pointer in order to be able to copy construct</span></span><br><span class="line">        <span class="keyword">auto</span> task_ptr = std::make_shared&lt;std::packaged_task&lt;<span class="keyword">decltype</span>(<span class="built_in">f</span>(args...))()&gt;&gt;(func);  ③</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Warp packaged task into void function</span></span><br><span class="line">        std::function&lt;<span class="built_in"><span class="keyword">void</span></span>()&gt; warpper_func = [task_ptr]()</span><br><span class="line">        &#123;</span><br><span class="line">            (*task_ptr)();</span><br><span class="line">        &#125;;  ④</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 队列通用安全封包函数，并压入安全队列</span></span><br><span class="line">        m_queue.<span class="built_in">enqueue</span>(warpper_func);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 唤醒一个等待中的线程</span></span><br><span class="line">        m_conditional_lock.<span class="built_in">notify_one</span>();  ⑤</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回先前注册的任务指针</span></span><br><span class="line">        <span class="keyword">return</span> task_ptr-&gt;<span class="built_in">get_future</span>();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>C++11众多的语法糖正式来袭。下面讲一下需要注意的地方：</p>
<ol>
<li><p><code>submit()</code>是一个模板函数，这很明显。<code>template&lt;typename F, typename... Args&gt;</code>中的<code>typename... Args</code>是C++11引入的<strong>可变模版参数</strong>（variadic templates），很容易理解。</p>
<p>首先来看长得奇奇怪怪的函数头部分，<code>auto submit(F &amp;&amp;f, Args &amp;&amp;...args) -&gt; std::future&lt;decltype(f(args...))&gt;</code>，这里函数类型的定义用到了叫做<strong>“尾返回类型推导”</strong>的技巧。</p>
<p>按照标准，<code>auto</code>关键字不能用于函数形参的类型推导，==在C++14以前==，也不能直接用<code>auto func()</code>的形式来推导函数的返回类型。</p>
<p>因此传统C++中我们必须这么写：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function">R <span class="title">add</span><span class="params">(T x, U y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样存在很明显的缺陷：事实上很多时候我们并不知道<code>add()</code>这个函数会进行什么操作，获取什么样的返回类型。</p>
<p>最终在C++11中这个问题得到了解决。C++11关键字<code>decltype</code>解决了<code>auto</code>关键字只能对变量类型进行类型推导的缺陷。它的用法也很简单，应该也是看过C++11标准就能记住的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(表达式)</span><br></pre></td></tr></table></figure>

<p>但是为了利用<code>decltype</code>来推导函数的返回类型，我们并不能直接写出这种形式的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(x+y) <span class="built_in">add</span>(T x, U y)</span><br></pre></td></tr></table></figure>

<p>因为编译器在读到<code>decltype(x+y)</code>时，<code>x</code>和<code>y</code>尚未定义。而这个问题的解决方案，正是<strong>尾返回类型推导</strong>。C++11引入了一个<strong>尾返回类型</strong>（trailing return type），利用<code>auto</code>关键字将返回类型后置：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add2</span><span class="params">(T x, U y)</span> -&gt; <span class="title">decltype</span><span class="params">(x+y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，看起来奇奇怪怪的函数头中关于函数的返回类型的定义已经清楚明了：该函数的返回值将从<code>std::future&lt;decltype(f(args...))&gt;</code>中自动推导得出。</p>
<p>接着谈函数头。这里我们谈一下<code>std::future</code>，它提供了一个==访问异步操作结果==的途径。我们可以使用<code>std::future</code>的<code>wait()</code>方法来设置屏障，阻塞线程，实现线程同步。并最终使用<code>std::future</code>的<code>get()</code>方法来获得执行结果。</p>
<p>对于<code>std::future</code>，可以在这篇文献中找到更详细的讲解：</p>
<p><a href="https://changkun.de/modern-cpp/zh-cn/07-thread/index.html#7-3-%E6%9C%9F%E7%89%A9">https://changkun.de/modern-cpp/zh-cn/07-thread/index.html#7-3-%E6%9C%9F%E7%89%A9</a></p>
<p>总的来说，在我们的程序中，最后将会获得返回类型为 实例化为<code>f(args...)</code>的<code>std::future&lt;&gt;</code> 的<code>submit</code>函数。</p>
<p>如果我们阅读其他一些博文或者Github上著名的99行C++11实现线程池，我们可能会看到以下形式的添加任务方法的定义：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">ThreadPool::enqueue</span><span class="params">(F&amp;&amp; f, Args&amp;&amp;... args)</span> -&gt; std::future&lt;<span class="keyword">typename</span> std::result_of&lt;<span class="title">F</span><span class="params">(Args...)</span>&gt;::type&gt;</span></span><br></pre></td></tr></table></figure>

<p>为什么我们这里不采用<code>std::result_of&lt;&gt;::type</code>的方法而是使用<code>decltype(f(args...))</code>方法，这个要结合下一点来理解。</p>
</li>
<li><p>这里我们使用了<code>std::function</code>进行包装从而产生了一个特殊函数，这个特殊函数使用<code>std::bind</code>将函数<code>f</code>和参数<code>args</code>绑定起来。</p>
<p>简单来说，<code>std::function</code>可以对多个相似的函数进行包装（即通用的描述方法）。<code>std::function</code>可以hold住任何可以通过“()”来调用的对象，包括：</p>
<ul>
<li>普通函数</li>
<li>成员函数</li>
<li>lambda</li>
<li><code>std::bind</code></li>
</ul>
<p>而<code>std::bind</code>可以<strong>将调用函数时的部分参数先制定好，留下一部分在真正调用时确定</strong>。（当然，你也可以直接指定全部参数，在调用时不再指定。）</p>
<p>对于<code>std::function</code>和<code>std::bind</code>，我们可以移步这篇博客获得更详细的讲解：</p>
<p><a href="https://paul.pub/cpp-lambda-function-bind/">https://paul.pub/cpp-lambda-function-bind/</a></p>
<p>这里我们会注意到，<code>std::bind</code>中，出现了一个<code>std::forward()</code>的特殊方法。<code>std::forward()</code>又被称作<strong>完美转发</strong>。简单来说，<code>std::forward()</code>将会完整保留参数的引用类型进行转发。如果参数是左值引用（<em>lvalue</em>），该方法会将参数保留左值引用的形式进行转发，如果参数是右值引用（<em>rvalue</em>），该方法会将参数保留右值引用的形式进行转发。而我们这里为什么要使用这个方法呢？</p>
<p>我们会对为什么使用<code>std::forward()</code>方法产生疑惑，可能是因为我们看到了函数头中的<code>F&amp;&amp; f</code>和<code>Args&amp;&amp;... args</code>，这难道不已经指明这个函数接收的参数类型应为右值引用吗？<strong>其实不然。</strong>这里的<code>F&amp;&amp; f</code>和<code>Args&amp;&amp;... args</code>中的<code>&amp;&amp;</code>并非是右值引用意思，而是一种特殊现象，这个现象被称作<strong>万能引用</strong>（universal reference）。</p>
<p><strong>万能引用</strong>可以简单理解为，当<code>T</code>是模板参数时，<code>T&amp;&amp;</code>的作用主要是保持值类别进行转发。然而，<strong>一个绑定到universial reference上的对象可能具有lvaluesness或者rvalueness，正是因为有这种二义性</strong>，所以产生了<code>std::forward</code>。</p>
<p>有关于万能引用、完美转发以及背后所隐藏的引用折叠，可以在这篇知乎回答中找到更详细的介绍：</p>
<p><a href="https://zhuanlan.zhihu.com/p/99524127">https://zhuanlan.zhihu.com/p/99524127</a></p>
<p>总的来说，②会产生一个以 函数<code>f(arg...)</code>返回类型 为返回类型、不含参数的特殊函数包装<code>func</code>。</p>
<p>这里我们也不难注意到，在网上其他的示例中，这里使用了如下方法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> return_type = <span class="keyword">typename</span> std::result_of&lt;<span class="built_in">F</span>(Args...)&gt;::type;</span><br></pre></td></tr></table></figure>

<p>可以看到，这里再次像这些示例在函数头中一样，使用了<code>std::result_of</code>方法，而结合上文，我们也不难理解为什么本文会使用<code>std::function</code>方法，即更方便地增加对将成员函数和lambda表达式作为参数的支持。</p>
</li>
<li><p>这里我们使用<code>std::make_shared&lt;&gt;()</code>方法，声明了一个<code>std::packaged_task&lt;decltype(f(args...))()&gt;</code>类型的智能指针，并将前面<code>std::function</code>方法声明的特殊函数包装<code>func</code>传入作为<code>std::packaged_task</code>的实例化参数。智能指针将更方便我们对该<code>std::packaged_task</code>对象进行管理。</p>
<p><code>std::packaged_task</code>可以用来封装任何可以调用的目标，从而用于实现异步的调用。</p>
</li>
<li><p>这里我们再次利用<code>std::function</code>，将<em>task_ptr</em>指向的<strong>std::packaged_task</strong>对象取出并包装为void函数。这样我们的代码将更加美观优雅。</p>
<p>当然，我们也可以像其他示例一样，将这一步和下一步任务进入队列操作简化为一步：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">m_queue.<span class="built_in">enqueue</span>([task_ptr]()&#123;</span><br><span class="line">    (*task_ptr)();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li><p>这里条件变量会通知一个处于<em>wait</em>状态的线程，该线程将会从任务队列中取得任务并执行。</p>
<p>这里简要介绍一下条件变量（<code>std::condition_variable</code>）：</p>
<p>条件变量 <code>std::condition_variable</code> 是为了解决死锁而生，当互斥操作不够用而引入的。比如，线程可能需要等待某个条件为真才能继续执行，而一个忙等待循环中可能会导致所有其他线程都无法进入临界区使得条件为真时，就会发生死锁。所以，<code>condition_variable</code>实例被创建出现主要就是用于唤醒等待线程从而避免死锁。<code>std::condition_variable</code>的<code>notify_one()</code>用于唤醒一个线程；<code>notify_all()</code>则是通知所有线程。</p>
</li>
</ol>
<p>提交函数到此结束。</p>
<hr>
<h4 id="2-2-内置工作线程类"><a href="#2-2-内置工作线程类" class="headerlink" title="2-2 内置工作线程类"></a>2-2 内置工作线程类</h4><p>本文在线程池中设立私有成员类<em>ThreadWoker</em>作为内置线程工作类，执行真正的工作。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadWorker</span> // 内置线程工作类</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_id; <span class="comment">// 工作id</span></span><br><span class="line"></span><br><span class="line">    ThreadPool *m_pool; <span class="comment">// 所属线程池</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">ThreadWorker</span>(ThreadPool *pool, <span class="keyword">const</span> <span class="keyword">int</span> id) : <span class="built_in">m_pool</span>(pool), <span class="built_in">m_id</span>(id)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载()操作</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::function&lt;<span class="built_in"><span class="keyword">void</span></span>()&gt; func; <span class="comment">// 定义基础函数类func</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> dequeued; <span class="comment">// 是否正在取出队列中元素</span></span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 判断线程池是否关闭，没有关闭则从任务队列中循环提取任务</span></span><br><span class="line">        <span class="keyword">while</span> (!m_pool-&gt;m_shutdown)</span><br><span class="line">        &#123;</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 为线程环境加锁，互访问工作线程的休眠和唤醒</span></span><br><span class="line">                <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_pool-&gt;m_conditional_mutex)</span></span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果任务队列为空，阻塞当前线程</span></span><br><span class="line">                <span class="keyword">if</span> (m_pool-&gt;m_queue.<span class="built_in">empty</span>())</span><br><span class="line">                &#123;</span><br><span class="line">                    m_pool-&gt;m_conditional_lock.<span class="built_in">wait</span>(lock); <span class="comment">// 等待条件变量通知，开启线程</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 取出任务队列中的元素</span></span><br><span class="line">                dequeued = m_pool-&gt;m_queue.<span class="built_in">dequeue</span>(func);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果成功取出，执行工作函数</span></span><br><span class="line">            <span class="keyword">if</span> (dequeued)</span><br><span class="line">                <span class="built_in">func</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里应该重点关注重载()操作的<code>void operator()()</code>，这里面进行了任务的取出与执行。</p>
<p>参照注释和上文，我们使用了一个while循环，在线程池处于工作时循环从任务队列中提取任务。并利用条件变量，在任务队列为空时阻塞当前线程，等待上文中的提交函数添加任务后发出的通知。在任务队列不为空时，我们将任务队列中的任务取出，并放在事先声明的基础函数类<em>func</em>中。成功取出后便立即执行该任务。</p>
<h4 id="线程池完整代码"><a href="#线程池完整代码" class="headerlink" title="线程池完整代码"></a>线程池完整代码</h4><p>下面给出线程池的完整代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadPool</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ThreadWorker</span> // 内置线程工作类</span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> m_id; <span class="comment">// 工作id</span></span><br><span class="line"></span><br><span class="line">        ThreadPool *m_pool; <span class="comment">// 所属线程池</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// 构造函数</span></span><br><span class="line">        <span class="built_in">ThreadWorker</span>(ThreadPool *pool, <span class="keyword">const</span> <span class="keyword">int</span> id) : <span class="built_in">m_pool</span>(pool), <span class="built_in">m_id</span>(id)</span><br><span class="line">        &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重载()操作</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            std::function&lt;<span class="built_in"><span class="keyword">void</span></span>()&gt; func; <span class="comment">// 定义基础函数类func</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">bool</span> dequeued; <span class="comment">// 是否正在取出队列中元素</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (!m_pool-&gt;m_shutdown)</span><br><span class="line">            &#123;</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 为线程环境加锁，互访问工作线程的休眠和唤醒</span></span><br><span class="line">                    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_pool-&gt;m_conditional_mutex)</span></span>;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 如果任务队列为空，阻塞当前线程</span></span><br><span class="line">                    <span class="keyword">if</span> (m_pool-&gt;m_queue.<span class="built_in">empty</span>())</span><br><span class="line">                    &#123;</span><br><span class="line">                        m_pool-&gt;m_conditional_lock.<span class="built_in">wait</span>(lock); <span class="comment">// 等待条件变量通知，开启线程</span></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 取出任务队列中的元素</span></span><br><span class="line">                    dequeued = m_pool-&gt;m_queue.<span class="built_in">dequeue</span>(func);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果成功取出，执行工作函数</span></span><br><span class="line">                <span class="keyword">if</span> (dequeued)</span><br><span class="line">                    <span class="built_in">func</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> m_shutdown; <span class="comment">// 线程池是否关闭</span></span><br><span class="line"></span><br><span class="line">    SafeQueue&lt;std::function&lt;<span class="built_in"><span class="keyword">void</span></span>()&gt;&gt; m_queue; <span class="comment">// 执行函数安全队列，即任务队列</span></span><br><span class="line"></span><br><span class="line">    std::vector&lt;std::thread&gt; m_threads; <span class="comment">// 工作线程队列</span></span><br><span class="line"></span><br><span class="line">    std::mutex m_conditional_mutex; <span class="comment">// 线程休眠锁互斥变量</span></span><br><span class="line"></span><br><span class="line">    std::condition_variable m_conditional_lock; <span class="comment">// 线程环境锁，可以让线程处于休眠或者唤醒状态</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 线程池构造函数</span></span><br><span class="line">    <span class="built_in">ThreadPool</span>(<span class="keyword">const</span> <span class="keyword">int</span> n_threads = <span class="number">4</span>)</span><br><span class="line">        : <span class="built_in">m_threads</span>(std::vector&lt;std::thread&gt;(n_threads)), <span class="built_in">m_shutdown</span>(<span class="literal">false</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ThreadPool</span>(<span class="keyword">const</span> ThreadPool &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ThreadPool</span>(ThreadPool &amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    ThreadPool &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> ThreadPool &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    ThreadPool &amp;<span class="keyword">operator</span>=(ThreadPool &amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Inits thread pool</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m_threads.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            m_threads.<span class="built_in">at</span>(i) = std::<span class="built_in">thread</span>(<span class="built_in">ThreadWorker</span>(<span class="keyword">this</span>, i)); <span class="comment">// 分配工作线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Waits until threads finish their current task and shutdowns the pool</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_shutdown = <span class="literal">true</span>;</span><br><span class="line">        m_conditional_lock.<span class="built_in">notify_all</span>(); <span class="comment">// 通知，唤醒所有工作线程</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m_threads.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (m_threads.<span class="built_in">at</span>(i).<span class="built_in">joinable</span>()) <span class="comment">// 判断线程是否在等待</span></span><br><span class="line">            &#123;</span><br><span class="line">                m_threads.<span class="built_in">at</span>(i).<span class="built_in">join</span>(); <span class="comment">// 将线程加入到等待队列</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Submit a function to be executed asynchronously by the pool</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">submit</span><span class="params">(F &amp;&amp;f, Args &amp;&amp;...args)</span> -&gt; std::future&lt;<span class="title">decltype</span><span class="params">(f(args...))</span>&gt;</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// Create a function with bounded parameter ready to execute</span></span><br><span class="line">        std::function&lt;<span class="keyword">decltype</span>(<span class="built_in">f</span>(args...))()&gt; func = std::<span class="built_in">bind</span>(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...); <span class="comment">// 连接函数和参数定义，特殊函数类型，避免左右值错误</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Encapsulate it into a shared pointer in order to be able to copy construct</span></span><br><span class="line">        <span class="keyword">auto</span> task_ptr = std::make_shared&lt;std::packaged_task&lt;<span class="keyword">decltype</span>(<span class="built_in">f</span>(args...))()&gt;&gt;(func);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Warp packaged task into void function</span></span><br><span class="line">        std::function&lt;<span class="built_in"><span class="keyword">void</span></span>()&gt; warpper_func = [task_ptr]()</span><br><span class="line">        &#123;</span><br><span class="line">            (*task_ptr)();</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 队列通用安全封包函数，并压入安全队列</span></span><br><span class="line">        m_queue.<span class="built_in">enqueue</span>(warpper_func);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 唤醒一个等待中的线程</span></span><br><span class="line">        m_conditional_lock.<span class="built_in">notify_one</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回先前注册的任务指针</span></span><br><span class="line">        <span class="keyword">return</span> task_ptr-&gt;<span class="built_in">get_future</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>结合注释应该能很轻松的理解线程池剩余的代码。</p>
<p>注意一下<code>init()</code>函数和<code>shutdown()</code>函数：</p>
<ul>
<li>在线程池初始化函数<code>init()</code>中，我们声明并分配工作线程，将工作线程放入工作线程队列<em>m_threads</em>中。</li>
<li>在线程池关闭函数<code>shutdown()</code>中，我们唤醒所有工作线程，并等待期完成所有工作后关闭线程池。</li>
</ul>
<p>这里我们也可以改进一下代码，将<code>shutdown()</code>函数中的工作转移到<em>ThreadPool</em>的析构函数中，从而更便利日后的使用。</p>
<p>至此，线程池全文讲解结束，后附完整项目代码及参考资料。</p>
<h2 id="0x02-项目完整代码"><a href="#0x02-项目完整代码" class="headerlink" title="0x02 项目完整代码"></a>0x02 项目完整代码</h2><h3 id="线程池代码"><a href="#线程池代码" class="headerlink" title="线程池代码"></a>线程池代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//thread_pool.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> THREAD_POOL_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THREAD_POOL_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Thread safe implementation of a Queue using a std::queue</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SafeQueue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::queue&lt;T&gt; m_queue; <span class="comment">//利用模板函数构造队列</span></span><br><span class="line"></span><br><span class="line">    std::mutex m_mutex; <span class="comment">// 访问互斥信号量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SafeQueue</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">SafeQueue</span>(SafeQueue &amp;&amp;other) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">SafeQueue</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="comment">// 返回队列是否为空</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_mutex)</span></span>; <span class="comment">// 互斥信号变量加锁，防止m_queue被改变</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> m_queue.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_mutex)</span></span>; <span class="comment">// 互斥信号变量加锁，防止m_queue被改变</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> m_queue.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 队列添加元素</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(T &amp;t)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">        m_queue.<span class="built_in">emplace</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 队列取出元素</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dequeue</span><span class="params">(T &amp;t)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_mutex)</span></span>; <span class="comment">// 队列加锁</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (m_queue.<span class="built_in">empty</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        t = std::<span class="built_in">move</span>(m_queue.<span class="built_in">front</span>()); <span class="comment">// 取出队首元素，返回队首元素值，并进行右值引用</span></span><br><span class="line"></span><br><span class="line">        m_queue.<span class="built_in">pop</span>(); <span class="comment">// 弹出入队的第一个元素</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadPool</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ThreadWorker</span> // 内置线程工作类</span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> m_id; <span class="comment">// 工作id</span></span><br><span class="line"></span><br><span class="line">        ThreadPool *m_pool; <span class="comment">// 所属线程池</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// 构造函数</span></span><br><span class="line">        <span class="built_in">ThreadWorker</span>(ThreadPool *pool, <span class="keyword">const</span> <span class="keyword">int</span> id) : <span class="built_in">m_pool</span>(pool), <span class="built_in">m_id</span>(id)</span><br><span class="line">        &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重载()操作</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            std::function&lt;<span class="built_in"><span class="keyword">void</span></span>()&gt; func; <span class="comment">// 定义基础函数类func</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">bool</span> dequeued; <span class="comment">// 是否正在取出队列中元素</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (!m_pool-&gt;m_shutdown)</span><br><span class="line">            &#123;</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 为线程环境加锁，互访问工作线程的休眠和唤醒</span></span><br><span class="line">                    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_pool-&gt;m_conditional_mutex)</span></span>;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 如果任务队列为空，阻塞当前线程</span></span><br><span class="line">                    <span class="keyword">if</span> (m_pool-&gt;m_queue.<span class="built_in">empty</span>())</span><br><span class="line">                    &#123;</span><br><span class="line">                        m_pool-&gt;m_conditional_lock.<span class="built_in">wait</span>(lock); <span class="comment">// 等待条件变量通知，开启线程</span></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 取出任务队列中的元素</span></span><br><span class="line">                    dequeued = m_pool-&gt;m_queue.<span class="built_in">dequeue</span>(func);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果成功取出，执行工作函数</span></span><br><span class="line">                <span class="keyword">if</span> (dequeued)</span><br><span class="line">                    <span class="built_in">func</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> m_shutdown; <span class="comment">// 线程池是否关闭</span></span><br><span class="line"></span><br><span class="line">    SafeQueue&lt;std::function&lt;<span class="built_in"><span class="keyword">void</span></span>()&gt;&gt; m_queue; <span class="comment">// 执行函数安全队列，即任务队列</span></span><br><span class="line"></span><br><span class="line">    std::vector&lt;std::thread&gt; m_threads; <span class="comment">// 工作线程队列</span></span><br><span class="line"></span><br><span class="line">    std::mutex m_conditional_mutex; <span class="comment">// 线程休眠锁互斥变量</span></span><br><span class="line"></span><br><span class="line">    std::condition_variable m_conditional_lock; <span class="comment">// 线程环境锁，可以让线程处于休眠或者唤醒状态</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 线程池构造函数</span></span><br><span class="line">    <span class="built_in">ThreadPool</span>(<span class="keyword">const</span> <span class="keyword">int</span> n_threads = <span class="number">4</span>)</span><br><span class="line">        : <span class="built_in">m_threads</span>(std::vector&lt;std::thread&gt;(n_threads)), <span class="built_in">m_shutdown</span>(<span class="literal">false</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ThreadPool</span>(<span class="keyword">const</span> ThreadPool &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ThreadPool</span>(ThreadPool &amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    ThreadPool &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> ThreadPool &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    ThreadPool &amp;<span class="keyword">operator</span>=(ThreadPool &amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Inits thread pool</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m_threads.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            m_threads.<span class="built_in">at</span>(i) = std::<span class="built_in">thread</span>(<span class="built_in">ThreadWorker</span>(<span class="keyword">this</span>, i)); <span class="comment">// 分配工作线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Waits until threads finish their current task and shutdowns the pool</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_shutdown = <span class="literal">true</span>;</span><br><span class="line">        m_conditional_lock.<span class="built_in">notify_all</span>(); <span class="comment">// 通知，唤醒所有工作线程</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m_threads.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (m_threads.<span class="built_in">at</span>(i).<span class="built_in">joinable</span>()) <span class="comment">// 判断线程是否在等待</span></span><br><span class="line">            &#123;</span><br><span class="line">                m_threads.<span class="built_in">at</span>(i).<span class="built_in">join</span>(); <span class="comment">// 将线程加入到等待队列</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Submit a function to be executed asynchronously by the pool</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">submit</span><span class="params">(F &amp;&amp;f, Args &amp;&amp;...args)</span> -&gt; std::future&lt;<span class="title">decltype</span><span class="params">(f(args...))</span>&gt;</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// Create a function with bounded parameter ready to execute</span></span><br><span class="line">        std::function&lt;<span class="keyword">decltype</span>(<span class="built_in">f</span>(args...))()&gt; func = std::<span class="built_in">bind</span>(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...); <span class="comment">// 连接函数和参数定义，特殊函数类型，避免左右值错误</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Encapsulate it into a shared pointer in order to be able to copy construct</span></span><br><span class="line">        <span class="keyword">auto</span> task_ptr = std::make_shared&lt;std::packaged_task&lt;<span class="keyword">decltype</span>(<span class="built_in">f</span>(args...))()&gt;&gt;(func);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Warp packaged task into void function</span></span><br><span class="line">        std::function&lt;<span class="built_in"><span class="keyword">void</span></span>()&gt; warpper_func = [task_ptr]()</span><br><span class="line">        &#123;</span><br><span class="line">            (*task_ptr)();</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 队列通用安全封包函数，并压入安全队列</span></span><br><span class="line">        m_queue.<span class="built_in">enqueue</span>(warpper_func);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 唤醒一个等待中的线程</span></span><br><span class="line">        m_conditional_lock.<span class="built_in">notify_one</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回先前注册的任务指针</span></span><br><span class="line">        <span class="keyword">return</span> task_ptr-&gt;<span class="built_in">get_future</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>



<h3 id="测试样例代码"><a href="#测试样例代码" class="headerlink" title="测试样例代码"></a>测试样例代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;random&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;thread_pool.h&quot;</span></span></span><br><span class="line">std::random_device rd; <span class="comment">// 真实随机数产生器</span></span><br><span class="line"></span><br><span class="line"><span class="function">std::mt19937 <span class="title">mt</span><span class="params">(rd())</span></span>; <span class="comment">//生成计算随机数mt</span></span><br><span class="line"></span><br><span class="line"><span class="function">std::uniform_int_distribution&lt;<span class="keyword">int</span>&gt; <span class="title">dist</span><span class="params">(<span class="number">-1000</span>, <span class="number">1000</span>)</span></span>; <span class="comment">//生成-1000到1000之间的离散均匀分布数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> rnd = std::<span class="built_in">bind</span>(dist, mt);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置线程睡眠时间</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">simulate_hard_computation</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">2000</span> + <span class="built_in">rnd</span>()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加两个数字的简单函数并打印结果</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">multiply</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> a, <span class="keyword">const</span> <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">simulate_hard_computation</span>();</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> res = a * b;</span><br><span class="line">    std::cout &lt;&lt; a &lt;&lt; <span class="string">&quot; * &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; res &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加并输出结果</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">multiply_output</span><span class="params">(<span class="keyword">int</span> &amp;out, <span class="keyword">const</span> <span class="keyword">int</span> a, <span class="keyword">const</span> <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">simulate_hard_computation</span>();</span><br><span class="line">    out = a * b;</span><br><span class="line">    std::cout &lt;&lt; a &lt;&lt; <span class="string">&quot; * &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; out &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果返回</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">multiply_return</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> a, <span class="keyword">const</span> <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">simulate_hard_computation</span>();</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> res = a * b;</span><br><span class="line">    std::cout &lt;&lt; a &lt;&lt; <span class="string">&quot; * &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; res &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">example</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建3个线程的线程池</span></span><br><span class="line">    <span class="function">ThreadPool <span class="title">pool</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化线程池</span></span><br><span class="line">    pool.<span class="built_in">init</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提交乘法操作，总共30个</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">10</span>; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            pool.<span class="built_in">submit</span>(multiply, i, j);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用ref传递的输出参数提交函数</span></span><br><span class="line">    <span class="keyword">int</span> output_ref;</span><br><span class="line">    <span class="keyword">auto</span> future1 = pool.<span class="built_in">submit</span>(multiply_output, std::<span class="built_in">ref</span>(output_ref), <span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待乘法输出完成</span></span><br><span class="line">    future1.<span class="built_in">get</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Last operation result is equals to &quot;</span> &lt;&lt; output_ref &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用return参数提交函数</span></span><br><span class="line">    <span class="keyword">auto</span> future2 = pool.<span class="built_in">submit</span>(multiply_return, <span class="number">5</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待乘法输出完成</span></span><br><span class="line">    <span class="keyword">int</span> res = future2.<span class="built_in">get</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Last operation result is equals to &quot;</span> &lt;&lt; res &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭线程池</span></span><br><span class="line">    pool.<span class="built_in">shutdown</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">example</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="0x03-参考资料"><a href="#0x03-参考资料" class="headerlink" title="0x03 参考资料"></a>0x03 参考资料</h2><ol>
<li>《C++后端线程池》：<a href="https://wangpengcheng.github.io/2019/05/17/cplusplus_theadpool/">https://wangpengcheng.github.io/2019/05/17/cplusplus_theadpool/</a></li>
<li>《基于C++11的线程池（threadpool），简介且可以带任意多的参数》：<a href="https://www.cnblogs.com/lzpong/p/6397997.html">https://www.cnblogs.com/lzpong/p/6397997.html</a></li>
<li>《C++并发编程（从C++11到C++17）》：<a href="https://paul.pub/cpp-concurrency">https://paul.pub/cpp-concurrency</a></li>
<li>《从pthread转换到std::thread》：<a href="https://segmentfault.com/a/1190000002655852">https://segmentfault.com/a/1190000002655852</a></li>
<li>《货比三家：C++中的task based并发》：<a href="https://segmentfault.com/a/1190000002706259">https://segmentfault.com/a/1190000002706259</a></li>
<li>Github-99行线程池实现：<a href="https://github.com/progschj/ThreadPool">https://github.com/progschj/ThreadPool</a></li>
<li>《现代C++之万能引用、完美转发、引用折叠》：<a href="https://zhuanlan.zhihu.com/p/99524127">https://zhuanlan.zhihu.com/p/99524127</a></li>
<li>《C++11中的lambda，std::function以及std:bind》：<a href="https://paul.pub/cpp-lambda-function-bind/">https://paul.pub/cpp-lambda-function-bind/</a></li>
<li>《现代C++教程——告诉上手C++11/14/17/20》：<a href="https://changkun.de/modern-cpp/">https://changkun.de/modern-cpp/</a></li>
</ol>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++11</tag>
        <tag>C++高并发</tag>
        <tag>C++线程池</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL on Qt (1):安装 MySQL 驱动以及连接 MySQL 与 SQLite</title>
    <url>/2020/07/22/mysqlonqt1/</url>
    <content><![CDATA[<h1 id="MySQL-on-Qt-1-安装-MySQL-驱动以及连接-MySQL-与-SQLite"><a href="#MySQL-on-Qt-1-安装-MySQL-驱动以及连接-MySQL-与-SQLite" class="headerlink" title="MySQL on Qt (1): 安装 MySQL 驱动以及连接 MySQL 与 SQLite"></a>MySQL on Qt (1): 安装 MySQL 驱动以及连接 MySQL 与 SQLite</h1><blockquote>
<p>写在前面： </p>
<p>大一下学期的 CPP 大作业“自主订餐系统”可真是颇费了一些力气，每天晚睡早起撸代码，课都没听，很多知识都是现学现用。</p>
<p>为了避免当时学到的东西给全部忘光光（`_&gt;`，我这脑子啊。。。），所以我把当时大作业的一些核心部分（一些零碎的小细节，能记就记）给记录一下，一方面是复习，一方面也方便以后用到的时候查阅。</p>
</blockquote>
<p>这篇文章是大作业 MySQL + SQLite 操作相关部分的第一章，主要讲一下如何安装 MySQL 驱动（Win 下）以及如何连接 MySQL 及 SQLite。</p>
<span id="more"></span>

<h2 id="准备部分——安装-MySQL-驱动"><a href="#准备部分——安装-MySQL-驱动" class="headerlink" title="准备部分——安装 MySQL 驱动"></a>准备部分——安装 MySQL 驱动</h2><p>还记得跟着教程学 Qt MySQL 操作的时候兴致冲冲地跟着打下了一行行代码，然后编译—运行，卧槽，报错。。。报错信息如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">QSqlDatabase: QMYSQL driver not loaded</span><br><span class="line"></span><br><span class="line">QSqlDatabase: available drivers: QSQLITE QPSQL QPSQL7</span><br><span class="line"></span><br><span class="line">&quot;Driver not loaded Driver not loaded&quot;</span><br></pre></td></tr></table></figure>

<p>看一下报错信息，大体的意思就是说 Qt 没有连接 MySQL 的驱动。</p>
<p>查看当前系统环境中的 Qt 支持哪些 Sql 驱动，可以输出一下 QSqlDatabase::drivers() 的值。</p>
<p>坑爹的 Qt 在 Win 下并没有附带 MySQL 的连接驱动，需要我们自行编译。</p>
<p>如果只需要连接远程数据库，那我们本地并不需要安装 MySQL，只要找到 MySQL 提供的 <code>libmysql.dll</code> 和 <code>libmysqld.dll</code> 拷贝到 Qt 的安装目录（<code>%QtDir%/migw.../bin</code>）。网上有教程说 Qt 默认自带已经编译好的 <code>qsqlmysql.dll</code> 和 <code>qsqlmysqld.dll</code> （路径在 <code>%QtDir%/mingw.../plugins/sqldrivers</code>），但是实测这些教程都已经老的不能再老了，我的安装目录下就没有自带的编译好的这两个 dll 文件，接下来我们开始着手安装和编译 MySQL 驱动。</p>
<h3 id="第一步：下载-MySQL-DLL文件"><a href="#第一步：下载-MySQL-DLL文件" class="headerlink" title="第一步：下载 MySQL DLL文件"></a>第一步：下载 MySQL DLL文件</h3><p>扔个地址： </p>
<blockquote>
<p><a href="https://dev.mysql.com/downloads/connector/cpp/">https://dev.mysql.com/downloads/connector/cpp/</a></p>
</blockquote>
<p>下载下来拷贝一下扔过去就好了。。。</p>
<p>（我记得当时搞了一个老版本的才能用。。。记不清了。。。需要的时候现搞吧。）</p>
<h3 id="第二步：-编译-MySQL-驱动"><a href="#第二步：-编译-MySQL-驱动" class="headerlink" title="第二步： 编译 MySQL 驱动"></a>第二步： 编译 MySQL 驱动</h3><p>这一步是重中之重，不巧的是我也忘的差不多了。。。</p>
<p>这里我们需要有 Qt 的源码，可以去下载一下。Qt 全部源码2G大小，我们可以仅选择模块进行下载。</p>
<p>用 Qt 打开源码目录下的<code>\src\plugins\sqldrivers\mysql\mysql.pro</code>。</p>
<p>在末尾加上两句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INCLUDEPATH += mysql安装目录\include</span><br><span class="line">LIBS += -Lmysql安装目录\lib\ -llibmysql</span><br></pre></td></tr></table></figure>

<p>构建项目后会生成 <code>qsqlmysql.dll</code> 和 <code>qsqlmysqld.dll</code>两个文件，然后拷贝到<code>%QtDir%/mingw.../plugins/sqldrivers</code>文件夹中。</p>
<p>准备部分到这里就大体结束了，理论上 Qt 就已经能成功连接 MySQL 。</p>
<h2 id="上路！连接-MySQL-和-SQLite"><a href="#上路！连接-MySQL-和-SQLite" class="headerlink" title="上路！连接 MySQL 和 SQLite"></a>上路！连接 MySQL 和 SQLite</h2><h3 id="配置工程文件"><a href="#配置工程文件" class="headerlink" title="配置工程文件"></a>配置工程文件</h3><p>若要使用 Qt 的 SQL 库，则需要在工程文件中添加相应的参数。</p>
<p>CMakeLists.txt:</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(Qt5 Sql)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(Ordering-System-Server PRIVATE Qt5::Sql)</span><br></pre></td></tr></table></figure>

<p>.pro工程文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">QT += sql</span><br></pre></td></tr></table></figure>



<h3 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h3><p>SQL 用到的库主要为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QSqlDatabase&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QSqlError&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QSqlRecord&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QSqlQuery&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QSqlIndex&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>其中 QSqlDatabase 是最重要的库，数据库的连接及其他基本操作都要在这个类上执行。</p>
<p>连接数据库时，我们主要会用到以下几个函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//添加数据库</span></span><br><span class="line">[<span class="keyword">static</span>] <span class="function">QSqlDatabase <span class="title">QSqlDatabase::addDatabase</span><span class="params">(<span class="keyword">const</span> QString &amp;type, <span class="keyword">const</span> QString &amp;connectionName = QLatin1String(defaultConnection))</span></span></span><br><span class="line"><span class="function"><span class="comment">//设置数据库相关信息</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QSqlDatabase::setHostName</span><span class="params">(<span class="keyword">const</span> QString &amp;host)</span>        <span class="comment">//主机地址</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QSqlDatabase::setDatabaseName</span><span class="params">(<span class="keyword">const</span> QString &amp;name)</span>    <span class="comment">//数据库名</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QSqlDatabase::setUserName</span><span class="params">(<span class="keyword">const</span> QString &amp;name)</span>    	   <span class="comment">//数据库用户名</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QSqlDatabase::setPassword</span><span class="params">(<span class="keyword">const</span> QString &amp;password)</span>    <span class="comment">//数据库密码</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QSqlDatabase::setPort</span><span class="params">(<span class="keyword">int</span> port)</span>                       <span class="comment">//数据库端口</span></span></span><br></pre></td></tr></table></figure>

<p>这里要特别注意一下<code>addDatabase()</code>这个函数的第二个参数 <em>connectionName</em> ，如果不指定这个参数，<strong>每次添加的数据库连接都会被应用程序当作默认连接</strong>。当初被这个坑了很久，因为大作业中服务端同时操作着两个数据库，一个远程 MySQL 数据库，一个本地 SQLite 数据库，添加第二个 SQLite 数据库后，就出锅不断，原因就在我没有注意第二个参数。</p>
<p><img src="https://gitee.com/skykeyjoker/PicCloud/raw/master/img/adddatabase.png" alt="Qt Doc中关于 addDatabase的介绍"></p>
<p>接下来分别就给一下连接 MySQL 和 SQLite 数据库的范例：</p>
<h4 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL:"></a>MySQL:</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QSqlDatabase db = QSqlDatabase::<span class="built_in">addDatabase</span>(<span class="string">&quot;QMYSQL&quot;</span>);   <span class="comment">//添加一个数据库 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//设置数据库信息</span></span><br><span class="line">db.<span class="built_in">setHostName</span>(_dbHost);</span><br><span class="line">db.<span class="built_in">setDatabaseName</span>(_dbName);</span><br><span class="line">db.<span class="built_in">setUserName</span>(_dbUser);</span><br><span class="line">db.<span class="built_in">setPassword</span>(_dbPasswd);</span><br><span class="line">db.<span class="built_in">setPort</span>(_dbPort);</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> dbRet = db.<span class="built_in">open</span>(); <span class="comment">//连接数据库</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!ret)</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;Can not open the DB&quot;</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;Open the DB successfully.&quot;</span>;</span><br></pre></td></tr></table></figure>



<p>SQLite:</p>
<p>因为 SQLite 数据库没有网络层，是一种本地储存的关系型数据库，因此连接的时候与 MySQL 有很大的差别。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置数据库文件名</span></span><br><span class="line">QString dbPath = QDir::<span class="built_in">currentPath</span>()+<span class="string">&quot;/&quot;</span>+<span class="string">&quot;orders.db&quot;</span>;</span><br><span class="line"></span><br><span class="line">sqliteDb = QSqlDatabase::<span class="built_in">addDatabase</span>(<span class="string">&quot;QSQLITE&quot;</span>,<span class="string">&quot;LocalSqlite&quot;</span>);</span><br><span class="line">sqliteDb.<span class="built_in">setDatabaseName</span>(dbPath);</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> ret = sqliteDb.<span class="built_in">open</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!ret)</span><br><span class="line">	<span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;Can not open the DB&quot;</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;Open the DB successfully.&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>数据库连接成功！</p>
<hr>
<p>MySQL 部分的第一章到此便结束了， 接下来的一章会讲解一些数据库的基本操作。</p>
<blockquote>
<p>补充：</p>
<p>MySQL 与 SQLite 的区别：</p>
<p><a href="https://blog.csdn.net/zbw1185/article/details/47975965">https://blog.csdn.net/zbw1185/article/details/47975965</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>Qt</tag>
        <tag>Sql</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL on Qt (2):SQL的连接、断开与增删查改基本操作</title>
    <url>/2020/07/23/mysqlonqt2/</url>
    <content><![CDATA[<h1 id="MySQL-on-Qt-2-SQL的连接、断开与增删查改基本操作"><a href="#MySQL-on-Qt-2-SQL的连接、断开与增删查改基本操作" class="headerlink" title="MySQL on Qt (2): SQL的连接、断开与增删查改基本操作"></a>MySQL on Qt (2): SQL的连接、断开与增删查改基本操作</h1><blockquote>
<p>写在前面： </p>
<p>大一下学期的 CPP 大作业“自主订餐系统”可真是颇费了一些力气，每天晚睡早起撸代码，课都没听，很多知识都是现学现用。</p>
<p>为了避免当时学到的东西给全部忘光光（`_&gt;`，我这脑子啊。。。），所以我把当时大作业的一些核心部分（一些零碎的小细节，能记就记）给记录一下，一方面是复习，一方面也方便以后用到的时候查阅。</p>
</blockquote>
<p>这篇文章是大作业 MySQL + SQLite 操作相关部分的第二章，主要讲一下 Qt 中 MySQL 和 SQLite 连接、断开与增删查改的基本操作。</p>
<span id="more"></span>

<h2 id="Qt-SQL-类"><a href="#Qt-SQL-类" class="headerlink" title="Qt SQL 类"></a>Qt SQL 类</h2><p><img src="https://gitee.com/skykeyjoker/PicCloud/raw/master/img/sqlmoudles.png" alt="Qt 中 SQl 相关类"></p>
<ul>
<li>用户接口层：实现将数据库中的数据链接到窗口部件上</li>
<li>SQL接口层：提供对数据库的访问</li>
<li>驱动层：为具体的数据库和SQL接口层之间提供了底层的桥梁</li>
</ul>
<p>要使用Qt SQL的类，需要在项目文件（.pro文件）中添加：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">QT += sql</span><br></pre></td></tr></table></figure>



<h2 id="Qt-SQL-的连接、断开与增删查改操作"><a href="#Qt-SQL-的连接、断开与增删查改操作" class="headerlink" title="Qt SQL 的连接、断开与增删查改操作"></a>Qt SQL 的连接、断开与增删查改操作</h2><p>下面用一个 demo 来演示 Qt 中 SQL 的连接、断开与增删查改操作。</p>
<img src="https://gitee.com/skykeyjoker/PicCloud/raw/master/img/demo.png" alt="demo" style="zoom:80%;" />



<hr>
<p>先来讲数据库的连接与断开。</p>
<h3 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h3><p>上一章已经讲过如何连接 SQL 数据库，这里就简简单单放一下代码。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Connect to db</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Widget::connectToDb</span><span class="params">(<span class="keyword">const</span> QString &amp; hostName, <span class="keyword">const</span> <span class="keyword">int</span> &amp; port, <span class="keyword">const</span> QString &amp; databaseName, <span class="keyword">const</span> QString &amp; username, <span class="keyword">const</span> QString &amp; password)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;hostName;</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;port;</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;databaseName;</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;username;</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;password;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set info</span></span><br><span class="line">    _db.<span class="built_in">setHostName</span>(hostName);</span><br><span class="line">    _db.<span class="built_in">setPort</span>(port);</span><br><span class="line">    _db.<span class="built_in">setDatabaseName</span>(databaseName);</span><br><span class="line">    _db.<span class="built_in">setUserName</span>(username);</span><br><span class="line">    _db.<span class="built_in">setPassword</span>(password);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Open Db</span></span><br><span class="line">    <span class="keyword">bool</span> ret = _db.<span class="built_in">open</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Error Info</span></span><br><span class="line">    QSqlError error = _db.<span class="built_in">lastError</span>();</span><br><span class="line">    <span class="keyword">if</span>(error.<span class="built_in">type</span>() != QSqlError::NoError)</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;error.<span class="built_in">text</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里要注意下打印出错信息的技巧，这样可以方便查错。</p>
<h3 id="断开数据库"><a href="#断开数据库" class="headerlink" title="断开数据库"></a>断开数据库</h3><p>啊这，更简单：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Close Db</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Widget::closeDb</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    _db.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<p>接下来讲数据库的增删查改操作。这些操作主要是对 Query 语句的简单利用。</p>
<p><strong>注意：</strong> MySQL 与 SQLite 的 SQL 语法存在一定区别，要注意区分使用。</p>
<h3 id="创建数据表"><a href="#创建数据表" class="headerlink" title="创建数据表"></a>创建数据表</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Create Table</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Widget::createTable</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Query</span></span><br><span class="line">    QSqlQuery query;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create table</span></span><br><span class="line">    query.<span class="built_in">exec</span>(<span class="string">&quot;CREATE TABLE `runoob_tbl` \</span></span><br><span class="line"><span class="string">                   (`runoob_id` INT UNSIGNED AUTO_INCREMENT, \</span></span><br><span class="line"><span class="string">                   `runoob_title` VARCHAR(100) NOT NULL,\</span></span><br><span class="line"><span class="string">                   `runoob_author` VARCHAR(40) NOT NULL,\</span></span><br><span class="line"><span class="string">                   `submission_date` DATE,\</span></span><br><span class="line"><span class="string">                   PRIMARY KEY ( `runoob_id`)) &quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Error Info</span></span><br><span class="line">    QSqlError error = _db.<span class="built_in">lastError</span>();</span><br><span class="line">    <span class="keyword">if</span>(error.<span class="built_in">type</span>() != QSqlError::NoError)</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;error.<span class="built_in">text</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="增加字段"><a href="#增加字段" class="headerlink" title="增加字段"></a>增加字段</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Add new column</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Widget::addNewcolumn</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Query</span></span><br><span class="line">    QSqlQuery query;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add column</span></span><br><span class="line">    query.<span class="built_in">exec</span>(<span class="string">&quot;ALTER TABLE runoob_tbl ADD COLUMN new1 VARCHAR(20) DEFAULT NULL;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Error Info</span></span><br><span class="line">    QSqlError error = _db.<span class="built_in">lastError</span>();</span><br><span class="line">    <span class="keyword">if</span>(error.<span class="built_in">type</span>() != QSqlError::NoError)</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;error.<span class="built_in">text</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="检验表是否存在"><a href="#检验表是否存在" class="headerlink" title="检验表是否存在"></a>检验表是否存在</h3><p>检验数据库中是否存在某表，可以利用 QSqlDatabase 提供的 <code>QSqlDatabase::tables()</code>函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Is Table Exists</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Widget::isTableExists</span><span class="params">(<span class="keyword">const</span> QString &amp;)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(_db.<span class="built_in">tables</span>().<span class="built_in">contains</span>(<span class="string">&quot;user&quot;</span>))</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;Table exists&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;Table not exists&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> _db.<span class="built_in">tables</span>().<span class="built_in">contains</span>(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>QSqlDatabase::tables()</code>函数返回一个 <em>QStringList</em> 类型的数据，里面储存着所有表名，所以我们可以很方便的调用 <code>QStringList::contains()</code> 函数了来检验表是否存在。</p>
<h3 id="查询、遍历数据表"><a href="#查询、遍历数据表" class="headerlink" title="查询、遍历数据表"></a>查询、遍历数据表</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Query Table</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Widget::queryTable</span><span class="params">(<span class="keyword">const</span> QString &amp;)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Query</span></span><br><span class="line">    QSqlQuery query;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Query the database</span></span><br><span class="line">    query.<span class="built_in">exec</span>(<span class="string">&quot;SELECT * FROM user WHERE 1&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get record</span></span><br><span class="line">    <span class="keyword">while</span>(query.<span class="built_in">next</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        QSqlRecord record = query.<span class="built_in">record</span>();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;record.<span class="built_in">value</span>(<span class="number">0</span>)&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;record.<span class="built_in">value</span>(<span class="number">1</span>)&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;record.<span class="built_in">value</span>(<span class="number">2</span>)&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;record.<span class="built_in">value</span>(<span class="number">3</span>)&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;record.<span class="built_in">value</span>(<span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Error Info</span></span><br><span class="line">    QSqlError error = _db.<span class="built_in">lastError</span>();</span><br><span class="line">    <span class="keyword">if</span>(error.<span class="built_in">type</span>() != QSqlError::NoError)</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;error.<span class="built_in">text</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>数据表的遍历技巧要记住。</p>
<h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Insert Data</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Widget::insertData</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//Query</span></span><br><span class="line">    QSqlQuery query;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Prepare</span></span><br><span class="line">    query.<span class="built_in">prepare</span>(<span class="string">&quot;INSERT INTO user VALUES (:ID, :Name, :Age, :Type, :Gender)&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Bind value</span></span><br><span class="line">    query.<span class="built_in">bindValue</span>(<span class="string">&quot;:ID&quot;</span>,<span class="number">0</span>);</span><br><span class="line">    query.<span class="built_in">bindValue</span>(<span class="string">&quot;:Name&quot;</span>,<span class="string">&quot;test&quot;</span>);</span><br><span class="line">    query.<span class="built_in">bindValue</span>(<span class="string">&quot;:Age&quot;</span>,<span class="number">22</span>);</span><br><span class="line">    query.<span class="built_in">bindValue</span>(<span class="string">&quot;:Type&quot;</span>,<span class="string">&quot;testType&quot;</span>);</span><br><span class="line">    query.<span class="built_in">bindValue</span>(<span class="string">&quot;:Gender&quot;</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Exec inserting</span></span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;query.<span class="built_in">exec</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Error Info</span></span><br><span class="line">    QSqlError error = _db.<span class="built_in">lastError</span>();</span><br><span class="line">    <span class="keyword">if</span>(error.<span class="built_in">type</span>() != QSqlError::NoError)</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;error.<span class="built_in">text</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>插入数据时使用了<code>QSqlDatabase::prepare()</code> 与 <code>QSqlDatabase::bindValue()</code>方法，当然我们也可以直接调用 <code>QSqlDatabase::exec()</code>，使用<code>tr(&quot;%1&quot;).arg(arg1)</code>方法来指定参数。</p>
<h3 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Update Data</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Widget::updateData</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Query</span></span><br><span class="line">    QSqlQuery query;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update</span></span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;query.<span class="built_in">exec</span>(<span class="string">&quot;UPDATE user SET Age=233 WHERE Name=&#x27;Joker&#x27;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Error Info</span></span><br><span class="line">    QSqlError error = _db.<span class="built_in">lastError</span>();</span><br><span class="line">    <span class="keyword">if</span>(error.<span class="built_in">type</span>() != QSqlError::NoError)</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;error.<span class="built_in">text</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Delete Data</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Widget::deleteData</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Query</span></span><br><span class="line">    QSqlQuery query;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Delete</span></span><br><span class="line">    query.<span class="built_in">exec</span>(<span class="string">&quot;DELETE FROM user WHERE Name=&#x27;test&#x27;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Error Info</span></span><br><span class="line">    QSqlError error = _db.<span class="built_in">lastError</span>();</span><br><span class="line">    <span class="keyword">if</span>(error.<span class="built_in">type</span>() != QSqlError::NoError)</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;error.<span class="built_in">text</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<p>至此本章的内容基本结束。下一章将讲解 Qt SQL 操作中最为精彩的部分：Model/View 模式。</p>
<blockquote>
<p>简单的 MySQL 和 SQLite 教程：</p>
<p>MySQL: <a href="https://www.runoob.com/mysql/mysql-tutorial.html">https://www.runoob.com/mysql/mysql-tutorial.html</a></p>
<p>SQLite: <a href="https://www.runoob.com/sqlite/sqlite-tutorial.html">https://www.runoob.com/sqlite/sqlite-tutorial.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>Qt</tag>
        <tag>Sql</tag>
      </tags>
  </entry>
  <entry>
    <title>二元运算符重载</title>
    <url>/2020/07/21/%E4%BA%8C%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/</url>
    <content><![CDATA[<h1 id="C-二元运算符重载"><a href="#C-二元运算符重载" class="headerlink" title="C++ 二元运算符重载"></a>C++ 二元运算符重载</h1><p>二元运算符需要两个参数，下面是二元运算符的实例。我们平常使用的加运算符（ + ）、减运算符（ - ）、乘运算符（ * ）和除运算符（ / ）都属于二元运算符。就像加(+)运算符。</p>
<p>下面的实例演示了如何重载加运算符（ + ）。类似地，您也可以尝试重载减运算符（ - ）和除运算符（ / ）。</p>
<span id="more"></span>

<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span> &#123;</span>   </span><br><span class="line">    <span class="keyword">double</span> length;      <span class="comment">// 长度   </span></span><br><span class="line">    <span class="keyword">double</span> breadth;     <span class="comment">// 宽度   </span></span><br><span class="line">    <span class="keyword">double</span> height;      <span class="comment">// 高度 </span></span><br><span class="line">    <span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getVolume</span><span class="params">(<span class="keyword">void</span>)</span>   </span></span><br><span class="line"><span class="function">    </span>&#123;      </span><br><span class="line">        <span class="keyword">return</span> length * breadth * height;   </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setLength</span><span class="params">( <span class="keyword">double</span> len )</span>   </span></span><br><span class="line"><span class="function">    </span>&#123;       </span><br><span class="line">        length = len;   </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setBreadth</span><span class="params">( <span class="keyword">double</span> bre )</span>   </span></span><br><span class="line"><span class="function">    </span>&#123;       </span><br><span class="line">        breadth = bre;   </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setHeight</span><span class="params">( <span class="keyword">double</span> hei )</span>   </span></span><br><span class="line"><span class="function">    </span>&#123;       </span><br><span class="line">        height = hei;   </span><br><span class="line">    &#125;   <span class="comment">// 重载 + 运算符，用于把两个 Box 对象相加   </span></span><br><span class="line">    Box <span class="keyword">operator</span>+(<span class="keyword">const</span> Box&amp; b)   </span><br><span class="line">    &#123;      </span><br><span class="line">        Box box;      </span><br><span class="line">        box.length = <span class="keyword">this</span>-&gt;length + b.length;      </span><br><span class="line">        box.breadth = <span class="keyword">this</span>-&gt;breadth + b.breadth;      </span><br><span class="line">        box.height = <span class="keyword">this</span>-&gt;height + b.height;      </span><br><span class="line">        <span class="keyword">return</span> box;   &#125; &#125;; </span><br><span class="line"><span class="comment">// 程序的主函数 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( )</span> </span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    Box Box1;                <span class="comment">// 声明 Box1，类型为 Box   </span></span><br><span class="line">    Box Box2;                <span class="comment">// 声明 Box2，类型为 Box   </span></span><br><span class="line">    Box Box3;                <span class="comment">// 声明 Box3，类型为 Box   </span></span><br><span class="line">    <span class="keyword">double</span> volume = <span class="number">0.0</span>;     <span class="comment">// 把体积存储在该变量中    </span></span><br><span class="line">    <span class="comment">// Box1 详述  </span></span><br><span class="line">    Box1.<span class="built_in">setLength</span>(<span class="number">6.0</span>);    </span><br><span class="line">    Box1.<span class="built_in">setBreadth</span>(<span class="number">7.0</span>);    </span><br><span class="line">    Box1.<span class="built_in">setHeight</span>(<span class="number">5.0</span>);    </span><br><span class="line">    <span class="comment">// Box2 详述   </span></span><br><span class="line">    Box2.<span class="built_in">setLength</span>(<span class="number">12.0</span>);    </span><br><span class="line">    Box2.<span class="built_in">setBreadth</span>(<span class="number">13.0</span>);    </span><br><span class="line">    Box2.<span class="built_in">setHeight</span>(<span class="number">10.0</span>);    </span><br><span class="line">    <span class="comment">// Box1 的体积   </span></span><br><span class="line">    volume = Box1.<span class="built_in">getVolume</span>();   </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Volume of Box1 : &quot;</span> &lt;&lt; volume &lt;&lt;endl;    </span><br><span class="line">    <span class="comment">// Box2 的体积   </span></span><br><span class="line">    volume = Box2.<span class="built_in">getVolume</span>();   </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Volume of Box2 : &quot;</span> &lt;&lt; volume &lt;&lt;endl;    </span><br><span class="line">    <span class="comment">// 把两个对象相加，得到 Box3   </span></span><br><span class="line">    Box3 = Box1 + Box2;    <span class="comment">// Box3 的体积   </span></span><br><span class="line">    volume = Box3.<span class="built_in">getVolume</span>();   </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Volume of Box3 : &quot;</span> &lt;&lt; volume &lt;&lt;endl;    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Volume of Box1 : 210</span><br><span class="line">Volume of Box2 : 1560</span><br><span class="line">Volume of Box3 : 5400</span><br></pre></td></tr></table></figure>





<h2 id="非成员函数与类成员二元运算-友元函数"><a href="#非成员函数与类成员二元运算-友元函数" class="headerlink" title="非成员函数与类成员二元运算(友元函数)"></a>非成员函数与类成员二元运算(友元函数)</h2><p>当 2 个对象相加时是没有顺序要求的，<strong>但要重载 ‘+’让其与一个数字相加则有顺序要求，可以通过加一个</strong>友元函数<strong>使另一个顺序的输入合法。</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">            <span class="built_in">A</span>();</span><br><span class="line">            <span class="built_in">A</span>(<span class="keyword">int</span> n);</span><br><span class="line">            A <span class="keyword">operator</span>+(<span class="keyword">const</span> A &amp; obj);</span><br><span class="line">            A <span class="keyword">operator</span>+(<span class="keyword">const</span> <span class="keyword">int</span> b);</span><br><span class="line">    		<span class="keyword">friend</span> A <span class="keyword">operator</span>+(<span class="keyword">const</span> <span class="keyword">int</span> b, A obj); </span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>; </span><br><span class="line">&#125; ;</span><br><span class="line">A::<span class="built_in">A</span>()</span><br><span class="line">&#123;</span><br><span class="line">    a=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">A::<span class="built_in">A</span>(<span class="keyword">int</span> n)<span class="comment">//构造函数 </span></span><br><span class="line">&#123;</span><br><span class="line">    a=n;</span><br><span class="line">&#125;</span><br><span class="line">A A::<span class="keyword">operator</span> +(<span class="keyword">const</span> A&amp; obj)<span class="comment">//重载+号用于 对象相加 </span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;a+obj.a;</span><br><span class="line">&#125;</span><br><span class="line">A A::<span class="keyword">operator</span>+(<span class="keyword">const</span> <span class="keyword">int</span> b)<span class="comment">//重载+号用于  对象与数相加</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">A</span>(a+b);</span><br><span class="line">&#125;</span><br><span class="line">A <span class="keyword">operator</span>+(<span class="keyword">const</span> <span class="keyword">int</span> b,  A obj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> obj+b;<span class="comment">//友元函数调用第二个重载+的成员函数  相当于 obj.operator+(b); </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">A::display</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">a1</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">A <span class="title">a2</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">    A a3,a4,a5;</span><br><span class="line">    a1.<span class="built_in">display</span>();</span><br><span class="line">    a2.<span class="built_in">display</span>();</span><br><span class="line">    <span class="keyword">int</span> m=<span class="number">1</span>;</span><br><span class="line">    a3=a1+a2;<span class="comment">//可以交换顺序，相当月a3=a1.operator+(a2); </span></span><br><span class="line">    a3.<span class="built_in">display</span>();</span><br><span class="line">    a4=a1+m;<span class="comment">//因为加了个友元函数所以也可以交换顺序了。</span></span><br><span class="line">    a4.<span class="built_in">display</span>();</span><br><span class="line">    a5=m+a1;</span><br><span class="line">    a5.<span class="built_in">display</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title>构造函数</title>
    <url>/2020/07/21/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="【C-】类构造函数（深拷贝与浅拷贝）"><a href="#【C-】类构造函数（深拷贝与浅拷贝）" class="headerlink" title="【C++】类构造函数（深拷贝与浅拷贝）"></a>【C++】类构造函数（深拷贝与浅拷贝）</h1><blockquote>
<p>原创Jacky_Feng 最后发布于2019-11-29 19:56:28 阅读数 16  收藏</p>
</blockquote>
<h2 id="1-什么是类的构造函数"><a href="#1-什么是类的构造函数" class="headerlink" title="1.什么是类的构造函数"></a>1.什么是类的构造函数</h2><p>类的构造函数是类的一种特殊的成员函数，它会在每次创建类的新对象时被自动调用。没创建一个对象都必须调用一次构造函数。</p>
<p>构造函数的名称与类的名称是完全相同的，并且不会返回任何类型，也不会返回void。构造函数可用于为某些成员变量设置初始值。</p>
<span id="more"></span>

<p>实例演示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 类Counter的构造函数</span></span><br><span class="line">    <span class="comment">// 特点：以类名作为函数名，无返回类型</span></span><br><span class="line">    <span class="built_in">Counter</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;object is being created&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 数据成员</span></span><br><span class="line">    <span class="keyword">int</span> m_value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Counter obj1;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>以上代码编译和执行的结果如下：</p>
<p><strong>object is being created</strong></p>
</blockquote>
<p> 该类对象obj1被创建时，编译系统为对象分配内存空间，并自动调用构造函数Counter()完成对象成员变量的初始化工作。</p>
<h2 id="2-构造函数的分类"><a href="#2-构造函数的分类" class="headerlink" title="2.构造函数的分类"></a>2.构造函数的分类</h2><h3 id="1）按函数有无参数分类"><a href="#1）按函数有无参数分类" class="headerlink" title="1）按函数有无参数分类"></a>1）按函数有无参数分类</h3><img src="https://img-blog.csdnimg.cn/20191129164917429.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phY2t5X0Zlbmc=,size_16,color_FFFFFF,t_70" alt="有无参数分类" style="zoom:80%;" />

<p> 其中所有带有默认值的有参构造函数会转变成默认构造函数。</p>
<h3 id="2）按参数的类型分类"><a href="#2）按参数的类型分类" class="headerlink" title="2）按参数的类型分类"></a>2）按参数的类型分类</h3><img src="https://img-blog.csdnimg.cn/20191129165633658.png" alt="按参数的类型分类" style="zoom:80%;" />

<p> 一个类中至少有上述两个构造函数，可以有更多的构造函数（构造函数允许重载），以实现不同形式对象的创建。</p>
<h2 id="3-构造函数的重载"><a href="#3-构造函数的重载" class="headerlink" title="3.构造函数的重载"></a>3.构造函数的重载</h2><p>和普通成员函数一样，构造函数是允许重载的。一个类中可以有多个重载的构造函数，创建对象时根据传递的实参来判断调用哪个构造函数。创建对象构造函数的调用是强制性的，一旦在类中定义了构造函数，那么创建对象时就一定要调用。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">String</span>(<span class="keyword">const</span> <span class="keyword">char</span> *str = <span class="literal">NULL</span>); <span class="comment">// 普通构造函数</span></span><br><span class="line">    <span class="built_in">String</span>(<span class="keyword">const</span> String &amp;other);    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    ~ <span class="built_in">String</span>(<span class="keyword">void</span>);                 <span class="comment">// 析构函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> *m_data; <span class="comment">// 用于保存字符串</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// String 的析构函数</span></span><br><span class="line">String::~<span class="built_in">String</span>(<span class="keyword">void</span>) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> [] m_data;</span><br><span class="line">    <span class="comment">// 由于m_data 是内部数据类型，也可以写成 delete m_data;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// String 的普通构造函数</span></span><br><span class="line">String::<span class="built_in">String</span>(<span class="keyword">const</span> <span class="keyword">char</span> *str) </span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Ordinary constructor is running&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 拷贝构造函数</span></span><br><span class="line">String::<span class="built_in">String</span>(<span class="keyword">const</span> String &amp;other) </span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Copy constructor is running&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	String  str1; </span><br><span class="line">	<span class="function">String  <span class="title">str2</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span></span>; </span><br><span class="line">	<span class="function">String  <span class="title">str3</span><span class="params">(str2)</span></span>; </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p> 上面代码编译和执行结果为：</p>
<img src="https://img-blog.csdnimg.cn/20191129172558212.png" alt="结果" style="zoom:80%;" />

 

<h2 id="4-常见的构造函数"><a href="#4-常见的构造函数" class="headerlink" title="4.常见的构造函数"></a>4.常见的构造函数</h2><h3 id="1）默认构造函数"><a href="#1）默认构造函数" class="headerlink" title="1）默认构造函数"></a>1）默认构造函数</h3><p>如果用户自己没有定义构造函数，那么编译器会自动生成一个默认构造函数，只是这个构造函数没有形参，函数体也是空的，不执行任何操作。例如：Student类的默认生成的构造函数如下：</p>
<p>​       <code> Student()&#123;&#125;</code></p>
<p>==一个类中必须有构造函数，要么用户自己定义，要么编译器自动生成。一旦用户自己定义了构造函数，不管几个，也不管形参如何，编译器都不再自动生成。==</p>
<p>调用不带参数的构造函数也可以省略括号。即创建对象Student stu()和Student stu是等价的。</p>
<h3 id="2）-拷贝构造函数"><a href="#2）-拷贝构造函数" class="headerlink" title="2） 拷贝构造函数"></a>2） 拷贝构造函数</h3><p>当以拷贝的方式初始化一个对象时，会调用一个特殊的构造函数，就是拷贝构造函数。拷贝构造函数的名称与类的名称一致，它必须的一个参数是本类型的一个引用变量。</p>
<p>注意，默认构造函数（即无参构造函数）不一定存在，但是拷贝构造函数总是会存在。</p>
<blockquote>
<p>拷贝构造函数常用的三种情况：</p>
<p>==①当用一个对象去初始化同类的另一个对象==。</p>
<p>例如：</p>
<p>​    A test_b(test_a);<br>​    A test_b = test_a;//这两条语句是等价的<br><strong>【注意】第二条语句是初始化语句，不是赋值语句。赋值语句的等号左边是一个早已有定义的变量，赋值语句不会引发拷贝构造函数的调用。</strong></p>
<pre><code>A test_a,test_b;
 test_b = test_a;//这句不会引发拷贝构造函数的调用，因为test_b早已生成，已经初始化过了
</code></pre>
<p>②==一个对象以值传递的方式传入函数体==，而调用拷贝构造函数时的参数，就是调用函数时所给的实参。</p>
<p>③==一个对象以值传递的方式从函数中返回==，而调用拷贝构造函数的参数，就是return语句所返回的对象。</p>
</blockquote>
<h4 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h4><p>浅拷贝是指在对象拷贝时，只对对象中的数据成员进行简单的赋值，默认拷贝构造函数执行的也是浅拷贝。大多数情况下“浅拷贝”可以很好的工作，但一旦对象存在动态成员，那么浅拷贝就会出问题。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rect</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Rect</span>()</span><br><span class="line">    &#123;</span><br><span class="line">     p=<span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	~<span class="built_in">Rect</span>()</span><br><span class="line">	&#123;</span><br><span class="line"> 		<span class="built_in">assert</span>(p!=<span class="literal">NULL</span>);</span><br><span class="line">    	<span class="keyword">delete</span> p;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> width;</span><br><span class="line">    <span class="keyword">int</span> height;</span><br><span class="line">    <span class="keyword">int</span> *p;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Rect rect1;</span><br><span class="line">    <span class="function">Rect <span class="title">rect2</span><span class="params">(rect1)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; 这段代码运行结束后，会出现运行错误。原因就在于在进行对象拷贝时，对于动态分配的内容没有正确的操作。</span><br></pre></td></tr></table></figure>

<p>原因分析：</p>
<p>在使用rect1复制rect2时，由于执行的是浅拷贝，只是将成员的值进行赋值，这时 rect1.p = rect2.p，也即这两个指针指向了堆里的同一个空间。</p>
<img src="https://img-blog.csdnimg.cn/20191129194029601.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phY2t5X0Zlbmc=,size_16,color_FFFFFF,t_70" alt="原因" style="zoom:80%;" />

<p> 在销毁对象时，两个对象的析构函数将对同一个内存空间释放两次，这就是错误出现的原因。我们需要的不是两个p有相同的值，而是两个p指向的空间有相同的值，解决办法就是使用“深拷贝”。</p>
<h4 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h4><p>深拷贝对于动态成员，并不是简单地复制，而是重新动态分配空间。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rect</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Rect</span>()</span><br><span class="line">    &#123;</span><br><span class="line">     p=<span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//深拷贝</span></span><br><span class="line">    <span class="built_in">Rect</span>(<span class="keyword">const</span> Rect&amp; r)</span><br><span class="line">    &#123;</span><br><span class="line">     width=r.width;</span><br><span class="line">        height=r.height;</span><br><span class="line">     p=<span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">100</span>);</span><br><span class="line">        *p=*(r.p);</span><br><span class="line">    &#125;</span><br><span class="line">~<span class="built_in">Rect</span>()</span><br><span class="line">&#123;</span><br><span class="line"> <span class="built_in">assert</span>(p!=<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> width;</span><br><span class="line">    <span class="keyword">int</span> height;</span><br><span class="line">    <span class="keyword">int</span> *p;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Rect rect1;</span><br><span class="line">    <span class="function">Rect <span class="title">rect2</span><span class="params">(rect1)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完成对象拷贝地过程为:</p>
<img src="https://img-blog.csdnimg.cn/2019112919463854.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phY2t5X0Zlbmc=,size_16,color_FFFFFF,t_70" alt="过程" style="zoom:80%;" />

<p> 此时rect1的p和rect2的p各自指向一段内存空间，但它们指向的空间具有相同的内容，这就是所谓的“深拷贝”。</p>
<blockquote>
<p>小结：</p>
<p><strong>拷贝构造函数有两种：深拷贝和浅拷贝</strong></p>
<p>当出现类的等号赋值时，会调用拷贝函数，在未定义显示拷贝构造函数的情况下，系统会调用默认的拷贝函数——即浅拷贝，它能够完成成员的一一复制。当数据成员中没有指针时，浅拷贝是可行的。但<strong>当数据成员中有指针</strong>时，如果采用简单的浅拷贝，则两类中的两个指针将指向同一个地址，当对象快结束时，会调用两次析构函数，而导致指针悬挂现象。所以，这时，必须采用深拷贝.</p>
<p>深拷贝与浅拷贝的区别就在于深拷贝会在堆内存中另外申请空间来储存数据，从而也就解决了指针悬挂的问题。<strong>简而言之，当数据成员中有指针时，必须要用深拷贝。</strong></p>
</blockquote>
<h2 id="5-综合实例分析"><a href="#5-综合实例分析" class="headerlink" title="5.综合实例分析"></a>5.综合实例分析</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CPoint</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//缺省构造函数,如果定义类时未指定任何构造函数，</span></span><br><span class="line">    <span class="comment">//系统将自动生成不带参数的缺省构造函数</span></span><br><span class="line">    <span class="built_in">CPoint</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;默认构造函数 &quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        x = <span class="number">0</span>;</span><br><span class="line">        y = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//带一个参数的可用于类型转换的构造函数</span></span><br><span class="line">	<span class="comment">//  explicit    //加上 explicit 可防止 CPoint pt1 = 1; 这种隐性转换</span></span><br><span class="line">    <span class="built_in">CPoint</span>(<span class="keyword">int</span> ix)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;1参数构造函数 &quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        x = ix;</span><br><span class="line">        y = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//带参数的构造函数</span></span><br><span class="line">	<span class="built_in">CPoint</span>(<span class="keyword">int</span> ix, <span class="keyword">int</span> iy)</span><br><span class="line">	&#123;</span><br><span class="line">    	cout &lt;&lt; <span class="string">&quot;2参数构造函数 &quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    	x = ix;</span><br><span class="line">   	 y = iy;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//拷贝构造函数,如果此函数不定义，系统将生成缺省拷贝构造函数功能,</span></span><br><span class="line">	<span class="comment">//缺省拷贝构造函数的行为是：用传入的对象参数的成员初始化正要建立的对象的相应成员</span></span><br><span class="line">	<span class="comment">//  explicit    //加上 explicit 可防止 CPoint pt2 = pt1; 这种隐性转换</span></span><br><span class="line">    <span class="built_in">CPoint</span>(<span class="keyword">const</span> CPoint &amp;cp)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;拷贝构造函数 &quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        x = cp.x;</span><br><span class="line">        y = cp.y;</span><br><span class="line">    &#125;</span><br><span class="line">    CPoint &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> CPoint &amp;cp)</span><br><span class="line">	&#123;</span><br><span class="line">    	cout &lt;&lt; <span class="string">&quot;赋值重载函数 &quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    	<span class="keyword">if</span> (<span class="keyword">this</span> != &amp;cp)</span><br><span class="line">    	&#123;</span><br><span class="line">       	 	x = cp.x;</span><br><span class="line">       	 	y = cp.y;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">return</span> (*<span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//析构函数，一个类中只能有一个析构函数,如果用户没有定义析构函数，</span></span><br><span class="line">	<span class="comment">//系统会自动未类生成一个缺省的析构函数</span></span><br><span class="line">	~<span class="built_in">CPoint</span>()</span><br><span class="line">	&#123;</span><br><span class="line">    	cout &lt;&lt; <span class="string">&quot;析构函数 &quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	CPoint &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> CPoint &amp;cp)</span><br><span class="line">	&#123;</span><br><span class="line">    	cout &lt;&lt; <span class="string">&quot;赋值重载函数 &quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    	<span class="keyword">if</span> (<span class="keyword">this</span> != &amp;cp)</span><br><span class="line">    	&#123;</span><br><span class="line">        	x = cp.x;</span><br><span class="line">        	y = cp.y;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">return</span> (*<span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//析构函数，一个类中只能有一个析构函数,如果用户没有定义析构函数，</span></span><br><span class="line">	<span class="comment">//系统会自动未类生成一个缺省的析构函数</span></span><br><span class="line">	~<span class="built_in">CPoint</span>()</span><br><span class="line">	&#123;</span><br><span class="line">    	cout &lt;&lt; <span class="string">&quot;析构函数 &quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">CPoint <span class="title">p0</span><span class="params">()</span></span>;        <span class="comment">//这是函数的声明，不是实例化类</span></span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; <span class="string">&quot;CPoint pt1;\t\t&quot;</span>;</span><br><span class="line">	CPoint pt1;         <span class="comment">//缺省构造函数</span></span><br><span class="line"> </span><br><span class="line">	cout &lt;&lt; endl &lt;&lt; <span class="string">&quot;CPoint pt2(1);\t\t&quot;</span>;</span><br><span class="line">	<span class="function">CPoint <span class="title">pt2</span><span class="params">(<span class="number">1</span>)</span></span>;      <span class="comment">//一个参数的构造函数</span></span><br><span class="line"> </span><br><span class="line">	cout &lt;&lt; endl &lt;&lt; <span class="string">&quot;CPoint pt3(1, 2);\t&quot;</span>;</span><br><span class="line">	<span class="function">CPoint <span class="title">pt3</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;   <span class="comment">//两个参数的构造函数</span></span><br><span class="line"> </span><br><span class="line">	cout &lt;&lt; endl &lt;&lt; <span class="string">&quot;CPoint pt4 = 1;\t\t&quot;</span>;</span><br><span class="line">	CPoint pt4 = <span class="number">1</span>;     <span class="comment">//等价于CPoint t4(1);  //explicit</span></span><br><span class="line"> </span><br><span class="line">	cout &lt;&lt; endl &lt;&lt; <span class="string">&quot;CPoint pt5 = t1;\t&quot;</span>;</span><br><span class="line">	CPoint pt5 = pt1;   <span class="comment">//CPoint(t1);</span></span><br><span class="line"> </span><br><span class="line">	cout &lt;&lt; endl &lt;&lt; <span class="string">&quot;CPoint pt6 = CPoint();\t&quot;</span>;</span><br><span class="line">	CPoint pt6 = <span class="built_in">CPoint</span>();  <span class="comment">//CPoint(1); CPoint(1,2);</span></span><br><span class="line"> </span><br><span class="line">	cout &lt;&lt; endl &lt;&lt; <span class="string">&quot;pt6 = CPoint(1);\t&quot;</span>;</span><br><span class="line">	pt6 = <span class="built_in">CPoint</span>(<span class="number">1</span>);</span><br><span class="line"> </span><br><span class="line">	cout &lt;&lt; endl &lt;&lt; <span class="string">&quot;pt6 = 1;\t\t&quot;</span>;</span><br><span class="line">	pt6 = <span class="number">1</span>;            <span class="comment">//首先调用单个参数的构造函数，生成临时对象CPoint(1), 然后调用赋值运算符函数</span></span><br><span class="line"> </span><br><span class="line">	cout &lt;&lt; endl &lt;&lt; <span class="string">&quot;pt6 = t1;\t\t&quot;</span>;</span><br><span class="line">	pt6 = pt1;          <span class="comment">//调用赋值运算符函数</span></span><br><span class="line"> </span><br><span class="line">	cout &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码编译和执行结果如下：</p>
<img src="https://img-blog.csdnimg.cn/2019112918062265.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phY2t5X0Zlbmc=,size_16,color_FFFFFF,t_70" alt="执行结果" style="zoom:80%;" />



<blockquote>
<p>————————————————<br>版权声明：本文为CSDN博主「Jacky_Feng」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/Jacky_Feng/article/details/103313208">https://blog.csdn.net/Jacky_Feng/article/details/103313208</a></p>
</blockquote>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title>当我谈线程池时我谈些什么</title>
    <url>/2021/12/12/%E5%BD%93%E6%88%91%E8%B0%88%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%97%B6%E6%88%91%E8%B0%88%E4%BA%9B%E4%BB%80%E4%B9%88/</url>
    <content><![CDATA[<h1 id="当我谈线程池时我谈些什么"><a href="#当我谈线程池时我谈些什么" class="headerlink" title="当我谈线程池时我谈些什么"></a>当我谈线程池时我谈些什么</h1><p>最近跟着purecpp社区里的两篇博文复习了一下两种线程池的C++实现（单任务队列、多任务队列），相比于之前那篇C++11实现线程池的博文，语言版本进行了一点小更新（C++14-C++17）。在这里结合代码记录一下学习心得。</p>
<blockquote>
<p>12.12，然然首播一周年辣（嘉然小姐首播周年快乐）</p>
</blockquote>
<span id="more"></span>

<h2 id="单任务队列线程池"><a href="#单任务队列线程池" class="headerlink" title="单任务队列线程池"></a>单任务队列线程池</h2><p>用现代的C++标准库（线程+锁+条件变量）实现一个单任务队列的线程池非常简单。就像之前那篇博文里面讲的一样，原理非常简单，对新手而言最复杂的其实就是C++11众多的新语言特性罢了。</p>
<p>一个简易的单任务队列线程池的实现思路：在线程池构造时初始化线程数，在析构时停止线程池。对外也只需要提供提交任务的接口就够了。</p>
<h3 id="接口设计"><a href="#接口设计" class="headerlink" title="接口设计"></a>接口设计</h3><h4 id="返回类型"><a href="#返回类型" class="headerlink" title="返回类型"></a>返回类型</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">ThreadPool</span><span class="params">(<span class="keyword">size_t</span> threads = std::thread::hardware_concurrency())</span></span>;  <span class="comment">// 构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">enqueue</span><span class="params">(F &amp;&amp;f, Args &amp;&amp;...args)</span></span>; <span class="comment">// 入队接口</span></span><br></pre></td></tr></table></figure>

<p>入队接口<code>enqueue()</code>这个模板函数返回值使用了<code>auto</code>关键字进行推导，实际上的返回值其实是一个future。future的类型如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> return_type = std::<span class="keyword">invoke_result_t</span>&lt;F, Args...&gt;;</span><br><span class="line">std::future&lt;return_type&gt; res;</span><br></pre></td></tr></table></figure>

<p>也就是说这个future返回的类型实际上是任务的返回类型。</p>
<h4 id="输入参数"><a href="#输入参数" class="headerlink" title="输入参数"></a>输入参数</h4><p>输入参数是一个可调用对象和它的参数，这里利用了C++11的可变参数模板来实现传递任意数量的可调用对象的参数。</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadPool</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">ThreadPool</span><span class="params">(<span class="keyword">size_t</span> threads = std::thread::hardware_concurrency())</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function">	<span class="keyword">auto</span> <span class="title">enqueue</span><span class="params">(F &amp;&amp;f, Args &amp;&amp;...args)</span></span>;</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">ThreadPool</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::vector&lt;std::thread&gt; workers;</span><br><span class="line">	std::queue&lt;std::function&lt;<span class="keyword">void</span>()&gt;&gt; tasks;</span><br><span class="line">	std::mutex queue_mutex;</span><br><span class="line">	std::condition_variable condition;</span><br><span class="line">	<span class="keyword">bool</span> stop;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个简易单任务队列线程池的成员只有一个线程组，一个任务队列。为了保证任务队列的线程安全，我们还提供了一个锁。同时我们还提供了一个条件变量，利用锁和条件变量，我们可以实现线程通知机制。线程通知机制指的是，刚开始时线程池中是没有任务的，所有的线程都等待任务的到来，当一个任务进入到线程池中，就会通知<strong>一个</strong>线程去处理到来的任务。</p>
<p>同时我们又提供了一个stop变量，用来在析构的时候停止和清理任务和线程。因为懒（高情商：RAII风格线程池，生命周期基本上与应用的生命周期一致），没有提供stop接口。</p>
<p>下面是具体实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Diana &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// * 简易多线程单任务队列线程池，使用线程安全队列，接口更人性化。</span></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">ThreadPool</span> &#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="keyword">explicit</span> <span class="title">ThreadPool</span><span class="params">(<span class="keyword">size_t</span> threads = std::thread::hardware_concurrency())</span> : stop(false) &#123;</span></span><br><span class="line">			<span class="comment">// 根据threads数量创建多个线程</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; threads; ++i) &#123;</span><br><span class="line">				workers.<span class="built_in">emplace_back</span>([<span class="keyword">this</span>]() &#123;</span><br><span class="line">					<span class="keyword">for</span> (;;) &#123;<span class="comment">// 工作线程就是一个死循环，不停查询任务队列并取出任务执行</span></span><br><span class="line">						std::function&lt;<span class="built_in"><span class="keyword">void</span></span>()&gt; task;</span><br><span class="line"></span><br><span class="line">						&#123;</span><br><span class="line">							std::unique_lock&lt;std::mutex&gt; <span class="built_in">lock</span>(<span class="keyword">this</span>-&gt;queue_mutex);</span><br><span class="line">							<span class="keyword">this</span>-&gt;condition.<span class="built_in">wait</span>(lock,</span><br><span class="line">												 [<span class="keyword">this</span>]() &#123;</span><br><span class="line">													 <span class="keyword">return</span> <span class="keyword">this</span>-&gt;stop || !<span class="keyword">this</span>-&gt;tasks.<span class="built_in">empty</span>();<span class="comment">// 条件变量等待线程池不为空或者stop</span></span><br><span class="line">												 &#125;);</span><br><span class="line">							<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;stop &amp;&amp; <span class="keyword">this</span>-&gt;tasks.<span class="built_in">empty</span>())<span class="comment">// 线程池为空且stop，证明线程池结束，退出线程</span></span><br><span class="line">								<span class="keyword">return</span>;</span><br><span class="line">							task = std::<span class="built_in">move</span>(<span class="keyword">this</span>-&gt;tasks.<span class="built_in">front</span>());<span class="comment">// 取出任务</span></span><br><span class="line">							<span class="keyword">this</span>-&gt;tasks.<span class="built_in">pop</span>();</span><br><span class="line">						&#125;</span><br><span class="line"></span><br><span class="line">						<span class="built_in">task</span>();<span class="comment">// 执行任务</span></span><br><span class="line">					&#125;</span><br><span class="line">				&#125;);<span class="comment">// lambda表达式构建</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function">		<span class="keyword">auto</span> <span class="title">enqueue</span><span class="params">(F &amp;&amp;f, Args &amp;&amp;...args)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">using</span> return_type = std::<span class="keyword">invoke_result_t</span>&lt;F, Args...&gt;;</span><br><span class="line">			<span class="keyword">auto</span> task = std::make_shared&lt;std::packaged_task&lt;<span class="built_in">return_type</span>()&gt;&gt;(</span><br><span class="line">					std::<span class="built_in">bind</span>(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...));<span class="comment">// 完美转发，构造任务仿函数的指针</span></span><br><span class="line">			std::future&lt;return_type&gt; res = task-&gt;<span class="built_in">get_future</span>();                  <span class="comment">// 获得函数执行的future返回</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(queue_mutex)</span></span>;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (stop) &#123;</span><br><span class="line">					<span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;enqueue on stopped Thread pool&quot;</span>);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				tasks.<span class="built_in">emplace</span>([task = std::<span class="built_in">move</span>(task)]() &#123; (*task)(); &#125;);<span class="comment">// 塞入任务队列</span></span><br><span class="line">			&#125;                                                            <span class="comment">// 入队列后即可解锁</span></span><br><span class="line">			condition.<span class="built_in">notify_one</span>();                                      <span class="comment">// 仅唤醒一个线程，避免无意义的竞争</span></span><br><span class="line">			<span class="keyword">return</span> res;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		~<span class="built_in">ThreadPool</span>() &#123;</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(queue_mutex)</span></span>;</span><br><span class="line">				stop = <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			condition.<span class="built_in">notify_all</span>();<span class="comment">// 唤醒所有线程，清理任务</span></span><br><span class="line">			<span class="keyword">for</span> (std::thread &amp;worker: workers)</span><br><span class="line">				worker.<span class="built_in">join</span>();<span class="comment">// 阻塞，等待所有线程执行结束</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		std::vector&lt;std::thread&gt; workers;</span><br><span class="line">		std::queue&lt;std::function&lt;<span class="keyword">void</span>()&gt;&gt; tasks;</span><br><span class="line">		std::mutex queue_mutex;</span><br><span class="line">		std::condition_variable condition;</span><br><span class="line">		<span class="keyword">bool</span> stop;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">&#125;;<span class="comment">// namespace Diana</span></span><br></pre></td></tr></table></figure>

<p>细节上的东西，注释已经写完了。</p>
<p>注意在有队伍进入队列时，仅需要notify_one()，避免无意义的线程竞争；在停止线程池时，要notify_all()唤醒所有进程。由于线程在等待stop标志，所以当唤醒之后才会把队列中的任务取出执行直到队列为空的时候才会退出线程。</p>
<h3 id="重构：分离队列代码，编写线程安全任务队列"><a href="#重构：分离队列代码，编写线程安全任务队列" class="headerlink" title="重构：分离队列代码，编写线程安全任务队列"></a>重构：分离队列代码，编写线程安全任务队列</h3><p>这里进行一次重构，像之前那片博文一样，封装一个线程安全队列：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Diana &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// * 线程安全队列</span></span><br><span class="line">	<span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">SafeQueue</span> &#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> T &amp;item)</span> </span>&#123;</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="function">std::scoped_lock <span class="title">lock</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">				queue_.<span class="built_in">push</span>(item);</span><br><span class="line">			&#125;</span><br><span class="line">			cond_.<span class="built_in">notify_one</span>();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T &amp;&amp;item)</span> </span>&#123;<span class="comment">// 两个push方法，此处不是万能引用而是单纯右值</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="function">std::scoped_lock <span class="title">lock</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">				queue_.<span class="built_in">push</span>(std::<span class="built_in">move</span>(item));</span><br><span class="line">			&#125;</span><br><span class="line">			cond_.<span class="built_in">notify_one</span>();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">bool</span> <span class="title">pop</span><span class="params">(T &amp;item)</span> </span>&#123;</span><br><span class="line">			<span class="function">std::unique_lock <span class="title">lock</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">			cond_.<span class="built_in">wait</span>(lock, [&amp;]() &#123;</span><br><span class="line">				<span class="keyword">return</span> !queue_.<span class="built_in">empty</span>() || stop_;</span><br><span class="line">			&#125;);</span><br><span class="line">			<span class="keyword">if</span> (queue_.<span class="built_in">empty</span>())</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			item = std::<span class="built_in">move</span>(queue_.<span class="built_in">front</span>());</span><br><span class="line">			queue_.<span class="built_in">pop</span>();</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function">std::<span class="keyword">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">			<span class="function">std::scoped_lock <span class="title">lock</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">			<span class="keyword">return</span> queue_.<span class="built_in">size</span>();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">			<span class="function">std::scoped_lock <span class="title">lock</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">			<span class="keyword">return</span> queue_.<span class="built_in">empty</span>();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="function">std::scoped_lock <span class="title">lock</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">				stop_ = <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			cond_.<span class="built_in">notify_all</span>();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		std::condition_variable cond_;</span><br><span class="line">		<span class="keyword">mutable</span> std::mutex mtx_;</span><br><span class="line">		std::queue&lt;T&gt; queue_;</span><br><span class="line">		<span class="keyword">bool</span> stop_ = <span class="literal">false</span>;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">&#125;;<span class="comment">// namespace Diana</span></span><br></pre></td></tr></table></figure>

<p>线程安全任务队列需要注意的细节不多。注意一下这里写了两个push方法，原因是在该模板类特化后，T已经是一个具体的类型，T&amp;&amp;就不再是泛型编程中常见的万能引用，而是一个单纯的右值了。我们可以通过再添加一个模板成员函数来合并两个push：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(U&amp;&amp; item)</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in"><span class="keyword">static_assert</span></span>(std::is_same&lt;U,T&gt;::value==<span class="literal">true</span>);</span><br><span class="line">        <span class="function">std::scoped_lock <span class="title">lock</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">        queue_.<span class="built_in">push</span>(std::forward(item));</span><br><span class="line">    &#125;</span><br><span class="line">    cond_.<span class="built_in">notify_one</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要注意的是，记得判断一下U和T的类型是一样的。</p>
<p>利用这个安全队列，我们可以重写一下单任务队列的线程池：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Diana &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">using</span> WorkItem = std::function&lt;<span class="built_in"><span class="keyword">void</span></span>()&gt;;</span><br><span class="line">	<span class="comment">// * 简易多线程单任务队列线程池，使用SafeQueue线程安全队列。</span></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">SimplePool</span> &#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="keyword">explicit</span> <span class="title">SimplePool</span><span class="params">(<span class="keyword">size_t</span> threads = std::thread::hardware_concurrency())</span> </span>&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; threads; ++i) &#123;</span><br><span class="line">				workers_.<span class="built_in">emplace_back</span>([<span class="keyword">this</span>]() &#123;</span><br><span class="line">					<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">						std::function&lt;<span class="built_in"><span class="keyword">void</span></span>()&gt; task;</span><br><span class="line">						<span class="keyword">if</span> (!queue_.<span class="built_in">pop</span>(task))</span><br><span class="line">							<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">						<span class="keyword">if</span> (task)</span><br><span class="line">							<span class="built_in">task</span>();</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(WorkItem item)</span> </span>&#123;</span><br><span class="line">			queue_.<span class="built_in">push</span>(std::<span class="built_in">move</span>(item));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		~<span class="built_in">SimplePool</span>() &#123;</span><br><span class="line">			queue_.<span class="built_in">stop</span>();</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; thd: workers_)</span><br><span class="line">				thd.<span class="built_in">join</span>();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		SafeQueue&lt;WorkItem&gt; queue_;</span><br><span class="line">		std::vector&lt;std::thread&gt; workers_;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">&#125;;<span class="comment">// namespace Diana</span></span><br></pre></td></tr></table></figure>

<p>入队接口enqueue()史诗级简化。当然，这种简化也带来一些不便：使用std::function&lt;void()&gt;作为参数，不想前面的那个传入可调用对象及其参数，在实际使用时需要用户进行包装，这个会在后面功能测试的时候讲。</p>
<hr>
<h2 id="多任务队列线程池"><a href="#多任务队列线程池" class="headerlink" title="多任务队列线程池"></a>多任务队列线程池</h2><p>其实多任务队列的线程池的设计思路也是很简单的：每个线程对应着一个自己的任务队列。因为前面对任务队列进行了抽取重构，编写一个多任务队列的线程池也非常简单。</p>
<p>我们对原本单任务队列的线程池的入队接口进行改造：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">schedule_by_id</span><span class="params">(WorkItem fn, <span class="keyword">size_t</span> id = <span class="number">-1</span>)</span></span></span><br></pre></td></tr></table></figure>

<p>当提交一个任务时，我们可以指定它放到任意一个线程的任务队列中。在用户没有指定任务队列时，就为该任务随机选择一个线程所对应的任务队列。</p>
<h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><p>简单多任务队列线程池实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Diana &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">using</span> WorkItem = std::function&lt;<span class="built_in"><span class="keyword">void</span></span>()&gt;;</span><br><span class="line">	<span class="comment">// * 简易多线程多任务队列线程池，使用SafeQueue线程安全队列。</span></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">MultiplePool</span> &#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="keyword">explicit</span> <span class="title">MultiplePool</span><span class="params">(<span class="keyword">size_t</span> thread_num = std::thread::hardware_concurrency())</span></span></span><br><span class="line"><span class="function">			: queues_(thread_num),</span></span><br><span class="line"><span class="function">			  thread_num_(thread_num) &#123;</span></span><br><span class="line">			<span class="keyword">auto</span> worker = [<span class="keyword">this</span>](<span class="keyword">size_t</span> id) &#123;</span><br><span class="line">				<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">					WorkItem task&#123;&#125;;</span><br><span class="line">					<span class="keyword">if</span> (!queues_[id].<span class="built_in">pop</span>(task))</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">					<span class="keyword">if</span> (task)</span><br><span class="line">						<span class="built_in">task</span>();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;;</span><br><span class="line"></span><br><span class="line">			workers_.<span class="built_in">reserve</span>(thread_num_);</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; thread_num_; ++i) &#123;</span><br><span class="line">				workers_.<span class="built_in">emplace_back</span>(worker, i);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">int</span> <span class="title">schedule_by_id</span><span class="params">(WorkItem fn, <span class="keyword">size_t</span> id = <span class="number">-1</span>)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (fn == <span class="literal">nullptr</span>)</span><br><span class="line">				<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (id == <span class="number">-1</span>) &#123;</span><br><span class="line">				id = <span class="built_in">rand</span>() % thread_num_;<span class="comment">// 随机插入到一个线程的任务队列中</span></span><br><span class="line">				queues_[id].<span class="built_in">push</span>(std::<span class="built_in">move</span>(fn));</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="built_in">assert</span>(id &lt; thread_num_);<span class="comment">// 插入指定线程的任务队列</span></span><br><span class="line">				queues_[id].<span class="built_in">push</span>(std::<span class="built_in">move</span>(fn));</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		~<span class="built_in">MultiplePool</span>() &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; queue: queues_) &#123;</span><br><span class="line">				queue.<span class="built_in">stop</span>();<span class="comment">// 停止每一个任务队列</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; worker: workers_) &#123;</span><br><span class="line">				worker.<span class="built_in">join</span>();<span class="comment">// 阻塞，等待每个线程执行结束</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		std::vector&lt;Diana::SafeQueue&lt;WorkItem&gt;&gt; queues_;<span class="comment">// 每个线程对应一个任务队列</span></span><br><span class="line">		<span class="keyword">size_t</span> thread_num_;</span><br><span class="line">		std::vector&lt;std::thread&gt; workers_;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">&#125;;<span class="comment">// namespace Diana</span></span><br></pre></td></tr></table></figure>

<p>需要注意的细节也在代码注释中写明了。</p>
<hr>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>我们编写如下测试代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_thread_pool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;test_thread_pool()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	Diana::ThreadPool threadPool;</span><br><span class="line">	threadPool.<span class="built_in">enqueue</span>([] &#123; std::cout &lt;&lt; <span class="string">&quot;hello\n&quot;</span>; &#125;);</span><br><span class="line">	<span class="keyword">auto</span> future = threadPool.<span class="built_in">enqueue</span>([](std::string str) &#123; <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span> + str; &#125;, <span class="string">&quot;world&quot;</span>);</span><br><span class="line">	std::cout &lt;&lt; future.<span class="built_in">get</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">funA</span><span class="params">(std::string str)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;hello&quot;</span> + str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_simple_thread_pool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;test_simple_thread_pool()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	Diana::SimplePool threadPool;</span><br><span class="line">	threadPool.<span class="built_in">enqueue</span>([] &#123; std::cout &lt;&lt; <span class="string">&quot;hello\n&quot;</span>; &#125;);</span><br><span class="line">	<span class="comment">// * 此处必须使用shared_ptr进行包装，</span></span><br><span class="line">	<span class="comment">// * 否则在std::function&lt;void()&gt;中会尝试生成std::packaged_task的拷贝构造函数，</span></span><br><span class="line">	<span class="comment">// ! std::packaged_task禁止拷贝操作</span></span><br><span class="line">	<span class="keyword">auto</span> task = std::make_shared&lt;std::packaged_task&lt;std::<span class="built_in">string</span>()&gt;&gt;(std::<span class="built_in">bind</span>(funA, <span class="string">&quot;world&quot;</span>));</span><br><span class="line">	std::future&lt;std::string&gt; res = task-&gt;<span class="built_in">get_future</span>();</span><br><span class="line">	threadPool.<span class="built_in">enqueue</span>([task = std::<span class="built_in">move</span>(task)] &#123; (*task)(); &#125;);</span><br><span class="line">    <span class="comment">// ! 以下实现方法是错误的</span></span><br><span class="line">	<span class="comment">//	auto task = std::packaged_task&lt;std::string()&gt;(std::bind(funA, &quot;world&quot;));</span></span><br><span class="line">	<span class="comment">//	std::future&lt;std::string&gt; res = task.get_future();</span></span><br><span class="line">	<span class="comment">//	threadPool.enqueue(std::move(task));</span></span><br><span class="line">	std::cout &lt;&lt; res.<span class="built_in">get</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_multiple_thread_pool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;test_multiple_thread_pool&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	Diana::MultiplePool threadPool;</span><br><span class="line">	threadPool.<span class="built_in">schedule_by_id</span>([] &#123; std::cout &lt;&lt; <span class="string">&quot;hello\n&quot;</span>; &#125;);</span><br><span class="line">	<span class="keyword">auto</span> task = std::make_shared&lt;std::packaged_task&lt;std::<span class="built_in">string</span>()&gt;&gt;(std::<span class="built_in">bind</span>(funA, <span class="string">&quot;world&quot;</span>));</span><br><span class="line">	std::future&lt;std::string&gt; res = task-&gt;<span class="built_in">get_future</span>();</span><br><span class="line">	threadPool.<span class="built_in">schedule_by_id</span>([task = std::<span class="built_in">move</span>(task)] &#123; (*task)(); &#125;);</span><br><span class="line">	std::cout &lt;&lt; res.<span class="built_in">get</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们分别为三个版本的线程池（未重构的单任务队列线程池+重构后的单任务队列线程池+多任务队列线程池）编写了接口测试。</p>
<p>未重构的单任务队列线程池，因为接口简单，没有什么需要特别注意的东西。</p>
<p>重构后的单任务队列线程池和多任务队列线程池，可以看到我写了一些注释，还注释了一些错误的任务提交方式。还记得前面重构时，我们把提交任务的接口参数改成了std::function&lt;void()&gt;嘛？为了配合这个参数格式，以及利用future进行异步编程，我们需要对异步获取结果的方法进行包装（之前的版本在入队接口中为用户做了这些事情）。比较需要注意的一点是我们需要用一个shared_ptr智能指针来对packaged_task进行包装，这是因为在std::function&lt;void()&gt;中会尝试生成std::packaged_task的拷贝构造函数，而std::packaged_task是禁止进行拷贝操作的，这会引起编译器的报错（感谢群里的大佬帮我整明白了这个事情）。</p>
<blockquote>
<p><a href="https://zh.cppreference.com/w/cpp/utility/functional/function">cppreference-std::funtion：</a></p>
<p>类模板 <code>std::function</code> 是通用多态函数包装器。 <code>std::function</code> 的实例能存储、复制及调用任何<a href="https://zh.cppreference.com/w/cpp/named_req/CopyConstructible"><em>可复制构造</em> <em>(CopyConstructible)</em> </a>的<a href="https://zh.cppreference.com/w/cpp/named_req/Callable"><em>可调用</em> <em>(Callable)</em> </a><em>目标</em>——函数、 <a href="https://zh.cppreference.com/w/cpp/language/lambda">lambda 表达式</a>、 <a href="https://zh.cppreference.com/w/cpp/utility/functional/bind">bind 表达式</a>或其他函数对象，还有指向成员函数指针和指向数据成员指针。</p>
<p>存储的可调用对象被称为 <code>std::function</code> 的<em>目标</em>。若 <code>std::function</code> 不含目标，则称它为<em>空</em>。调用<em>空</em> <code>std::function</code> 的<em>目标</em>导致抛出 <a href="https://zh.cppreference.com/w/cpp/utility/functional/bad_function_call">std::bad_function_call</a> 异常。</p>
<p><code>std::function</code> 满足<a href="https://zh.cppreference.com/w/cpp/named_req/CopyConstructible"><em>可复制构造</em> <em>(CopyConstructible)</em> </a>和<a href="https://zh.cppreference.com/w/cpp/named_req/CopyAssignable"><em>可复制赋值</em> <em>(CopyAssignable)</em> </a>。</p>
</blockquote>
<blockquote>
<p><a href="https://zh.cppreference.com/w/cpp/thread/packaged_task/packaged_task">cppreference-std::packaged_task构造函数：</a></p>
<p>构造新的 <code>std::packaged_task</code> 对象。</p>
<ol>
<li><p>…</p>
</li>
<li><p>复制构造函数被删除， <code>std::packaged_task</code> 仅可移动。</p>
</li>
<li><p>…</p>
</li>
</ol>
</blockquote>
<h2 id="性能比较"><a href="#性能比较" class="headerlink" title="性能比较"></a>性能比较</h2><p>根据性能测试，重构和未重构版本的单任务队列线程池有着细微的性能差别（未重构版本略优）。而在数据量足够大的情况下，因为多任务队列的设计，多任务队列线程池性能甚至达到了单任务队列线程池的两倍。</p>
<h2 id="写在后面"><a href="#写在后面" class="headerlink" title="写在后面"></a>写在后面</h2><p>后面大概还会继续研究一下work steal线程池，也会写篇学习心得=。=</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol>
<li><a href="http://www.purecpp.org/detail?id=2260">Purecpp：聊聊线程池（一）</a></li>
<li><a href="http://www.purecpp.org/detail?id=2261">Purecpp：聊聊线程池（二）</a></li>
</ol>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>C++11</tag>
        <tag>C++17</tag>
        <tag>学习心得</tag>
        <tag>C++14</tag>
        <tag>C++并发</tag>
      </tags>
  </entry>
</search>
